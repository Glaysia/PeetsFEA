"""
This type stub file was generated by pyright.
"""

import sys
from ansys.aedt.core.generic.general_methods import pyaedt_function_handler

open3 = ...
if sys.version_info < (3, 0):
    ...
@pyaedt_function_handler()
def identify_setup(props): # -> bool:
    """Identify if a setup's properties is based on a time or frequency domain.

    Parameters
    ----------
    props : dict
        Dictionary of the properties.

    Returns
    -------
    bool
        `True` if domain is a time. `False` if the domain is for a frequency and sweeps.
    """
    ...

class SweepCommon:
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class SweepHFSS(SweepCommon):
    """Initializes, creates, and updates sweeps in HFSS.

    Parameters
    ----------
    setup : :class 'from ansys.aedt.core.modules.solve_setup.Setup'
        Setup to use for the analysis.
    name : str
        Name of the sweep.
    sweep_type : str, optional
        Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
        and ``"Discrete"``. The default is ``"Interpolating"``.
    props : dict, optional
        Dictionary of the properties. The default is ``None``, in which case
        the default properties are retrieved.

    Examples
    --------
    >>> hfss = Hfss(version=version, project=proj, design=gtemDesign, solution_type=solutiontype,
                    name=name, new_desktop=False, close_on_exit=False)
    >>> hfss_setup = hfss.setups[0]
    >>> hfss_sweep = SweepHFSS(hfss_setup, "Sweep", sweep_type="Interpolating", props=None)

    """
    def __init__(self, setup, name, sweep_type=..., props=...) -> None:
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for the sweep.

        Returns
        -------
        bool
            `True` if solutions are available.
        """
        ...
    
    @property
    def frequencies(self): # -> list[Any]:
        """List of all frequencies of the active sweep.

        To see values, the project must be saved and solved.

        Returns
        -------
        list of float
            Frequency points.
        """
        ...
    
    @property
    def basis_frequencies(self): # -> list[Any]:
        """List of all frequencies that have fields available.

        To see values, the project must be saved and solved.

        Returns
        -------
        list of float
            Frequency points.
        """
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def add_subrange(self, range_type, start, end=..., count=..., unit=..., save_single_fields=..., clear=...): # -> Literal[True]:
        """Add a range to the sweep.

        Parameters
        ----------
        range_type : str
            Type of the range. Options are ``"LinearCount"``,
            ``"LinearStep"``, ``"LogScale"``, and ``"SinglePoints"``.
        start : float
            Starting frequency.
        end : float, optional
            Stopping frequency. The default value is ``None``. A value is required for
            ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
        count : int or float, optional
            Frequency count or frequency step. The default is ``None``. A value is required for
            ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
        unit : str, optional
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"GHz"``.
        save_single_fields : bool, optional
            Whether to save the fields of the single point. The default is ``False``.
            This parameter is used only for ``range_type="SinglePoints"``.
        clear : bool, optional
            Whether to suppress all other subranges except the current one under creation.
            The default value is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        Examples
        --------
        Create a setup in an HFSS design and add multiple sweep ranges.

        >>> setup = hfss.create_setup(name="MySetup")
        >>> sweep = setup.add_sweep()
        >>> sweep.change_type("Interpolating")
        >>> sweep.change_range("LinearStep", 1.1, 2.1, 0.4, "GHz")
        >>> sweep.add_subrange("LinearCount", 1, 1.5, 5, "MHz")
        >>> sweep.add_subrange("LogScale", 1, 3, 10, "GHz")

        """
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> Literal[True]:
        """Create a sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def update(self): # -> Literal[True]:
        """Update a sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    


class SweepHFSS3DLayout(SweepCommon):
    """Initializes, creates, and updates sweeps in HFSS 3D Layout.

    Parameters
    ----------
    setup : :class 'from ansys.aedt.core.modules.solve_setup.Setup'
        Setup to use for the analysis.
    name : str
        Name of the sweep.
    sweep_type : str, optional
        Type of the sweep. Options are ``"Interpolating"`` and ``"Discrete"``. The default is ``"Interpolating"``.
    save_fields : bool, optional
        Whether to save the fields. The default is ``True``.
    props : dict, optional
        Dictionary of the properties. The default is ``None``, in which
        case the default properties are retrieved.

    """
    def __init__(self, setup, name, sweep_type=..., save_fields=..., props=..., **kwargs) -> None:
        ...
    
    @property
    def combined_name(self): # -> str:
        """Compute the name : sweep_name string.

        Returns
        -------
        str
        """
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for the sweep.

        Returns
        -------
        bool
            `True` if solutions are available.
        """
        ...
    
    @pyaedt_function_handler(sweeptype="sweep_type")
    def change_type(self, sweep_type): # -> Literal[True]:
        """Change the type of the sweep.

        Parameters
        ----------
        sweep_type : str
            Type of the sweep. Options are ``"Interpolating"`` and ``"Discrete"``.
            The default is ``"Interpolating"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def set_save_fields(self, save_fields, save_rad_fields=...): # -> Literal[True]:
        """Choose whether to save fields.

        Parameters
        ----------
        save_fields : bool
            Whether to save the fields.
        save_rad_fields : bool, optional
            Whether to save the radiating fields. The default is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def add_subrange(self, range_type, start, end=..., count=..., unit=...):
        """Add a subrange to the sweep.

        Parameters
        ----------
        range_type : str
            Type of the subrange. Options are ``"LinearCount"``, ``"SinglePoint"``,
            ``"LinearStep"``, and ``"LogScale"``.
        start : float
            Starting frequency.
        end : float, optional
            Stopping frequency. The default is ``None``. A value is
            required for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
        count : int or float, optional
            Frequency count or frequency step. The default is ``None``.
            A value is required for these subranges: ``"LinearCount"``, ``"LinearStep"``,
            and ``"LogScale"``.
        unit : str
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"GHz"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def change_range(self, range_type, start, end=..., count=..., unit=...): # -> Literal[True]:
        """Change the range of the sweep.

        Parameters
        ----------
        range_type : str
            Type of the subrange. Options are ``"LinearCount"``, ``"SinglePoint"``,
            ``"LinearStep"``, and ``"LogScale"``.
        start : float
            Starting frequency.
        end : float, optional
            Stopping frequency. The default is ``None``.  A value is required
            for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
        count : int or float, optional
            Frequency count or frequency step. The default is ``None``.
            A value is required for these subranges: ``"LinearCount"``,
            ``"LinearStep"``, and ``"LogScale"``.
        unit : str, optional
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"GHz"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> Literal[True]:
        """Create a sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def update(self): # -> Literal[True]:
        """Update the sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    


class SweepMatrix(SweepCommon):
    """Initializes, creates, and updates sweeps in Q3D.

    Parameters
    ----------
    setup : :class 'from ansys.aedt.core.modules.solve_setup.Setup'
        Setup used for the analysis.
    name : str
        Name of the sweep.
    sweep_type : str, optional
        Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
        and ``"Discrete"``. The default is ``"Interpolating"``.
    props : dict
        Dictionary of the properties.  The default is ``None``, in which case
        the default properties are retrieved.
    """
    def __init__(self, setup, name, sweep_type=..., props=...) -> None:
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for given sweep.

        Returns
        -------
        bool
            `True` if solutions are available.
        """
        ...
    
    @property
    def frequencies(self): # -> list[Any]:
        """List of all frequencies of the active sweep.

        To see values, the project must be saved and solved.

        Returns
        -------
        list of float
            Frequency points.
        """
        ...
    
    @property
    def basis_frequencies(self): # -> list[Any]:
        """Get the list of all frequencies that have fields available.

        The project has to be saved and solved to see values.

        Returns
        -------
        list of float
            Frequency points.
        """
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def add_subrange(self, range_type, start, end=..., count=..., unit=..., clear=..., **kwargs): # -> Literal[True]:
        """Add a subrange to the sweep.

        Parameters
        ----------
        range_type : str
            Type of the subrange. Options are ``"LinearCount"``,
            ``"LinearStep"``, and ``"LogScale"``.
        start : float
            Starting frequency.
        end : float
            Stopping frequency. The default is ``None``.
        count : int or float
            Frequency count or frequency step. The default is ``None``.
        unit : str, optional
            Frequency units.
        clear : bool, optional
            Whether to replace the subrange. The default is ``False``, in which case
            subranges are appended.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> Literal[True]:
        """Create a sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def update(self): # -> Literal[True]:
        """Update the sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    


class SweepMaxwellEC(SweepCommon):
    """Initializes, creates, and updates sweeps in Maxwell Eddy Current.

    Parameters
    ----------
    setup : :class 'from ansys.aedt.core.modules.solve_setup.Setup'
        Setup used for the analysis.
    name : str
        Name of the sweep.
    sweep_type : str, optional
        Type of the sweep. Options are ``"LinearStep"``, ``"LinearCount"``,
         ``"LogScale"`` and ``"SinglePoints"``. The default is ``"LinearStep"``.
    props : dict
        Dictionary of the properties.  The default is ``None``, in which case
        the default properties are retrieved.
    """
    def __init__(self, setup, sweep_type=..., props=...) -> None:
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for the sweep.

        Returns
        -------
        bool
            `True` if solutions are available.
        """
        ...
    
    @property
    def frequencies(self): # -> list[Any]:
        """List of all frequencies of the active sweep.

        To see values, the project must be saved and solved.

        Returns
        -------
        list of float
            Frequency points.
        """
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> Literal[True]:
        """Create a Maxwell Eddy Current sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def update(self): # -> Literal[True]:
        """Update a Maxwell Eddy Current sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def delete(self): # -> Literal[True]:
        """Delete a Maxwell Eddy Current sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    


class SetupProps(dict):
    """Provides internal parameters for the AEDT boundary component."""
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __init__(self, setup, props) -> None:
        ...
    
    def delete_all(self): # -> None:
        ...
    


