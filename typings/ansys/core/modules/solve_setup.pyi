"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.generic.general_methods import PropsManager, pyaedt_function_handler
from ansys.aedt.core.modeler.cad.elements_3d import BinaryTreeNode

"""
This module contains these classes: `Setup`, `Setup3DLayout`, and `SetupCircuit`.

This module provides all functionalities for creating and editing setups in AEDT.
It is based on templates to allow for easy creation and modification of setup properties.
"""
class CommonSetup(PropsManager, BinaryTreeNode):
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @property
    def sweeps(self): # -> list[Any] | None:
        ...
    
    @property
    def default_intrinsics(self): # -> dict[Any, Any]:
        """Retrieve default intrinsic for actual setup.

        Returns
        -------
        dict
            Dictionary which keys are typically Freq, Phase or Time.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    @pyaedt_function_handler(num_cores="cores", num_tasks="tasks", num_gpu="gpus")
    def analyze(self, cores=..., tasks=..., gpus=..., acf_file=..., use_auto_settings=..., solve_in_batch=..., machine=..., run_in_thread=..., revert_to_initial_mesh=..., blocking=...): # -> None:
        """Solve the active design.

        Parameters
        ----------
        cores : int, optional
            Number of simulation cores. The default is ``1``.
        tasks : int, optional
            Number of simulation tasks. The default is ``1``.
        gpus : int, optional
            Number of simulation graphic processing units to use. The default is ``0``.
        acf_file : str, optional
            Full path to the custom ACF file.
        use_auto_settings : bool, optional
            Set ``True`` to use automatic settings for HPC. The option is only considered for setups
            that support automatic settings.
        solve_in_batch : bool, optional
            Whether to solve the project in batch or not.
            If ``True`` the project will be saved, closed, and solved.
        machine : str, optional
            Name of the machine if remote.  The default is ``"localhost"``.
        run_in_thread : bool, optional
            Whether to submit the batch command as a thread. The default is
            ``False``.
        revert_to_initial_mesh : bool, optional
            Whether to revert to initial mesh before solving or not. Default is ``False``.
        blocking : bool, optional
            Whether to block script while analysis is completed or not. It works from AEDT 2023 R2.
            Default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.Analyze
        """
        ...
    
    @property
    def props(self): # -> SetupProps | dict[Any, Any]:
        """Properties of the setup."""
        ...
    
    @props.setter
    def props(self, value): # -> None:
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for given setup.

        Returns
        -------
        bool
            ``True`` if solutions are available, ``False`` otherwise.
        """
        ...
    
    @property
    def omodule(self):
        """Analysis module."""
        ...
    
    @property
    def name(self): # -> str:
        """Name."""
        ...
    
    @name.setter
    def name(self, name): # -> None:
        ...
    
    @pyaedt_function_handler()
    def get_profile(self): # -> dict[Any, Any] | None:
        """Solution profile.

        Returns
        -------
        dict of :class:ansys.aedt.core.modeler.cad.elements_3d.BinaryTree when solved setups exist,
        ``None`` when no solved setups or no compatible application exists.
        """
        ...
    
    @pyaedt_function_handler(sweep_name="sweep")
    def get_solution_data(self, expressions=..., domain=..., variations=..., primary_sweep_variable=..., report_category=..., context=..., polyline_points=..., math_formula=..., sweep=...): # -> None:
        """Get a simulation result from a solved setup and cast it in a ``SolutionData`` object.

        Data to be retrieved from Electronics Desktop are any simulation results available in that
        specific simulation context.
        Most of the argument have some defaults which works for most of the ``Standard`` report quantities.

        Parameters
        ----------
        expressions : str or list, optional
            One or more formulas to add to the report. Example is value ``"dB(S(1,1))"`` or a list of values.
            Default is `None` which will return all traces.
        domain : str, optional
            Plot Domain. Options are "Sweep" for frequency domain related results and "Time" for transient related data.
        variations : dict, optional
            Dictionary of all families including the primary sweep.
            The default is ``None`` which will use the nominal variations of the setup.
        primary_sweep_variable : str, optional
            Name of the primary sweep. The default is ``"None"`` which, depending on the context,
            will internally assign the primary sweep to:
            1. ``Freq`` for frequency domain results,
            2. ``Time`` for transient results,
            3. ``Theta`` for radiation patterns,
            4. ``distance`` for field plot over a polyline.
        report_category : str, optional
            Category of the Report to be created. If `None` default data Report will be used.
            The Report Category can be one of the types available for creating a report depend on the simulation setup.
            For example for a Far Field Plot in HFSS the UI shows the report category as "Create Far Fields Report".
            The report category will be in this case "Far Fields".
            Depending on the setup different categories are available.
            If `None` default category will be used (the first item in the Results drop down menu in AEDT).
            To get the list of available categories user can use method ``available_report_types``.
        context : str, dict, optional
            This is the context of the report.
            The default is ``None``. It can be:
            1. `None`
            2. Infinite Sphere name for Far Fields Plot.
            3. Dictionary. If dictionary is passed, key is the report property name and value is property value.
        polyline_points : int, optional
            Number of points on which to create the report for plots on polylines.
            This parameter is valid for ``Fields`` plot only.
        math_formula : str, optional
            One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.
        sweep : str, optional
            Name of the sweep adaptive setup to get solutions from. the default is ``LastAdaptive``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solutions.SolutionData`
            Solution Data object.

        References
        ----------
        >>> oModule.GetSolutionDataPerVariation

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> aedtapp = Hfss()
        >>> aedtapp.post.create_report("dB(S(1,1))")

        >>> variations = aedtapp.available_variations.nominal_values
        >>> variations["Theta"] = ["All"]
        >>> variations["Phi"] = ["All"]
        >>> variations["Freq"] = ["30GHz"]
        >>> data1 = aedtapp.post.get_solution_data(
        ...     "GainTotal",
        ...     aedtapp.nominal_adaptive,
        ...     variations=variations,
        ...     primary_sweep_variable="Phi",
        ...     report_category="Far Fields",
        ...     context="3D",
        ... )

        >>> data2 = aedtapp.post.get_solution_data("S(1,1)", aedtapp.nominal_sweep, variations=variations)
        >>> data2.plot()

        >>> from ansys.aedt.core import Maxwell2d
        >>> maxwell_2d = Maxwell2d()
        >>> data3 = maxwell_2d.post.get_solution_data("InputCurrent(PHA)", domain="Time", primary_sweep_variable="Time")
        >>> data3.plot("InputCurrent(PHA)")

        >>> from ansys.aedt.core import Circuit
        >>> circuit = Circuit()
        >>> context = {"algorithm": "FFT", "max_frequency": "100MHz", "time_stop": "2.5us", "time_start": "0ps"}
        >>> spectralPlotData = circuit.post.get_solution_data(
        ...     expressions="V(Vprobe1)", domain="Spectral", primary_sweep_variable="Spectrum", context=context
        ... )
        """
        ...
    
    @pyaedt_function_handler(sweep_name="sweep", plotname="name")
    def create_report(self, expressions=..., domain=..., variations=..., primary_sweep_variable=..., secondary_sweep_variable=..., report_category=..., plot_type=..., context=..., subdesign_id=..., polyline_points=..., name=..., sweep=...): # -> None:
        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plot, or data table.

        Parameters
        ----------
        expressions : str or list, optional
            One or more formulas to add to the report. Example is value = ``"dB(S(1,1))"``.
        domain : str, optional
            Plot Domain. Options are "Sweep", "Time", "DCIR".
        variations : dict, optional
            Dictionary of all families including the primary sweep. The default is ``{"Freq": ["All"]}``.
        primary_sweep_variable : str, optional
            Name of the primary sweep. The default is ``"Freq"``.
        secondary_sweep_variable : str, optional
            Name of the secondary sweep variable in 3D Plots.
        report_category : str, optional
            Category of the Report to be created. If `None` default data Report will be used.
            The Report Category can be one of the types available for creating a report depend on the simulation setup.
            For example for a Far Field Plot in HFSS the UI shows the report category as "Create Far Fields Report".
            The report category will be in this case "Far Fields".
            Depending on the setup different categories are available.
            If `None` default category will be used (the first item in the Results drop down menu in AEDT).
        plot_type : str, optional
            The format of Data Visualization. Default is ``Rectangular Plot``.
        context : str, optional
            The default is ``None``. It can be `None`, `"Differential Pairs"`,`"RL"`,
            `"Sources"`, `"Vias"`,`"Bondwires"`, `"Probes"` for Hfss3dLayout or
            Reduce Matrix Name for Q2d/Q3d solution or Infinite Sphere name for Far Fields Plot.
        name : str, optional
            Name of the plot. The default is ``None``.
        polyline_points : int, optional,
            Number of points for creating the report for plots on polylines.
        subdesign_id : int, optional
            Specify a subdesign ID to export a Touchstone file of this subdesign to.
            This parameter is valid only for a circuit.
            The default value is ``None``.
        sweep : str, optional
            Name of the sweep adaptive setup to get solutions from. The default is ``LastAdaptive``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.report_templates.Standard`
            ``True`` when successful, ``False`` when failed.


        References
        ----------
        >>> oModule.CreateReport

        Examples
        --------
        >>> from ansys.aedt.core import Circuit
        >>> aedtapp = Circuit()
        >>> aedtapp.post.create_report("dB(S(1,1))")

        >>> variations = aedtapp.available_variations.nominal_values
        >>> aedtapp.post.setups[0].create_report("dB(S(1,1))", variations=variations, primary_sweep_variable="Freq")

        >>> aedtapp.post.create_report("S(1,1)", variations=variations, plot_type="Smith Chart")
        """
        ...
    


class Setup(CommonSetup):
    """Initializes, creates, and updates a 3D setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis.Analysis`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> bool:
        """Add a new setup based on class settings in AEDT.

        Returns
        -------
        bool
            Result of operation.

        References
        ----------
        >>> oModule.InsertSetup
        """
        ...
    
    @pyaedt_function_handler(update_dictionary="properties")
    def update(self, properties=...): # -> Literal[True]:
        """Update the setup based on either the class argument or a dictionary.

        Parameters
        ----------
        properties : optional
            Dictionary to use to update the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def delete(self): # -> Literal[True]:
        """Delete actual Setup.

        Returns
        -------
        bool
            ``True`` if setup is deleted. ``False`` if it failed.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_expression_cache(self, expressions, report_type=..., intrinsics=..., isconvergence=..., isrelativeconvergence=..., conv_criteria=..., use_cache_for_pass=..., use_cache_for_freq=...): # -> Literal[True]:
        """Enable an expression cache.

        Parameters
        ----------
        expressions : str or list
            One or more formulas to add to the expression cache.
        report_type : str or list, optional
            Type of the report for the expression. The default is ``Fields``. If a list of expressions
            is supplied, supply a corresponding list of report types.
        intrinsics : str or list, optional
            Intrinsic functions for the expressions. The default is ``""``. If a list of expressions
            is supplied, a corresponding list of intrinsic functions must be supplied.
        isconvergence : bool or str or list, optional
            Whether the expression is in the convergence criteria. The default is ``True``.
            If a list of expressions is supplied, a corresponding list of Boolean values must be
            supplied.
        isrelativeconvergence : bool, optional
            The default is ``True``.
        conv_criteria :
            The default is ``1``.
        use_cache_for_pass : bool, optional
            Use cache for pass.
            Default value is ``True``.
        use_cache_for_freq : bool, optional
            Use cache for frequency.
            Default value is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler(setup_name="name")
    def enable(self): # -> Literal[True]:
        """Enable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def disable(self): # -> Literal[True]:
        """Disable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler(design_name="design", solution_name="solution", parameters_dict="parameters", project_name="project")
    def add_mesh_link(self, design, solution=..., parameters=..., project=..., force_source_to_solve=..., preserve_partner_solution=..., apply_mesh_operations=..., adapt_port=...):
        """Import mesh from a source design solution to the target design.

        Parameters
        ----------
        design : str
            Name of the source design from which the mesh is imported.
        solution : str, optional
            Name of the source design solution in the format ``"name : solution_name"``.
            If ``None``, the default value is taken from the nominal adaptive solution.
        parameters : dict, optional
            Dictionary of the "mapping" variables from the source design.
            If ``None``, the default is `appname.available_variations.nominal_values`.
        project : str, optional
            Name of the project with the design. The default is ``"This Project*"``.
            However, you can supply the full path and name to another project.
        force_source_to_solve : bool, optional
            Default value is ``True``.
        preserve_partner_solution : bool, optional
            Default value is ``True``.
        apply_mesh_operations : bool, optional
            Apply mesh operations in target design on the imported mesh.
            Default value is ``True``.
        adapt_port : bool, optional
            Perform port adapt/seeding in target solve setup.
            Default value is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup

        Examples
        --------
        >>> from ansys.aedt.core import Maxwell3d
        >>> m3d = Maxwell3d(design="target_design")
        >>> target_setup = m3d.create_setup(name="target_setup")
        The target design is duplicated and made it active.
        The duplicated design will be the source design from which the mesh is imported.
        >>> m3d.duplicate_design(name="target_design", save_after_duplicate=True)
        >>> m3d.rename_design(name="source_design")
        >>> m3d.create_setup(name="source_setup")
        Activate the target design.
        >>> m3d.set_active_design("target_design")
        The mesh link is assigned to the target design.
        >>> target_setup.add_mesh_link("source_design")
        >>> m3d.release_desktop()
        """
        ...
    
    @pyaedt_function_handler(design_name="design", solution_name="solution", parameters_dict="parameters", project_name="project")
    def start_continue_from_previous_setup(self, design, solution, map_variables_by_name=..., parameters=..., project=..., force_source_to_solve=..., preserve_partner_solution=...): # -> bool:
        """Start or continue from a previously solved setup.

        Parameters
        ----------
        design : str
            Name of the design.
        solution : str
            Name of the solution in the format ``"name : solution_name"``.
            For example, ``"Setup1 : Transient", "MySetup : LastAdaptive"``.
        map_variables_by_name : bool, optional
            Whether variables are mapped by name from the source design. The default is
            ``True``.
        parameters : dict, optional
            Dictionary of the parameters. This parameter is not considered if
            ``map_variables_by_name=True``. If ``None``, the default is
            ``appname.available_variations.nominal_values``.
        project : str, optional
            Name of the project with the design. The default is ``"This Project*"``.
            However, you can supply the full path and name to another project.
        force_source_to_solve : bool, optional
            The default is ``True``.
        preserve_partner_solution : bool, optional
            The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup

        Examples
        --------
        >>> m2d = ansys.aedt.core.Maxwell2d()
        >>> setup = m2d.get_setup("Setup1")
        >>> setup.start_continue_from_previous_setup(design="IM", solution="Setup1 : Transient")
        """
        ...
    


class SetupCircuit(CommonSetup):
    """Manages a circuit setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis_nexxim.FieldAnalysisCircuit`
        Inherited app object.
    solution_type : str, int
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
      Whether to create the setup from a template. The default is ``True.``
      If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @property
    def props(self): # -> SetupProps:
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> bool:
        """Add a new setup based on class settings in AEDT.

        Returns
        -------
        bool
            Result of operation.

        References
        ----------
        >>> oModule.AddLinearNetworkAnalysis
        >>> oModule.AddDCAnalysis
        >>> oModule.AddTransient
        >>> oModule.AddQuickEyeAnalysis
        >>> oModule.AddVerifEyeAnalysis
        >>> oModule.AddAMIAnalysis
        """
        ...
    
    @pyaedt_function_handler(update_dictionary="properties")
    def update(self, properties=...): # -> Literal[True]:
        """Update the setup based on the class arguments or a dictionary.

        Parameters
        ----------
        properties : dict, optional
            Dictionary of settings to apply. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditLinearNetworkAnalysis
        >>> oModule.EditDCAnalysis
        >>> oModule.EditTransient
        >>> oModule.EditQuickEyeAnalysis
        >>> oModule.EditVerifEyeAnalysis
        >>> oModule.EditAMIAnalysis
        """
        ...
    
    @pyaedt_function_handler()
    def add_sweep_points(self, sweep_variable=..., sweep_points=..., units=..., override_existing_sweep=...): # -> Literal[True]:
        """Add a linear count sweep to existing Circuit Setup.

        Parameters
        ----------
        sweep_variable : str, optional
            Variable to which the sweep belongs. Default is ``"Freq``.
        sweep_points : float or str or list, optional
            Sweep points to apply linear sweep. It can be a list or single points.
             Points can be float or str. If ``str`` then no units will be applied.
        end_point float or str, optional
            End Point of Linear Count sweep. If ``str`` then no units will be applied.
        units : str, optional
            Sweeps Units. It will be ignored if strings are provided as start_point or end_point
        override_existing_sweep : bool, optional
            Define if existing sweep on the same variable has to be overridden or kept and added to this new sweep.

        Returns
        -------
        bool
            ``True`` is succeeded.

        References
        ----------
        >>> oModule.EditLinearNetworkAnalysis
        >>> oModule.EditDCAnalysis
        >>> oModule.EditTransient
        >>> oModule.EditQuickEyeAnalysis
        >>> oModule.EditVerifEyeAnalysis
        >>> oModule.EditAMIAnalysis
        """
        ...
    
    @pyaedt_function_handler(start_point="start", end_point="stop")
    def add_sweep_count(self, sweep_variable=..., start=..., stop=..., count=..., units=..., count_type=..., override_existing_sweep=...): # -> Literal[True]:
        """Add a step sweep to existing Circuit Setup. It can be ``"Linear"``, ``"Decade"`` or ``"Octave"``.

        Parameters
        ----------
        sweep_variable : str, optional
            Variable that the sweep belongs to. The default is ``"Freq``.
        start : float or str, optional
            Start point of the linear count sweep. The default is ``1``.
            If a string ``str`` is specified, no units are applied.
        stop : float or str, optional
            End point of the linear count sweep. The default is ``100``.
            If a string is specified, no units are applied.
        count :  int, optional
            Number of points. Default is ``100``.
        units : str, optional
            Sweeps Units. It will be ignored if strings are provided as start_point or end_point.
        count_type : str, optional
            Count Type. Default is ``"Linear"``. It can be also ``"Decade"`` or ``"Octave"``.
        override_existing_sweep : bool, optional
            Define if existing sweep on the same variable has to be overridden or kept and added to this new sweep.

        Returns
        -------
        bool
            ``True`` is succeeded.

        References
        ----------
        >>> oModule.EditLinearNetworkAnalysis
        >>> oModule.EditDCAnalysis
        >>> oModule.EditTransient
        >>> oModule.EditQuickEyeAnalysis
        >>> oModule.EditVerifEyeAnalysis
        >>> oModule.EditAMIAnalysis
        """
        ...
    
    @pyaedt_function_handler(start_point="start", end_point="stop")
    def add_sweep_step(self, sweep_variable=..., start=..., stop=..., step_size=..., units=..., override_existing_sweep=...): # -> Literal[True]:
        """Add a linear count sweep to existing Circuit Setup.

        Parameters
        ----------
        sweep_variable : str, optional
            Variable to which the sweep belongs. Default is ``"Freq``.
        start : float or str, optional
            Start point of the linear count sweep. The default is ``1``.
            If a string ``str`` is specified, no units are applied.
        stop : float or str, optional
            End point of the linear count sweep. The default is ``100``.
            If a string is specified, no units are applied.
        step_size :  float or str, optional
            Step size of the sweep. The default is ``1``.
            If a string is specified, no units are applied.
        units : str, optional
            Sweeps Units. It will be ignored if strings are provided as start_point or end_point.
        override_existing_sweep : bool, optional
            Define if existing sweep on the same variable has to be overridden or kept and added to this new sweep.

        Returns
        -------
        bool
            ``True`` is succeeded.

        References
        ----------
        >>> oModule.EditLinearNetworkAnalysis
        >>> oModule.EditDCAnalysis
        >>> oModule.EditTransient
        >>> oModule.EditQuickEyeAnalysis
        >>> oModule.EditVerifEyeAnalysis
        >>> oModule.EditAMIAnalysis
        """
        ...
    
    @pyaedt_function_handler()
    def enable_expression_cache(self, expressions, report_type=..., intrinsics=..., isconvergence=..., isrelativeconvergence=..., conv_criteria=...): # -> Literal[True]:
        """Enable a setup expression cache.

        Parameters
        ----------
        expressions : str or list
            One or more formulas to add to the expression cache.
        report_type : str or list, optional
            Type of the report for the expression. The default is ``"Fields"``. If a list of expressions
            is supplied, a corresponding list of report types must be supplied.
        intrinsics : str or list, optional
            Intrinsic functions for the expressions. The default is ``""``. If a list of expressions
            is supplied, a corresponding list of intrinsic expressesions must be supplied.
        isconvergence : bool, str, or list, optional
            Whether the expression is in the convergence criteria. The  default is ``True``.
            If a list of expressions is supplied, a corresponding list of Boolean values must be
            supplied.
        isrelativeconvergence : bool, optional
            The default is ``True``.
        conv_criteria
            The default is ``1``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler(setup_name="name")
    def enable(self, name=...): # -> Literal[True]:
        """Enable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler(setup_name="name")
    def disable(self, name=...): # -> Literal[True]:
        """Disable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def get_solution_data(self, expressions=..., domain=..., variations=..., primary_sweep_variable=..., report_category=..., context=..., polyline_points=..., math_formula=..., sweep=...):
        """Get a simulation result from a solved setup and cast it in a ``SolutionData`` object.

        Data to be retrieved from Electronics Desktop are any simulation results available in that
        specific simulation context.
        Most of the argument have some defaults which works for most of the ``Standard`` report quantities.

        Parameters
        ----------
        expressions : str or list, optional
            One or more formulas to add to the report. Example is value ``"dB(S(1,1))"`` or a list of values.
            Default is `None` which will return all traces.
        domain : str, optional
            Plot Domain. Options are "Sweep" for frequency domain related results and "Time" for transient related data.
        variations : dict, optional
            Dictionary of all families including the primary sweep.
            The default is ``None`` which will use the nominal variations of the setup.
        primary_sweep_variable : str, optional
            Name of the primary sweep. The default is ``"None"`` which, depending on the context,
            will internally assign the primary sweep to:
            1. ``Freq`` for frequency domain results,
            2. ``Time`` for transient results,
            3. ``Theta`` for radiation patterns,
            4. ``distance`` for field plot over a polyline.
        report_category : str, optional
            Category of the Report to be created. If `None` default data Report will be used.
            The Report Category can be one of the types available for creating a report depend on the simulation setup.
            For example for a Far Field Plot in HFSS the UI shows the report category as "Create Far Fields Report".
            The report category will be in this case "Far Fields".
            Depending on the setup different categories are available.
            If `None` default category will be used (the first item in the Results drop down menu in AEDT).
            To get the list of available categories user can use method ``available_report_types``.
        context : str, dict, optional
            This is the context of the report.
            The default is ``None``. It can be:
            1. `None`
            2. ``"Differential Pairs"``
            3. Reduce Matrix Name for Q2d/Q3d solution
            4. Infinite Sphere name for Far Fields Plot.
            5. Dictionary. If dictionary is passed, key is the report property name and value is property value.
        math_formula : str, optional
            One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.
        polyline_points : int, optional
            Number of points on which to create the report for plots on polylines.
            This parameter is valid for ``Fields`` plot only.
        sweep : str, optional
            One of the available AEDT mathematical formulas to apply. For example, ``abs, dB``.


        Returns
        -------
        :class:`ansys.aedt.core.modules.solutions.SolutionData`
            Solution Data object.

        References
        ----------
        >>> oModule.GetSolutionDataPerVariation
        """
        ...
    
    @pyaedt_function_handler()
    def create_report(self, expressions=..., domain=..., variations=..., primary_sweep_variable=..., secondary_sweep_variable=..., report_category=..., plot_type=..., context=..., subdesign_id=..., polyline_points=..., name=...):
        """Create a report in AEDT. It can be a 2D plot, 3D plot, polar plots or data tables.

        Parameters
        ----------
        expressions : str or list, optional
            One or more formulas to add to the report. Example is value = ``"dB(S(1,1))"``.
        domain : str, optional
            Plot Domain. Options are "Sweep", "Time", "DCIR".
        variations : dict, optional
            Dictionary of all families including the primary sweep. The default is ``{"Freq": ["All"]}``.
        primary_sweep_variable : str, optional
            Name of the primary sweep. The default is ``"Freq"``.
        secondary_sweep_variable : str, optional
            Name of the secondary sweep variable in 3D Plots.
        report_category : str, optional
            Category of the Report to be created. If `None` default data Report will be used.
            The Report Category can be one of the types available for creating a report depend on the simulation setup.
            For example for a Far Field Plot in HFSS the UI shows the report category as "Create Far Fields Report".
            The report category will be in this case "Far Fields".
            Depending on the setup different categories are available.
            If `None` default category will be used (the first item in the Results drop down menu in AEDT).
        plot_type : str, optional
            The format of Data Visualization. Default is ``Rectangular Plot``.
        context : str, optional
            The default is ``None``. It can be `None`, `"Differential Pairs"`,`"RL"`,
            `"Sources"`, `"Vias"`,`"Bondwires"`, `"Probes"` for Hfss3dLayout or
            Reduce Matrix Name for Q2d/Q3d solution or Infinite Sphere name for Far Fields Plot.
        name : str, optional
            Name of the plot. The default is ``None``.
        polyline_points : int, optional,
            Number of points for creating the report for plots on polylines.
        subdesign_id : int, optional
            Specify a subdesign ID to export a Touchstone file of this subdesign. Valid for Circuit Only.
            The default value is ``None``.
        context : str, optional

        Returns
        -------
        :class:`ansys.aedt.core.modules.report_templates.Standard`
            ``True`` when successful, ``False`` when failed.


        References
        ----------
        >>> oModule.CreateReport
        """
        ...
    


class Setup3DLayout(CommonSetup):
    """Initializes, creates, and updates a 3D Layout setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis_3d_layout.FieldAnalysis3DLayout`
        Inherited app object.
    solution_type : int or str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True.``
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @property
    def sweeps(self): # -> list[Any]:
        ...
    
    @property
    def props(self): # -> SetupProps:
        ...
    
    @props.setter
    def props(self, value): # -> None:
        ...
    
    @property
    def is_solved(self): # -> bool:
        """Verify if solutions are available for a given setup.

        Returns
        -------
        bool
            `True` if solutions are available.
        """
        ...
    
    @property
    def solver_type(self): # -> None:
        """Setup type.

        Returns
        -------
        type
            Setup type.
        """
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> bool:
        """Add a new setup based on class settings in AEDT.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.Add
        """
        ...
    
    @pyaedt_function_handler(update_dictionary="properties")
    def update(self, properties=...): # -> Literal[True]:
        """Update the setup based on the class arguments or a dictionary.

        Parameters
        ----------
        properties : dict, optional
            Dictionary of settings to apply.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.Edit
        """
        ...
    
    @pyaedt_function_handler()
    def enable(self): # -> Literal[True]:
        """Enable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.Edit
        """
        ...
    
    @pyaedt_function_handler()
    def disable(self): # -> Literal[True]:
        """Disable a setup.

        Parameters
        ----------
        name : str, optional
            Name of the setup.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.Edit
        """
        ...
    
    @pyaedt_function_handler(file_fullname="output_file")
    def export_to_hfss(self, output_file, keep_net_name=..., unite=...): # -> bool:
        """Export the HFSS 3D Layout design to an HFSS 3D design.

        This method is not supported with IronPython.

        Parameters
        ----------
        output_file : str
            Full path and file name for exporting the project.
        keep_net_name : bool, optional
            Keep net name in 3D export.
            The default is ``False``.
        unite : bool, optional
            Unite bodies which belong to the same net.
            The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ExportToHfss
        """
        ...
    
    @pyaedt_function_handler(file_fullname="output_file")
    def export_to_q3d(self, output_file, keep_net_name=..., unite=...): # -> bool:
        """Export the HFSS 3D Layout design to a Q3D design.

        Parameters
        ----------
        output_file : str
            Full path and file name for exporting the project.
        keep_net_name : bool
            Whether to keep the net name in the 3D export, The default is ``False``.
        unite : bool, optional
            Unite bodies which belong to the same net.
            The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        keep_net_name : bool
            Keep net name in 3D export when ``True`` or by default when ``False``. Default value is ``False``.

        References
        ----------
        >>> oModule.ExportToQ3d
        """
        ...
    
    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
    def add_sweep(self, name=..., sweep_type=...): # -> SweepHFSS3DLayout | Literal[False]:
        """Add a frequency sweep.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``,
            ``"Interpolating"``, and ``"Discrete"``.
            The default is ``"Interpolating"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS3DLayout`
            Sweep object.

        References
        ----------
        >>> oModule.AddSweep
        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def get_sweep(self, name=...): # -> Literal[False]:
        """Return frequency sweep object of a given sweep.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which case
            the first sweep is used.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS3DLayout`

        Examples
        --------
        >>> h3d = Hfss3dLayout()
        >>> setup = h3d.get_setup("Pyaedt_setup")
        >>> sweep = setup.get_sweep("Sweep1")
        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
        >>> sweep.add_subrange("LogScale", 10, 1e8, 100, "Hz")
        """
        ...
    
    @pyaedt_function_handler()
    def import_from_json(self, file_path): # -> Literal[True]:
        """Import setup properties from a json file.

        Parameters
        ----------
        file_path : str
            File path of the json file.
        """
        ...
    
    @pyaedt_function_handler()
    def export_to_json(self, file_path, overwrite=...): # -> bool:
        """Export all setup properties into a json file.

        Parameters
        ----------
        file_path : str
            File path of the json file.
        overwrite : bool, optional
            Whether to overwrite the file if it already exists.
        """
        ...
    
    @pyaedt_function_handler()
    def use_matrix_convergence(self, entry_selection=..., ignore_phase_when_mag_is_less_than=..., all_diagonal_entries=..., max_delta=..., max_delta_phase=..., all_offdiagonal_entries=..., off_diagonal_mag=..., off_diagonal_phase=..., custom_entries=...): # -> Literal[True]:
        """Enable Matrix Convergence criteria.

        Parameters
        ----------
        entry_selection : int
            Entry Selection. ``0`` for All, ``1`` for Diagonal Entries, ``2`` for custom entries.
        ignore_phase_when_mag_is_less_than : float
            Value of magnitude when phase is ignored.
        all_diagonal_entries : bool
            Whether diagonal entries has to be included in convergence or not. Default is ``True``.
        max_delta : float
            Maximum Delta S.
        max_delta_phase : float, str
            Maximum delta phase in degree.
        all_offdiagonal_entries : bool
            Whether off-diagonal entries has to be included in convergence or not. Default is ``True``.
        off_diagonal_mag : float
            Maximum offdiagonal Delta S.
        off_diagonal_phase : float, str
            Maximum off-diagonal delta phase in degree.
        custom_entries : list, optional
            Custom entry mapping list.
            Every item of the listshall be a list with 4 elements:
            ``[port 1 name, port 2 name, max_delta_s, max_delta_angle]``.

        Returns
        -------
        bool
        """
        ...
    


class SetupHFSS(Setup):
    """Initializes, creates, and updates an HFSS setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis.Analysis`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler()
    def get_derivative_variables(self): # -> list[Any]:
        """Return Derivative Enabled variables.

        Returns
        -------
        List
        """
        ...
    
    @pyaedt_function_handler()
    def add_derivatives(self, derivative_list): # -> Literal[True]:
        """Add derivatives to the setup.

        Parameters
        ----------
        derivative_list : str or List
            Derivative variable names.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def set_tuning_offset(self, offsets): # -> bool:
        """Set derivative variable to a specific offset value.

        This method adjusts the tuning ranges for derivative variables in the design, allowing for specific offset
        values to be applied. If a variable is not specified in the ``offsets`` dictionary,
        its offset is set to ``0`` by default. Each value must be within Â±10% of the nominal
        value of the corresponding variable.

        Parameters
        ----------
        offsets : dict
            Dictionary where keys are variable names and values are the corresponding offset values to be applied.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetTuningRanges

        Examples
        --------
        >>> from ansys.aed.core import Hfss
        >>> hfss = Hfss()
        >>> hfss["der_var"] = "1mm"
        >>> setup = hfss.create_setup(setup_type=1)
        >>> setup.add_derivatives("der_var")
        >>> hfss.analyze()
        >>> setup.set_tuning_offset({"der_var": 0.05})
        """
        ...
    
    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_frequency_sweep(self, unit=..., start_frequency=..., stop_frequency=..., num_of_freq_points=..., name=..., save_fields=..., save_rad_fields=..., sweep_type=..., interpolation_tol=..., interpolation_max_solutions=...): # -> SweepHFSS | Literal[False]:
        """Create a sweep with the specified number of points.

        Parameters
        ----------
        unit : str, optional
            Unit of the frequency.. The default is ``None``, in which case the default desktop units are used.
        start_frequency : float, str, optional
            Starting frequency of the sweep. The default is ``1.0``.
            If a unit is passed with number, such as ``"1MHz"``, the unit is ignored.
        stop_frequency : float, str, optional
            Stopping frequency of the sweep. The default is ``10.0``.
            If a unit is passed with number, such as ``"1MHz"`, the unit is ignored.
        num_of_freq_points : int
            Number of frequency points in the range. The default is ``401`` for
            a sweep type of ``"Interpolating"`` or ``"Fast"``. The default is ``5`` for a sweep
            type of ``"Discrete"``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save the fields. The default is ``True``.
        save_rad_fields : bool, optional
            Whether to save the radiating fields. The default is ``False``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
            and ``"Discrete"``. The default is ``"Discrete"``.
        interpolation_tol : float, optional
            Error tolerance threshold for the interpolation
            process. The default is ``0.5``.
        interpolation_max_solutions : int, optional
            Maximum number of solutions evaluated for the interpolation process.
            The default is ``250``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearCountSetup"`` and use it in a linear count sweep
        named ``"LinearCountSweep"``.

        >>> setup = hfss.create_setup("LinearCountSetup")
        >>> linear_count_sweep = setup.create_linear_count_sweep(,,
        >>> type(linear_count_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_linear_step_sweep(self, unit=..., start_frequency=..., stop_frequency=..., step_size=..., name=..., save_fields=..., save_rad_fields=..., sweep_type=...): # -> SweepHFSS | Literal[False]:
        """Create a Sweep with a specified frequency step.

        Parameters
        ----------
        unit : str
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
        start_frequency : float, optional
            Starting frequency of the sweep. The default is ``0.1``.
        stop_frequency : float, optional
            Stopping frequency of the sweep. The default is ``2.0``.
        step_size : float, optional
            Frequency size of the step. The default is ``0.05``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save the fields. The default is ``True``.
        save_rad_fields : bool, optional
            Whether to save the radiating fields. The default is ``False``.
        sweep_type : str, optional
            Whether to create a ``"Discrete"``,``"Interpolating"`` or ``"Fast"`` sweep.
            The default is ``"Discrete"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
        named ``"LinearStepSweep"``.

        >>> setup = hfss.create_setup("LinearStepSetup")
        >>> linear_step_sweep = setup.create_linear_step_sweep(
        ...     name="LinearStepSweep", unit="MHz", start_frequency=1.1e3, stop_frequency=1200.1, step_size=153.8
        ... )
        >>> type(linear_step_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def create_single_point_sweep(self, unit=..., freq=..., name=..., save_single_field=..., save_fields=..., save_rad_fields=...): # -> SweepHFSS:
        """Create a Sweep with a single frequency point.

        Parameters
        ----------
        unit : str
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
        freq : float, list
            Frequency of the single point or list of frequencies to create distinct single points.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_single_field : bool, list, optional
            Whether to save the fields of the single point. The default is ``True``.
            If a list is specified, the length must be the same as the frequency length.
        save_fields : bool, optional
            Whether to save the fields for all points and subranges defined in the sweep. The default is ``False``.
        save_rad_fields : bool, optional
            Whether to save only the radiating fields. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearStepSetup"`` and use it in a single point sweep
        named ``"SinglePointSweep"``.

        >>> setup = hfss.create_setup("LinearStepSetup")
        >>> single_point_sweep = setup.create_single_point_sweep(name="SinglePointSweep", unit="MHz", freq=1.1e3)
        >>> type(single_point_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
    def add_sweep(self, name=..., sweep_type=..., **props): # -> SweepHFSS:
        """Add a sweep to the project.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        sweep_type : str, optional
            Type of the sweep. The default is ``"Interpolating"``.
        **props : Optional context-dependent keyword arguments can be passed
            to the sweep setup

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS`
            Sweep object.

        References
        ----------
        >>> oModule.InsertFrequencySweep
        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def get_sweep(self, name=...): # -> Literal[False]:
        """Return frequency sweep object of a given sweep.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which case the
            first sweep is used.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS`

        Examples
        --------
        >>> hfss = Hfss()
        >>> setup = hfss.get_setup("Pyaedt_setup")
        >>> sweep = setup.get_sweep("Sweep1")
        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
        >>> sweep.add_subrange("LogScale", 10, 1e8, 100, "Hz")
        """
        ...
    
    @pyaedt_function_handler()
    def get_sweep_names(self):
        """Get the names of all sweeps in a given analysis setup.

        Returns
        -------
        list of str
            List of names of all sweeps for the setup.

        References
        ----------
        >>> oModules.GetSweeps

        Examples
        --------
        >>> import ansys.aedt.core
        >>> hfss = ansys.aedt.core.Hfss()
        >>> setup = hfss.get_setup("Pyaedt_setup")
        >>> sweeps = setup.get_sweep_names()
        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def delete_sweep(self, name): # -> bool:
        """Delete a sweep.

        Parameters
        ----------
        name : str
            Name of the sweep.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.DeleteSweep

        Examples
        --------
        Create a frequency sweep and then delete it.

        >>> import ansys.aedt.core
        >>> hfss = ansys.aedt.core.Hfss()
        >>> setup1 = hfss.create_setup(name="Setup1")
        >>> setup1.create_frequency_sweep(
            "GHz", 24, 24.25, 26, "Sweep1", sweep_type="Fast",
        )
        >>> setup1.delete_sweep("Sweep1")
        """
        ...
    
    @pyaedt_function_handler()
    def enable_adaptive_setup_single(self, freq=..., max_passes=..., max_delta_s=...): # -> bool:
        """Enable HFSS single frequency setup.

        Parameters
        ----------
        freq : float, str, optional
            Frequency at which to set the adaptive convergence.
            The default is ``None`` which will not update the value in setup.
            You can enter a float value in (GHz) or a string.
        max_passes : int, optional
            Maximum number of adaptive passes. The default is ``None`` which will not update the value in setup.
        max_delta_s : float, optional
            Delta S convergence criteria. The default is ``None`` which will not update the value in setup.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_adaptive_setup_broadband(self, low_frequency, high_frquency, max_passes=..., max_delta_s=...): # -> bool:
        """Enable HFSS broadband setup.

        Parameters
        ----------
        low_frequency : float, str
            Lower Frequency at which set the adaptive convergence.
            It can be float (GHz) or str.
        high_frquency : float, str
            Lower Frequency at which set the adaptive convergence. It can be float (GHz) or str.
        max_passes : int, optional
            Maximum number of adaptive passes. The default is ``6``.
        max_delta_s : float, optional
            Delta S Convergence criteria. The default is ``0.02``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_adaptive_setup_multifrequency(self, frequencies, max_delta_s=...): # -> bool:
        """Enable HFSS multi-frequency setup.

        Parameters
        ----------
        frequencies : list
            Frequency at which to set the adaptive convergence. You can enter list entries
            as float values in GHz or as strings.
        max_delta_s : list, float
            Delta S convergence criteria. The default is ``0.02``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def use_matrix_convergence(self, entry_selection=..., ignore_phase_when_mag_is_less_than=..., all_diagonal_entries=..., max_delta=..., max_delta_phase=..., all_offdiagonal_entries=..., off_diagonal_mag=..., off_diagonal_phase=..., custom_entries=...): # -> bool:
        """Enable Matrix Convergence criteria.

        Parameters
        ----------
        entry_selection : int
            Entry Selection. ``0`` for All, ``1`` for Diagonal Entries, ``2`` for custom entries.
        ignore_phase_when_mag_is_less_than : float
            Value of magnitude when phase is ignored.
        all_diagonal_entries : bool
            Whether diagonal entries has to be included in convergence or not. Default is ``True``.
        max_delta : float
            Maximum Delta S.
        max_delta_phase : float, str
            Maximum delta phase in degree.
        all_offdiagonal_entries : bool
            Whether off-diagonal entries has to be included in convergence or not. Default is ``True``.
        off_diagonal_mag : float
            Maximum offdiagonal Delta S.
        off_diagonal_phase : float, str
            Maximum off-diagonal delta phase in degree.
        custom_entries : list, optional
            Custom entry mapping list.
            Every item of the lists hall be a list with 4 elements:
            ``[port 1 name, port 2 name, max_delta_s, max_delta_angle]``.

        Returns
        -------
        bool
        """
        ...
    


class SetupHFSSAuto(Setup):
    """Initializes, creates, and updates an HFSS SBR+ or  HFSS Auto setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis.Analysis`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler()
    def get_derivative_variables(self): # -> list[Any]:
        """Return Derivative Enabled variables.

        Returns
        -------
        List
        """
        ...
    
    @pyaedt_function_handler()
    def add_derivatives(self, derivative_list): # -> Literal[True]:
        """Add derivatives to the setup.

        Parameters
        ----------
        derivative_list : str or List
            Derivative variable names.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def set_tuning_offset(self, offsets): # -> bool:
        """Set derivative variable to a specific offset value.

        This method adjusts the tuning ranges for derivative variables in the design, allowing for specific offset
        values to be applied. If a variable is not specified in the ``offsets`` dictionary,
        its offset is set to ``0`` by default. Each value must be within Â±10% of the nominal
        value of the corresponding variable.

        Parameters
        ----------
        offsets : dict
            Dictionary where keys are variable names and values are the corresponding offset values to be applied.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetTuningRanges

        Examples
        --------
        >>> from ansys.aed.core import Hfss
        >>> hfss = Hfss()
        >>> hfss["der_var"] = "1mm"
        >>> setup = hfss.create_setup(setup_type=0)
        >>> setup.add_derivatives("der_var")
        >>> hfss.analyze()
        >>> setup.set_tuning_offset({"der_var": 0.05})
        """
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def add_subrange(self, range_type, start, end=..., count=..., unit=..., clear=...): # -> Literal[True]:
        """Add a subrange to the sweep.

        Parameters
        ----------
        range_type : str
            Type of the subrange. Options are ``"LinearCount"``,
            ``"LinearStep"``, and ``"LogScale"``.
        start : float
            Starting frequency.
        end : float
            Stopping frequency.
        count : int or float
            Frequency count or frequency step.
        unit : str, optional
            Frequency Units.
        clear : bool, optional
            Either if the subrange has to be appended to existing ones or replace them.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler(freq="frequency")
    def enable_adaptive_setup_single(self, frequency=..., max_passes=..., max_delta_s=...): # -> bool:
        """Enable HFSS single frequency setup.

        Parameters
        ----------
        frequency : float, str, optional
            Frequency to set the adaptive convergence at.
            The default is ``None``, in which case the value in the setup is
            not updated. You can specify a float value (GHz) or a string.
        max_passes : int, optional
            Maximum number of adaptive passes. The default is ``None`` which will not update the value in setup.
        max_delta_s : float, optional
            Delta S convergence criteria. The default is ``None`` which will not update the value in setup.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(high_frquency="high_frequency")
    def enable_adaptive_setup_broadband(self, low_frequency, high_frequency, max_passes=..., max_delta_s=...): # -> bool:
        """Enable HFSS broadband setup.

        Parameters
        ----------
        low_frequency : float, str
            Lower frequency to set the adaptive convergence at.
            You can specify a float value (GHz) or a string.
        high_frequency : float, str
            Lower frequency to set the adaptive convergence at. You can
            specify a float value (GHz) or a string.
        max_passes : int, optional
            Maximum number of adaptive passes. The default is ``6``.
        max_delta_s : float, optional
            Delta S Convergence criteria. The default is ``0.02``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_adaptive_setup_multifrequency(self, frequencies, max_delta_s=...): # -> bool:
        """Enable HFSS multi-frequency setup.

        Parameters
        ----------
        frequencies : list
            Frequency at which to set the adaptive convergence. You can enter list entries
            as float values in GHz or as strings.
        max_delta_s : list, float
            Delta S convergence criteria. The default is ``0.02``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    


class SetupSBR(Setup):
    """Initializes, creates, and updates an HFSS SBR+ or HFSS Auto setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis.Analysis`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler(rangetype="range_type")
    def add_subrange(self, range_type, start, end=..., count=..., unit=..., clear=...): # -> Literal[True]:
        """Add a subrange to the sweep.

        Parameters
        ----------
        range_type : str
            Type of the subrange. Options are ``"LinearCount"``,
            ``"LinearStep"``, and ``"LogScale"``.
        start : float
            Starting frequency.
        end : float
            Stopping frequency.
        count : int or float
            Frequency count or frequency step.
        unit : str, optional
            Frequency Units.
        clear : bool, optional
            Either if the subrange has to be appended to existing ones or replace them.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    


class SetupMaxwell(Setup):
    """Initializes, creates, and updates a Maxwell setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis.Analysis`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler(range_type="sweep_type", start="start_frequency", end="stop_frequency", count="step_size")
    def add_eddy_current_sweep(self, sweep_type=..., start_frequency=..., stop_frequency=..., step_size=..., units=..., clear=..., save_all_fields=...): # -> SweepMaxwellEC | Literal[False]:
        """Create a Maxwell Eddy Current Sweep.

        Parameters
        ----------
        sweep_type : str
            Type of the subrange. Options are ``"LinearCount"``,
            ``"LinearStep"``, ``"LogScale"`` and ``"SinglePoints"``.
        start_frequency : float
            Starting frequency.
        stop_frequency : float, optional
            Stopping frequency. Required for ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
        step_size : int or float, optional
            Frequency count or frequency step. Required for ``range_type="LinearCount"|"LinearStep"|"LogScale"``.
        units : str, optional
            Unit of the frequency. For example, ``"Hz`` or ``"MHz"``. The default is ``"Hz"``.
        clear : bool, optional
            If set to ``True``, all other subranges will be suppressed except the current one under creation.
            Default value is ``False``.
        save_all_fields : bool, optional
            Save fields at all frequency points to save fields for the entire set of sweep ranges.
            Default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepMaxwellEC`
            Sweep object.

        Example
        -------
        >>> import ansys.aedt.core
        >>> m2d = ansys.aedt.core.Maxwell2d(version="2025.1")
        >>> m2d.solution_type = SOLUTIONS.Maxwell2d.EddyCurrentXY
        >>> setup = m2d.create_setup()
        >>> sweep = setup.add_eddy_current_sweep(
        ...     sweep_type="LinearStep", start_frequency=1, stop_frequency=20, step_size=2, units="Hz", clear=False
        ... )
        >>> sweep.props["RangeStart"] = "0.1Hz"
        >>> sweep.update()
        >>> m2d.release_desktop()
        """
        ...
    
    @pyaedt_function_handler()
    def delete_all_eddy_current_sweeps(self): # -> bool:
        """Delete all Maxwell Eddy Current sweeps.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_control_program(self, control_program_path, control_program_args=..., call_after_last_step=...): # -> bool:
        """Enable control program option is solution setup.

        Provide externally created executable files, or Python (*.py) scripts that are called after each time step,
        and allow you to control the source input, circuit elements, mechanical quantities, time step,
        and stopping criteria, based on the updated solutions.

        Parameters
        ----------
        control_program_path : str
            File path of control program.
        control_program_args : str, optional
            Arguments to pass to control program.
            Default value is ``" "``.
        call_after_last_step : bool, optional
            If ``True`` the control program is called after the simulation is completed.
            Default value is ``False``.

        Returns
        -------
        bool
            ``True`` if successful, ``False`` if it fails.

        Notes
        -----
        By default a control program script will be called by the pre-installed Python interpreter:
        ``<install_path>\\Win64\\commonfiles\\CPython\\37\\winx64\\Release\\python\\python.exe``.
        However, the user can specify a custom Python interpreter to be used by setting following environment variable:
        ``EM_CTRL_PROG_PYTHON_PATH=<path_to\\python.exe>``

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    
    @pyaedt_function_handler()
    def set_save_fields(self, enable=..., range_type=..., subrange_type=..., start=..., stop=..., count=..., units=...): # -> bool:
        """Enable the save fields option in the setup.

        Parameters
        ----------
        enable : bool, optional
            Whether to enable the save fields option.
            The default value is ``True``.
        range_type : str, optional
            Range type. The available options are ``"Custom"`` to set a custom range type
            or ``"Every N Steps"`` to set the steps within the range.
            The default value is ``Custom``.
        subrange_type : str, optional
            In case of a custom range type the ``subrange_type`` defines the subrange type.
            The available options are ``"LinearStep"``, ``"LinearCount"`` and ``"SinglePoints"``.
            The default option is ``"LinearStep"``.
        start : float, optional
            Range or steps starting point.
            The default value is 0.
        stop : float, optional
            Range or steps starting point.
            The default value is 100000.
        count : float, optional
            Range count or step.
            The default value is 1.
        units : str, optional
            Time units.
            The default is "ns".

        Returns
        -------
        bool
            ``True`` if successful, ``False`` if it fails.

        Example
        -------
        >>> import ansys.aedt.core
        >>> m2d = ansys.aedt.core.Maxwell2d(version="2025.1")
        >>> m2d.solution_type = SOLUTIONS.Maxwell2d.TransientXY
        >>> setup = m2d.create_setup()
        >>> setup.set_save_fields(
        ...     enable=True, range_type="Custom", subrange_type="LinearStep", start=0, stop=8, count=2, units="ms"
        ... )
        >>> m2d.release_desktop()
        """
        ...
    
    @pyaedt_function_handler()
    def export_matrix(self, matrix_type, matrix_name, output_file, is_format_default=..., width=..., precision=..., is_exponential=..., setup=..., default_adaptive=..., is_post_processed=...): # -> Literal[True] | None:
        """Export R/L or Capacitance matrix after solving.

        Parameters
        ----------
        matrix_type : str
            Matrix type to be exported.
            The options are ``"RL"`` or ``"C"``.
        matrix_name : str
            Matrix name to be exported.
        output_file : str
            Output file path to export R/L matrix file to.
            Extension must be ``.txt``.
        is_format_default : bool, optional
            Whether the exported format is default or not.
            If False the custom format is set (no exponential).
        width : int, optional
            Column width in exported .txt file.
        precision : int, optional
            Decimal precision number in exported \\*.txt file.
        is_exponential : bool, optional
            Whether the format number is exponential or not.
        setup : str, optional
            Name of the setup.
            If not provided, the active setup is used.
        default_adaptive : str, optional
            Adaptive type.
            The default is ``"LastAdaptive"``.
        is_post_processed : bool, optional
            Boolean to check if it is post processed. Default value is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    


class SetupQ3D(Setup):
    """Initializes, creates, and updates an Q3D setup.

    Parameters
    ----------
    app : :class:`ansys.aedt.core.application.analysis_3d.FieldAnalysis3D`
        Inherited app object.
    solution_type : int, str
        Type of the setup.
    name : str, optional
        Name of the setup. The default is ``"MySetupAuto"``.
    is_new_setup : bool, optional
        Whether to create the setup from a template. The default is ``True``.
        If ``False``, access is to the existing setup.

    """
    def __init__(self, app, solution_type, name=..., is_new_setup=...) -> None:
        ...
    
    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_frequency_sweep(self, unit=..., start_frequency=..., stop_frequency=..., num_of_freq_points=..., name=..., save_fields=..., sweep_type=..., interpolation_tol=..., interpolation_max_solutions=...): # -> SweepMatrix | Literal[False]:
        """Create a sweep with the specified number of points.

        Parameters
        ----------
        unit : str, optional
            Frequency units. The default is ``None``, in which case the default desktop units are used.
        start_frequency : float, str, optional
            Starting frequency of the sweep. The default is ``0.0``.
            If a unit is passed with the number, such as``"1MHz"``, the unit is ignored.
        stop_frequency : float, str, optional
            Stopping frequency of the sweep. The default is ``20.0``.
            If a unit is passed with the number, such as ``"1MHz"``, the unit is ignored.
        num_of_freq_points : int
            Number of frequency points in the range. The default is ``401`` for
            a sweep type of ``"Interpolating"`` or ``"Fast"``. The default is ``5`` for a sweep
            type of ``"Discrete"``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save the fields. The default is ``True``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
            and ``"Discrete"``. The default is ``"Discrete"``.
        interpolation_tol : float, optional
            Error tolerance threshold for the interpolation
            process. The default is ``0.5``.
        interpolation_max_solutions : int, optional
            Maximum number of solutions evaluated for the interpolation process.
            The default is ``250``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepQ3D` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------
        >>> from ansys.aedt.core import Q3d
        >>> q3d = Q3d()
        >>> setup = q3d.create_setup("LinearCountSetup")
        >>> sweep = setup.create_frequency_sweep(unit="GHz", start_frequency=0.5, stop_frequency=1.5, name="Sweep1")
        >>> q3d.release_desktop(True, True)
        """
        ...
    
    @pyaedt_function_handler(freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_linear_step_sweep(self, unit=..., start_frequency=..., stop_frequency=..., step_size=..., name=..., save_fields=..., sweep_type=...): # -> SweepMatrix | Literal[False]:
        """Create a sweep with a specified frequency step.

        Parameters
        ----------
        unit : str, optional
            Unit of the frequency. The default is ``"GHz"``.
        start_frequency : float, optional
            Starting frequency of the sweep. The default is ``0.0``.
        stop_frequency : float, optional
            Stopping frequency of the sweep. The default is ``2.0``.
        step_size : float, optional
            Frequency size of the step. The default is ``0.05``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save the fields. The default is ``True``.
        sweep_type : str, optional
            Whether to create a ``"Discrete"`` or``"Interpolating"``  sweep.
            The default is ``"Discrete"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepQ3D` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------
        Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
        named ``"LinearStepSweep"``.
        >>> from ansys.aedt.core import Q3d
        >>> q3d = Q3d()
        >>> setup = q3d.create_setup("LinearStepSetup")
        >>> linear_step_sweep = setup.create_linear_step_sweep(
        ...     name="LinearStepSweep", unit="MHz", start_frequency=1.1e3, stop_frequency=1200.1, step_size=153.8
        ... )
        >>> type(linear_step_sweep)
        >>> q3d.release_desktop(True, True)
        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def create_single_point_sweep(self, unit=..., freq=..., name=..., save_single_field=..., save_fields=...): # -> SweepMatrix:
        """Create a sweep with a single frequency point.

        Parameters
        ----------
        unit : str, optional
            Unit of the frequency. The default is ``"GHz"``.
        freq : float, list, optional
            One or more frequencies for creating distinct single points.
            The default is ``1.0``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_single_field : bool, list, optional
            Whether to save the fields of the single point. The default is ``True``.
            If a list is specified, the length must be the same as the
            frequency length.
        save_fields : bool, optional
            Whether to save the fields for all points and subranges defined in the sweep. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepQ3D` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------
        Create a setup named ``"SinglePointSetup"`` and use it in a single point sweep
        named ``"SinglePointSweep"``.
        >>> from ansys.aedt.core import Q3d
        >>> q3d = Q3d()
        >>> setup = q3d.create_setup("SinglePointSetup")
        >>> single_point_sweep = setup.create_single_point_sweep(name="SinglePointSweep", unit="MHz", freq=1.1e3)
        >>> type(single_point_sweep)
        >>> q3d.release_desktop(True, True)
        """
        ...
    
    @pyaedt_function_handler(sweepname="name", sweeptype="sweep_type")
    def add_sweep(self, name=..., sweep_type=..., **props): # -> SweepMatrix:
        """Add a sweep to the project.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        sweep_type : str, optional
            Type of the sweep. The default is ``"Interpolating"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepMatrix`
            Sweep object.

        References
        ----------
        >>> oModule.InsertFrequencySweep
        """
        ...
    
    @pyaedt_function_handler(sweepname="name")
    def get_sweep(self, name=...): # -> Literal[False]:
        """Get the frequency sweep object of a given sweep.

        Parameters
        ----------
        name : str, optional
            Name of the sweep. The default is ``None``, in which case the
            first sweep is used.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepQ3D`

        Examples
        --------
        >>> from ansys.aedt.core import Q3d
        >>> q3d = Q3d()
        >>> setup = q3d.create_setup()
        >>> sweep = setup.create_frequency_sweep(name="Sweep1")
        >>> sweep.add_subrange("LinearCount", 0, 10, 1, "Hz")
        >>> sweep.add_subrange("LogScale", 10, 1e8, 100, "Hz")
        >>> sweep = setup.get_sweep("Sweep1")
        >>> q3d.release_desktop(True, True)
        """
        ...
    
    @property
    def ac_rl_enabled(self): # -> bool:
        """Get/Set the AC RL solution in active Q3D setup.

        Returns
        -------
        bool
        """
        ...
    
    @ac_rl_enabled.setter
    def ac_rl_enabled(self, value): # -> None:
        ...
    
    @property
    def capacitance_enabled(self): # -> bool:
        """Get/Set the Capacitance solution in active Q3D setup.

        Returns
        -------
        bool
        """
        ...
    
    @capacitance_enabled.setter
    def capacitance_enabled(self, value): # -> None:
        ...
    
    @property
    def dc_enabled(self): # -> bool:
        """Get/Set the DC solution in active Q3D setup.

        Returns
        -------
        bool
        """
        ...
    
    @dc_enabled.setter
    def dc_enabled(self, value): # -> None:
        ...
    
    @property
    def dc_resistance_only(self): # -> Literal[False]:
        """Get/Set the DC Resistance Only or Resistance/Inductance calculatio in active Q3D setup.

        Returns
        -------
        bool
        """
        ...
    
    @dc_resistance_only.setter
    def dc_resistance_only(self, value): # -> None:
        ...
    
    @pyaedt_function_handler()
    def update(self, properties=...): # -> Literal[True]:
        """Update the setup based on either the class argument or a dictionary.

        Parameters
        ----------
        properties : optional
            Dictionary to use to update the setup. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup
        """
        ...
    


class SetupIcepak(Setup):
    def __init__(self, app, solution_type, setup_name, is_new_setup=...) -> None:
        ...
    
    def start_continue_from_previous_setup(self, design, solution, map_variables_by_name=..., parameters=..., project=..., force_source_to_solve=..., preserve_partner_solution=..., frozen_flow=...): # -> bool:
        """Start or continue from a previously solved setup.

        Parameters
        ----------
        design : str
            Name of the design.
        solution : str
            Name of the solution in the format ``"name : solution_name"``.
            For example, ``"Setup1 : Transient"``, ``"Setup1 : SteadyState"``.
        map_variables_by_name : bool, optional
            Whether variables are mapped by name from the source design. The default is
            ``True``.
        parameters : dict, optional
            Dictionary of the parameters. This argument is not considered if
            ``map_variables_by_name=True``. If ``None``, the default is
            ``appname.available_variations.nominal_values``.
        project : str, optional
            Name of the project with the design. The default is ``"This Project*"``.
            However, you can supply the full path and name to another project.
        force_source_to_solve : bool, optional
            The default is ``True``.
        preserve_partner_solution : bool, optional
            The default is ``True``.
        frozen_flow : bool, optional
            Whether to freeze the flow to the previous solution. The default is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSetup

        Examples
        --------
        >>> ipk = ansys.aedt.core.Icepak()
        >>> setup = ipk.get_setup("Setup1")
        >>> setup.start_continue_from_previous_setup(design="IcepakDesign1", solution="Setup1 : SteadyState")
        """
        ...
    


