"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.generic.general_methods import pyaedt_function_handler
from ansys.aedt.core.modules.boundary.common import BoundaryObject

class BoundaryDictionary:
    """Handles Icepak transient and temperature-dependent boundary condition assignments.

    Parameters
    ----------
    assignment_type : str
        Type of assignment represented by the class. Options are `"Temp Dep"``
        and ``"Transient"``.
    function_type : str
        Variation function to assign. If ``assignment_type=="Temp Dep"``,
        the function can only be ``"Piecewise Linear"``. Otherwise, the function can be
        ``"Exponential"``, ``"Linear"``, ``"Piecewise Linear"``, ``"Power Law"``,
        ``"Sinusoidal"``, and ``"Square Wave"``.
    """
    def __init__(self, assignment_type, function_type) -> None:
        ...
    
    @property
    def props(self): # -> dict[str, Any]:
        """Dictionary that defines all the boundary condition properties."""
        ...
    
    @pyaedt_function_handler()
    def __getitem__(self, k): # -> None:
        ...
    


class LinearDictionary(BoundaryDictionary):
    """Manages linear conditions assignments, which are children of the ``BoundaryDictionary`` class.

    This class applies a condition ``y`` dependent on the time ``t``:
        ``y=a+b*t``

    Parameters
    ----------
    intercept : str
        Value of the assignment condition at the initial time, which
        corresponds to the coefficient ``a`` in the formula.
    slope : str
        Slope of the assignment condition, which
        corresponds to the coefficient ``b`` in the formula.
    """
    def __init__(self, intercept, slope) -> None:
        ...
    


class PowerLawDictionary(BoundaryDictionary):
    """Manages power law condition assignments, which are children of the ``BoundaryDictionary`` class.

    This class applies a condition ``y`` dependent on the time ``t``:
         ``y=a+b*t^c``

     Parameters
     ----------
     intercept : str
         Value of the assignment condition at the initial time, which
         corresponds to the coefficient ``a`` in the formula.
     coefficient : str
         Coefficient that multiplies the power term, which
         corresponds to the coefficient ``b`` in the formula.
     scaling_exponent : str
         Exponent of the power term, which
         corresponds to the coefficient ``c`` in the formula.
    """
    def __init__(self, intercept, coefficient, scaling_exponent) -> None:
        ...
    


class ExponentialDictionary(BoundaryDictionary):
    """Manages exponential condition assignments, which are children of the ``BoundaryDictionary`` class.

    This class applies a condition ``y`` dependent on the time ``t``:
        ``y=a+b*exp(c*t)``

    Parameters
    ----------
    vertical_offset : str
        Vertical offset summed to the exponential law, which
        corresponds to the coefficient ``a`` in the formula.
    coefficient : str
        Coefficient that multiplies the exponential term, which
        corresponds to the coefficient ``b`` in the formula.
    exponent_coefficient : str
        Coefficient in the exponential term, which
        corresponds to the coefficient ``c`` in the formula.
    """
    def __init__(self, vertical_offset, coefficient, exponent_coefficient) -> None:
        ...
    


class SinusoidalDictionary(BoundaryDictionary):
    """Manages sinusoidal condition assignments, which are children of the ``BoundaryDictionary`` class.

    This class applies a condition ``y`` dependent on the time ``t``:
        ``y=a+b*sin(2*pi(t-t0)/T)``

    Parameters
    ----------
    vertical_offset : str
        Vertical offset summed to the sinusoidal law, which
        corresponds to the coefficient ``a`` in the formula.
    vertical_scaling : str
        Coefficient that multiplies the sinusoidal term, which
        corresponds to the coefficient ``b`` in the formula.
    period : str
        Period of the sinusoid, which
        corresponds to the coefficient ``T`` in the formula.
    period_offset : str
        Offset of the sinusoid, which
        corresponds to the coefficient ``t0`` in the formula.
    """
    def __init__(self, vertical_offset, vertical_scaling, period, period_offset) -> None:
        ...
    


class SquareWaveDictionary(BoundaryDictionary):
    """Manages square wave condition assignments, which are children of the ``BoundaryDictionary`` class.

    Parameters
    ----------
    on_value : str
        Maximum value of the square wave.
    initial_time_off : str
        Time after which the square wave assignment starts.
    on_time : str
        Time for which the square wave keeps the maximum value during one period.
    off_time : str
        Time for which the square wave keeps the minimum value during one period.
    off_value : str
        Minimum value of the square wave.
    """
    def __init__(self, on_value, initial_time_off, on_time, off_time, off_value) -> None:
        ...
    


class PieceWiseLinearDictionary(BoundaryDictionary):
    """
    Manages dataset condition assignments, which are children of the ``BoundaryDictionary`` class.

    Parameters
    ----------
    assignment_type : str
        Type of assignment represented by the class.
        Options are ``"Temp Dep"`` and ``"Transient"``.
    ds : str
        Dataset name to assign.
    scale : str
        Scaling factor for the y values of the dataset.
    """
    def __init__(self, assignment_type, ds, scale) -> None:
        ...
    
    @property
    def dataset_name(self):
        """Dataset name that defines the piecewise assignment."""
        ...
    


class NetworkObject(BoundaryObject):
    """Manages networks in Icepak projects."""
    def __init__(self, app, name=..., props=..., create=...) -> None:
        ...
    
    @pyaedt_function_handler()
    def create(self): # -> Literal[True]:
        """
        Create network in AEDT.

        Returns
        -------
        bool:
            True if successful.
        """
        ...
    
    @property
    def auto_update(self): # -> Literal[False]:
        """
        Get if auto-update is enabled.

        Returns
        -------
        bool:
            Whether auto-update is enabled.
        """
        ...
    
    @auto_update.setter
    def auto_update(self, b): # -> None:
        """
        Set auto-update on or off.

        Parameters
        ----------
        b : bool
            Whether to enable auto-update.

        """
        ...
    
    @property
    def links(self): # -> dict[Any, Any]:
        """
        Get links of the network.

        Returns
        -------
        dict:
            Links dictionary.

        """
        ...
    
    @property
    def r_links(self): # -> dict[Any, Any]:
        """
        Get r-links of the network.

        Returns
        -------
        dict:
            R-links dictionary.

        """
        ...
    
    @property
    def c_links(self): # -> dict[Any, Any]:
        """
        Get c-links of the network.

        Returns
        -------
        dict:
            C-links dictionary.

        """
        ...
    
    @property
    def nodes(self): # -> dict[Any, Any]:
        """
        Get nodes of the network.

        Returns
        -------
        dict:
            Nodes dictionary.

        """
        ...
    
    @property
    def face_nodes(self): # -> dict[Any, Any]:
        """
        Get face nodes of the network.

        Returns
        -------
        dict:
            Face nodes dictionary.

        """
        ...
    
    @property
    def faces_ids_in_network(self): # -> list[Any]:
        """
        Get ID of faces included in the network.

        Returns
        -------
        list:
            Face IDs.

        """
        ...
    
    @property
    def objects_in_network(self): # -> list[Any]:
        """
        Get objects included in the network.

        Returns
        -------
        list:
            Objects names.

        """
        ...
    
    @property
    def internal_nodes(self): # -> dict[Any, Any]:
        """
        Get internal nodes.

        Returns
        -------
        dict:
            Internal nodes.

        """
        ...
    
    @property
    def boundary_nodes(self): # -> dict[Any, Any]:
        """
        Get boundary nodes.

        Returns
        -------
        dict:
            Boundary nodes.

        """
        ...
    
    @property
    def name(self): # -> str:
        """
        Get network name.

        Returns
        -------
        str
            Network name.
        """
        ...
    
    @name.setter
    def name(self, new_network_name): # -> None:
        """
        Set new name of the network.

        Parameters
        ----------
        new_network_name : str
            New name of the network.
        """
        ...
    
    @pyaedt_function_handler()
    def add_internal_node(self, name, power, mass=..., specific_heat=...): # -> _Node:
        """Add an internal node to the network.

        Parameters
        ----------
        name : str
            Name of the node.
        power : str or float or dict
            String, float, or dictionary containing the value of the assignment.
            If a float is passed, the ``"W"`` unit is used. A dictionary can be
            passed to use temperature-dependent or transient
            assignments.
        mass : str or float, optional
            Value of the mass assignment. This parameter is relevant only
            if the solution is transient. If a float is passed, the ``"Kg"`` unit
            is used. The default is ``None``, in which case ``"0.001kg"`` is used.
        specific_heat : str or float, optional
            Value of the specific heat assignment. This parameter is
            relevant only if the solution is transient. If a float is passed,
            the ``"J_per_Kelkg"`` unit is used. The default is ``None`, in
            which case ``"1000J_per_Kelkg"`` is used.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> network.add_internal_node("TestNode", {"Type": "Transient",
        >>>                                        "Function": "Linear", "Values": ["0.01W", "1"]})
        """
        ...
    
    @pyaedt_function_handler()
    def add_boundary_node(self, name, assignment_type, value): # -> _Node:
        """
        Add a boundary node to the network.

        Parameters
        ----------
        name : str
            Name of the node.
        assignment_type : str
            Type assignment. Options are ``"Power"`` and ``"Temperature"``.
        value : str or float or dict
            String, float, or dictionary containing the value of the assignment.
            If a float is passed the ``"W"`` or ``"cel"`` unit is used, depending on
            the selection for the ``assignment_type`` parameter. If ``"Power"``
            is selected for the type, a dictionary can be passed to use
            temperature-dependent or transient assignment.

        Returns
        -------
        bool
            ``True`` if successful.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> network.add_boundary_node("TestNode", "Temperature", 2)
        >>> ds = app.create_dataset1d_design("Test_DataSet", [1, 2, 3], [3, 4, 5])
        >>> network.add_boundary_node("TestNode", "Power", {"Type": "Temp Dep",
        >>>                                                       "Function": "Piecewise Linear",
        >>>                                                       "Values": "Test_DataSet"})
        """
        ...
    
    @pyaedt_function_handler(face_id="assignment")
    def add_face_node(self, assignment, name=..., thermal_resistance=..., material=..., thickness=..., resistance=...): # -> _Node:
        """
        Create a face node in the network.

        Parameters
        ----------
        assignment : int
            Face ID.
        name : str, optional
            Name of the node. Default is ``None``.
        thermal_resistance : str
            Thermal resistance value and unit. Default is ``"NoResistance"``.
        material : str, optional
            Material specification (required if ``thermal_resistance="Compute"``).
            Default is ``None``.
        thickness : str or float, optional
            Thickness value and unit (required if ``thermal_resistance="Compute"``).
            If a float is passed, ``"mm"`` unit is automatically used. Default is ``None``.
        resistance : str or float, optional
            Resistance value and unit (required if ``thermal_resistance="Specified"``).
            If a float is passed, ``"cel_per_w"`` unit is automatically used. Default is ``None``.

        Returns
        -------
        bool
            True if successful.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> box = app.modeler.create_box([5, 5, 5], [20, 50, 80])
        >>> faces_ids = [face.id for face in box.faces]
        >>> network.add_face_node(faces_ids[0])
        >>> network.add_face_node(
        ...     faces_ids[1], name="TestNode", thermal_resistance="Compute", material="Al-Extruded", thickness="2mm"
        ... )
        >>> network.add_face_node(faces_ids[2], name="TestNode", thermal_resistance="Specified", resistance=2)
        """
        ...
    
    @pyaedt_function_handler(nodes_dict="nodes")
    def add_nodes_from_dictionaries(self, nodes): # -> Literal[True]:
        """
        Add nodes to the network from dictionary.

        Parameters
        ----------
        nodes : list or dict
            A dictionary or list of dictionaries containing nodes to add to the network. Different
            node types require different key and value pairs:

            - Face nodes must contain the ``"ID"`` key associated with an integer containing the face ID.
              Optional keys and values pairs are:

              - ``"ThermalResistance"``: a string specifying the type of thermal resistance.
                 Options are ``"NoResistance"`` (default), ``"Compute"``, and ``"Specified"``.
              - ``"Thickness"``: a string with the thickness value and unit (required if ``"Compute"``
              is selected for ``"ThermalResistance"``).
              - ``"Material"``: a string with the name of the material (required if ``"Compute"`` is
              selected for ``"ThermalResistance"``).
              - ``"Resistance"``: a string with the resistance value and unit (required if
                 ``"Specified"`` is selected for ``"ThermalResistance"``).
              - ``"Name"``: a string with the name of the node. If not
                 specified, a name is generated automatically.


            - Internal nodes must contain the following keys and values pairs:

              - ``"Name"``: a string with the node name
              - ``"Power"``: a string with the assigned power or a dictionary for transient or
              temperature-dependent assignment
              Optional keys and values pairs:
              - ``"Mass"``: a string with the mass value and unit
              - ``"SpecificHeat"``: a string with the specific heat value and unit

            - Boundary nodes must contain the following keys and values pairs:

              - ``"Name"``: a string with the node name
              - ``"ValueType"``: a string specifying the type of value (``"Power"`` or
              ``"Temperature"``)
              Depending on the ``"ValueType"`` choice, one of the following keys and values pairs must
              be used:
              - ``"Power"``: a string with the power value and unit or a dictionary for transient or
              temperature-dependent assignment
              - ``"Temperature"``: a string with the temperature value and unit or a dictionary for
              transient or temperature-dependent assignment
              According to the ``"ValueType"`` choice, ``"Power"`` or ``"Temperature"`` key must be
              used. Their associated value a string with the value and unit of the quantity prescribed or
              a dictionary for transient or temperature dependent assignment.


            All the temperature dependent or thermal dictionaries should contain three keys:
            ``"Type"``, ``"Function"``, and ``"Values"``. Accepted ``"Type"`` values are:
            ``"Temp Dep"`` and ``"Transient"``. Accepted ``"Function"`` are: ``"Linear"``,
            ``"Power Law"``, ``"Exponential"``, ``"Sinusoidal"``, ``"Square Wave"``, and
            ``"Piecewise Linear"``. ``"Temp Dep"`` only support the latter. ``"Values"``
            contains a list of strings containing the parameters required by the ``"Function"``
            selection (e.g. ``"Linear"`` requires two parameters: the value of the variable at t=0
            and the slope of the line). The parameters required by each ``Function`` option is in
            Icepak documentation. The parameters must contain the units where needed.

        Returns
        -------
        bool
            ``True`` if successful. ``False`` otherwise.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> box = app.modeler.create_box([5, 5, 5], [20, 50, 80])
        >>> faces_ids = [face.id for face in box.faces]
        >>> nodes_dict = [
        >>>         {"FaceID": faces_ids[0]},
        >>>         {"Name": "TestNode", "FaceID": faces_ids[1],
        >>>          "ThermalResistance": "Compute", "Thickness": "2mm"},
        >>>         {"FaceID": faces_ids[2], "ThermalResistance": "Specified", "Resistance": "2cel_per_w"},
        >>>         {"Name": "Junction", "Power": "1W"}]
        >>> network.add_nodes_from_dictionaries(nodes_dict)
        """
        ...
    
    @pyaedt_function_handler()
    def add_link(self, node1, node2, value, name=...): # -> Literal[True]:
        """Create links in the network object.

        Parameters
        ----------
        node1 : str or int
            String containing one of the node names that the link is connecting or an integer
            containing the ID of the face. If an ID is used and the node associated with the
            corresponding face is not created yet, it is added automatically.
        node2 : str or int
            String containing one of the node names that the link is connecting or an integer
            containing the ID of the face. If an ID is used and the node associated with the
            corresponding face is not created yet, it is added atuomatically.
        value : str or float
            String containing the value and unit of the connection. If a float is passed, an
            R-Link is added to the network and the ``"cel_per_w"`` unit is used.
        name : str, optional
            Name of the link. The default is ``None``, in which case a name is
            automatically generated.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> box = app.modeler.create_box([5, 5, 5], [20, 50, 80])
        >>> faces_ids = [face.id for face in box.faces]
        >>> connection = {"Name": "LinkTest", "Connection": [faces_ids[1], faces_ids[0]], "Value": "1cel_per_w"}
        >>> network.add_links_from_dictionaries(connection)
        """
        ...
    
    @pyaedt_function_handler()
    def add_links_from_dictionaries(self, connections): # -> Literal[True]:
        """Create links in the network object.

        Parameters
        ----------
        connections : dict or list of dict
            Dictionary or list of dictionaries containing the links between nodes. Each dictionary
            consists of these elements:

            - ``"Link"``: a three-item list consisting of the two nodes that the link is connecting and
               the value with unit of the link. The node of the connection can be referred to with the
               name (str) or face ID (int). The link type (resistance, heat transfer coefficient, or
               mass flow) is determined automatically from the unit.
            - ``"Name"`` (optional): a string specifying the name of the link.


        Returns
        -------
        bool
            ``True`` if successful.

        Examples
        --------
        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Icepak()
        >>> network = ansys.aedt.core.modules.boundary.Network(app)
        >>> box = app.modeler.create_box([5, 5, 5], [20, 50, 80])
        >>> faces_ids = [face.id for face in box.faces]
        >>> [network.add_face_node(faces_ids[i]) for i in range(2)]
        >>> connection = {"Name": "LinkTest", "Link": [faces_ids[1], faces_ids[0], "1cel_per_w"]}
        >>> network.add_links_from_dictionaries(connection)
        """
        ...
    
    @pyaedt_function_handler()
    def update(self): # -> bool:
        """Update the network in AEDT.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler()
    def update_assignment(self): # -> bool:
        """Update assignments of the network."""
        ...
    
    class _Link:
        def __init__(self, node_1, node_2, value, name, network) -> None:
            ...
        
        @property
        def props(self): # -> list[str]:
            """
            Get link properties.

            Returns
            -------
            list
                First two elements of the list are the node names that the link connects,
                the third element is the link type while the fourth contains the value
                associated with the link.
            """
            ...
        
        @pyaedt_function_handler()
        def delete_link(self): # -> None:
            """Delete link from network."""
            ...
        
    
    
    class _Node:
        def __init__(self, name, app, network, node_type=..., props=...) -> None:
            ...
        
        @pyaedt_function_handler()
        def delete_node(self): # -> None:
            """Delete node from network."""
            ...
        
        @property
        def node_type(self): # -> str | None:
            """Get node type.

            Returns
            -------
            str
                Node type.
            """
            ...
        
        @property
        def props(self): # -> dict[str, str] | dict[str, Any] | None:
            """Get properties of the node.

            Returns
            -------
            dict
                Node properties.
            """
            ...
        
        @props.setter
        def props(self, props): # -> None:
            """Set properties of the node.

            Parameters
            ----------
            props : dict
                Node properties.
            """
            ...
        
    
    


