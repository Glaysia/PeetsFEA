"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.application.analysis_hf import ScatteringMethods
from ansys.aedt.core.application.analysis_nexxim import FieldAnalysisCircuit
from ansys.aedt.core.generic.general_methods import deprecate_argument, pyaedt_function_handler

"""This module contains the ``Circuit`` class."""
class Circuit(FieldAnalysisCircuit, ScatteringMethods):
    """Provides the Circuit application interface.

    Parameters
    ----------
    project : str, optional
        Name of the project to select or the full path to the project
        or AEDTZ archive to open.  The default is ``None``, in which
        case an attempt is made to get an active project. If no
        projects are present, an empty project is created.
    design : str, optional
        Name of the design to select. The default is ``None``, in
        which case an attempt is made to get an active design. If no
        designs are present, an empty design is created.
    solution_type : str, optional
        Solution type to apply to the design. The default is
        ``None``, in which case the default type is applied.
    setup : str, optional
        Name of the setup to use as the nominal. The default is
        ``None``, in which case the active setup is used or
        nothing is used.
    version : str, int, float, optional
        Version of AEDT to use. The default is ``None``, in which case
        the active version or latest installed version is  used.
        This parameter is ignored when Script is launched within AEDT.
        Examples of input values are ``251``, ``25.1``,``2025.1``,``"2025.1"``.
    non_graphical : bool, optional
        Whether to run AEDT in non-graphical mode. The default
        is ``False``, in which case AEDT is launched in graphical mode.
        This parameter is ignored when a script is launched within AEDT.
    new_desktop : bool, optional
        Whether to launch an instance of AEDT in a new thread, even if
        another instance of the ``specified_version`` is active on the
        machine.  The default is ``False``. This parameter is ignored when
        a script is launched within AEDT.
    close_on_exit : bool, optional
        Whether to release AEDT on exit. The default is ``False``.
    student_version : bool, optional
        Whether to open the AEDT student version. The default is ``False``.
        This parameter is ignored when Script is launched within AEDT.
    machine : str, optional
        Machine name to which connect the oDesktop Session. Works only in 2022 R2
        or later. The remote server must be up and running with the command
        `"ansysedt.exe -grpcsrv portnum"`. If a machine is `"localhost"`, the
        server also starts if not present.
    port : int, optional
        Port number on which to start the oDesktop communication on an already existing server.
        This parameter is ignored when creating a new server. It works only in 2022 R2 or
        later. The remote server must be up and running with the command
        `"ansysedt.exe -grpcsrv portnum"`.
    aedt_process_id : int, optional
        Process ID for the instance of AEDT to point PyAEDT at. The default is
        ``None``. This parameter is only used when ``new_desktop = False``.
    remove_lock : bool, optional
        Whether to remove lock to project before opening it or not.
        The default is ``False``, which means to not unlock
        the existing project if needed and raise an exception.

    Examples
    --------
    Create an instance of Circuit and connect to an existing Circuit
    design or create a new Circuit design if one does not exist.

    >>> from ansys.aedt.core import Circuit
    >>> aedtapp = Circuit()

    Create an instance of Circuit and link to a project named
    ``"projectname"``. If this project does not exist, create one with
    this name.

    >>> aedtapp = Circuit(projectname)

    Create an instance of Circuit and link to a design named
    ``"designname"`` in a project named ``"projectname"``.

    >>> aedtapp = Circuit(projectname, designame)

    Create an instance of Circuit and open the specified project,
    which is ``"myfie.aedt"``.

    >>> aedtapp = Circuit("myfile.aedt")

    Create an instance of Circuit using the 20255.1, project="myfile.aedt")

    Create an instance of Circuit using the 2025 R1 student version and open
    the specified project, which is named ``"myfile.aedt"``.

    >>> aedtapp = Circuit(version="2025.1", project="myfile.aedt", student_version=True)

    """
    @pyaedt_function_handler(designname="design", projectname="project", specified_version="version", setup_name="setup", new_desktop_session="new_desktop")
    def __init__(self, project=..., design=..., solution_type=..., setup=..., version=..., non_graphical=..., new_desktop=..., close_on_exit=..., student_version=..., machine=..., port=..., aedt_process_id=..., remove_lock=...) -> None:
        ...
    
    @pyaedt_function_handler(file_to_import="input_file")
    def create_schematic_from_netlist(self, input_file):
        """Create a circuit schematic from an HSpice netlist.

        Supported currently are:

        * R
        * L
        * C
        * Diodes
        * Bjts
        * Discrete components with syntax ``Uxxx net1 net2 ... netn modname``

        Parameters
        ----------
        input_file : str
            Full path to the HSpice file to import.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler(path="input_file")
    def get_ibis_model_from_file(self, input_file, is_ami=...): # -> Ibis | None:
        """Create an IBIS model based on the data contained in an IBIS file.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Path of the IBIS file.
        is_ami : bool, optional
            Whether the file to import is an IBIS AMI file. The
            default is ``False``, in which case it is an IBIS file.

        Returns
        -------
        :class:`ansys.aedt.core.generic.ibis_reader.Ibis`
            IBIS object exposing all data from the IBIS file.
        """
        ...
    
    @pyaedt_function_handler(file_to_import="input_file")
    def create_schematic_from_mentor_netlist(self, input_file): # -> Literal[True]:
        """Create a circuit schematic from a Mentor netlist.

        Supported currently are:

        * R
        * L
        * C
        * Diodes
        * Bjts
        * Discrete components with syntax ``Uxxx net1 net2get_source_pin_names ... netn modname``

        Parameters
        ----------
        input_file : str
            Full path to the HSpice file to import.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @pyaedt_function_handler(refid="reference_id")
    def retrieve_mentor_comp(self, reference_id): # -> Literal['resistor:RES.', 'capacitor:CAP.', 'inductor:COIL.', 'diode', 'transistor:NPN', '']:
        """Retrieve the type of the Mentor netlist component for a given reference ID.

        Parameters
        ----------
        reference_id : list
            Reference ID.

        Returns
        -------
        str
            Type of the Mentor netlist component.

        """
        ...
    
    @pyaedt_function_handler()
    def get_source_pin_names(self, source_design_name, source_project_name=..., source_project_path=..., port_selector=...): # -> list[Any] | Literal[False]:
        """Retrieve pin names.

        Parameters
        ----------
        source_design_name : str
            Name of the source design.
        source_project_name : str, optional
            Name of the source project. The default is ``None``.
        source_project_path : str, optional
            Path to the source project if different than the existing path. The default is ``None``.
        port_selector : int, optional
            Type of the port. Options are ``1``, ``2``, and ``3``, corresponding respectively to ``"Wave Port"``,
            ``"Terminal"``, or ``"Circuit Port"``. The default is ``3``, which is a circuit port.

        Returns
        -------
        list
            List of pin names.

        References
        ----------
        >>> oModule.GetExcitationsOfType
        """
        ...
    
    @pyaedt_function_handler(filename="input_file", solution_name="solution")
    def import_touchstone_solution(self, input_file, solution=...): # -> list[str]:
        """Import a Touchstone file as the solution.

        Parameters
        ----------
        input_file : str
            Name of the Touchstone file.
        solution : str, optional
            Name of the solution. The default is ``"Imported_Data"``.

        Returns
        -------
        list
            List of ports.

        References
        ----------
        >>> oDesign.ImportData
        """
        ...
    
    @pyaedt_function_handler(designname="design", setupname="setup")
    def export_fullwave_spice(self, design=..., setup=..., is_solution_file=..., filename=..., passivity=..., causality=..., renormalize=..., impedance=..., error=..., poles=...): # -> Path:
        """
        Export a full wave HSpice file using NDE.

        .. warning::
          This method doesn't work.

        Parameters
        ----------
        design : str, optional
            Name of the design or the full path to the solution file if it is an imported file.
            The default is ``None``.
        setup : str, optional
            Name of the setup if it is a design. The default is ``None``.
        is_solution_file : bool, optional
            Whether it is an imported solution file. The default is ``False``.
        filename : str or :class:`pathlib.Path`, optional
            Full path and name for exporting the HSpice file.
            The default is ``None``, in which case the file is exported to the working directory.
        passivity : bool, optional
            Whether to compute the passivity. The default is ``False``.
        causality : bool, optional
            Whether to compute the causality. The default is ``False``.
        renormalize : bool, optional
            Whether to renormalize the S-matrix to a specific port impedance.
            The default is ``False``.
        impedance : float, optional
            Impedance value if ``renormalize=True``. The default is ``50``.
        error : float, optional
            Fitting error. The default is ``0.5``.
        poles : int, optional
            Number of fitting poles. The default is ``10000``.

        Returns
        -------
        str
            Name of the HSpice file if the export is successful.

        References
        ----------
        >>> oDesign.ExportFullWaveSpice
        """
        ...
    
    @pyaedt_function_handler(plot_name="name", curvenames="curves", solution_name="solution", variation_dict="variations")
    def create_touchstone_report(self, name, curves, solution=..., variations=..., differential_pairs=..., subdesign_id=...): # -> Literal[False]:
        """Create a Touchstone plot.

        Parameters
        ----------
        name : str
            Name of the plot.
        curves : list
            List of names for the curves to plot.
        solution : str, optional
            Name of the solution. The default is ``None``.
        variations : dict, optional
            Dictionary of variation names. The default is ``None``.
        differential_pairs : bool, optional
            Whether the plot is on differential pairs traces. The default is ``False``.
        subdesign_id : int, optional
            Specify a subdesign ID to export a Touchstone file of this subdesign. The default value is ``None``.

        Returns
        -------
        bool
           ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.CreateReport
        """
        ...
    
    @pyaedt_function_handler(instance_name="instance", setup_name="setup")
    def push_excitations(self, instance, thevenin_calculation=..., setup=...): # -> Literal[True]:
        """Push excitations for a linear frequency setup.

        Parameters
        ----------
        instance : str
            Name of the instance.
        thevenin_calculation : bool, optional
            Whether to perform the Thevenin equivalent calculation. The default is ``False``.
        setup : str, optional
            Name of the solution setup to push. The default is ``"LinearFrequency"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.PushExcitations
        """
        ...
    
    @pyaedt_function_handler(instance_name="instance", setup_name="setup")
    def push_time_excitations(self, instance, start=..., stop=..., harmonics=..., window_type=..., width_percentage=..., kaiser=..., correct_coherent_gain=..., setup=...): # -> Literal[True]:
        """Push excitations for a transient setup.

        Parameters
        ----------
        instance : str
            Name of the instance.
        start : float, optional
            Start time in ``seconds``. The default is ``0.0``.
        stop : float, optional
            Stop time in ``seconds``. The default is ``0.0``.
        harmonics : int, optional
            Maximum number of harmonics. The default is ``100``.
        window_type : str, optional
            Window type. Available windows are: ``Rectangular``, ``Barlett``, ``Blackman``, ``Hamming``,
            ``Hanning``, ``Kaiser``, ``Welch``, ``Weber``, ``Lanzcos``. The default is ``Rectangular``.
        width_percentage : float, optional
            Width percentage. The default is ``100.0``.
        kaiser : float, optional
            Kaiser value. The default is ``0.0``.
        correct_coherent_gain : bool, optional
            Whether to enable the coherent gain correction. The default is ``True``.
        setup : str, optional
            Name of the solution setup to push. The default is ``"LinearFrequency"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.PushExcitations
        """
        ...
    
    @pyaedt_function_handler()
    def create_source(self, source_type, name=...): # -> PowerSinSource | PowerIQSource | VoltageFrequencyDependentSource | VoltageDCSource | VoltageSinSource | CurrentSinSource | Sources | Literal[False]:
        """Create a source in Circuit.

        Parameters
        ----------
        source_type : str
            Source type to create. Sources available are:

            * PowerSin.
            * PowerIQ.
            * VoltageFrequencyDependent.
            * VoltageDC.
            * VoltageSin.
            * CurrentSin.

        name : str, optional
            Source name.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.Source`
            Circuit Source Object.

        References
        ----------
        >>> oDesign.UpdateSources
        """
        ...
    
    @pyaedt_function_handler()
    def assign_voltage_sinusoidal_excitation_to_ports(self, ports): # -> PowerSinSource | PowerIQSource | VoltageFrequencyDependentSource | VoltageDCSource | VoltageSinSource | CurrentSinSource | Sources | Literal[False]:
        """Assign a voltage sinusoidal excitation to circuit ports.

        Parameters
        ----------
        ports : list
            List of circuit ports to assign to the sinusoidal excitation.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.Source`
            Circuit Source Object.

        References
        ----------
        >>> oDesign.UpdateSources
        """
        ...
    
    @pyaedt_function_handler()
    def assign_current_sinusoidal_excitation_to_ports(self, ports): # -> PowerSinSource | PowerIQSource | VoltageFrequencyDependentSource | VoltageDCSource | VoltageSinSource | CurrentSinSource | Sources | Literal[False]:
        """Assign a current sinusoidal excitation to circuit ports.

        Parameters
        ----------
        ports : list
            List of circuit ports to assign to the sinusoidal excitation.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.Source`
            Circuit Source Object.

        References
        ----------
        >>> oDesign.UpdateSources
        """
        ...
    
    @pyaedt_function_handler()
    def assign_power_sinusoidal_excitation_to_ports(self, ports): # -> PowerSinSource | PowerIQSource | VoltageFrequencyDependentSource | VoltageDCSource | VoltageSinSource | CurrentSinSource | Sources | Literal[False]:
        """Assign a power sinusoidal excitation to circuit ports.

        Parameters
        ----------
        ports : list
            List of circuit ports to assign to the sinusoidal excitation.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.Source`
            Circuit Source Object.

        References
        ----------
        >>> oDesign.UpdateSources
        """
        ...
    
    @pyaedt_function_handler(filepath="input_file")
    def assign_voltage_frequency_dependent_excitation_to_ports(self, ports, input_file): # -> PowerSinSource | PowerIQSource | VoltageFrequencyDependentSource | VoltageDCSource | VoltageSinSource | CurrentSinSource | Sources | Literal[False]:
        """Assign a frequency dependent excitation to circuit ports from a frequency dependent source (FDS format).

        Parameters
        ----------
        ports : list
            List of circuit ports to assign to the frequency dependent excitation.
        input_file : str or :class:`pathlib.Path`
            Path to the frequency dependent file.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.Source`
            Circuit Source Object.

        References
        ----------
        >>> oDesign.UpdateSources
        """
        ...
    
    @pyaedt_function_handler(positive_terminal="assignment", negative_terminal="reference", common_name="common_mode", diff_name="differential_mode", common_ref="common_reference", diff_ref_z="differential_reference")
    def set_differential_pair(self, assignment, reference, common_mode=..., differential_mode=..., common_reference=..., differential_reference=..., active=...): # -> bool:
        """Add a differential pair definition.

        Parameters
        ----------
        assignment : str
            Name of the terminal to use as the positive terminal.
        reference : str
            Name of the terminal to use as the negative terminal.
        common_mode : str, optional
            Name for the common mode. The default is ``None``, in which case a unique name is assigned.
        differential_mode : str, optional
            Name for the differential mode. The default is ``None``, in which case a unique name is assigned.
        common_reference : float, optional
            Reference impedance for the common mode. The units are Ohm. The default is ``25``.
        differential_reference : float, optional
            Reference impedance for the differential mode. Units are Ohm. Default is ``100``.
        active : bool, optional
            Whether to set the differential pair as active. The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetDiffPairs
        """
        ...
    
    @pyaedt_function_handler(filename="input_file")
    def load_diff_pairs_from_file(self, input_file): # -> bool:
        """Load differtential pairs definition from a file.

        You can use the ``save_diff_pairs_to_file()`` method to obtain the file format.
        New definitions are added only if they are compatible with the existing definitions in the project.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Full qualified name of the file containing the differential pairs definition.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.LoadDiffPairsFromFile
        """
        ...
    
    @pyaedt_function_handler(filename="output_file")
    def save_diff_pairs_to_file(self, output_file): # -> bool:
        """Save differential pairs definition to a file.

        If the file that is specified already exists, it is overwritten.

        Parameters
        ----------
        output_file : str or :class:`pathlib.Path`
            Full qualified name of the file to save the differential pairs definition to.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SaveDiffPairsToFile
        """
        ...
    
    @pyaedt_function_handler(netlist_file="input_file", datablock_name="name")
    def add_netlist_datablock(self, input_file, name=...): # -> bool:
        """Add a new netlist data block to the circuit schematic.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Path to the netlist file.
        name : str, optional
            Name of the data block.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(filepath="input_file")
    def browse_log_file(self, input_file=...): # -> Path | None:
        """Save the most recent log file in a new directory.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`, optional
            File path to save the new log file to. The default is the ``pyaedt`` folder.

        Returns
        -------
        str
            File Path.
        """
        ...
    
    @pyaedt_function_handler()
    def connect_circuit_models_from_multi_zone_cutout(self, project_connections, edb_zones_dict, ports=..., schematic_units=..., model_inc=...): # -> bool:
        """Connect circuit model from a multizone clipped project.

        Parameters
        ----------
        project_connections : dic[str][str]
            Dictionary of project connections returned from the
            ``edb.get_connected_ports_from_multizone_cutout()`` method.
        edb_zones_dict : dict[str][EDB PolygonData]
            Dictionary of zones returned by the ``edb.copy_zones()`` method.
        ports : dict[str][str]
            dictionary return from command edb.cutout_multizone_layout(). These ports are the ones created before
            processing the multizone clipping. Like for instance ports created on components resulting from previous
            automated workflow execution.
        schematic_units : str, optional
            Units for the schematic, such as ``"mm"`` or ``"in"``. The
            default is ``"mm"``.
        model_inc : float, optional
            Distance increment for adding models. The default is ``50``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        Examples
        --------
        These commands show how to get input arguments described in this method:
        - project_connections
        - edb_zone_dict
        -
        >>> edb = Edb(edb_file)
        >>> edb_zones = edb.copy_zones(r"C:\\Temp\\test")
        >>> defined_ports, project_connections = edb.cutout_multizone_layout(edb_zones, common_reference_net)
        >>> circ = Circuit()
        >>> circ.connect_circuit_models_from_multi_zone_cutout(project_connexions, edb_zones, defined_ports)
        """
        ...
    
    @pyaedt_function_handler(edb_path="input_dir")
    def import_edb_in_circuit(self, input_dir): # -> Literal[False]:
        """Import an EDB design inside a Circuit project.

        Parameters
        ----------
        input_dir : str
            Path of the EDB file to copy.

        Returns
        -------
            ``Hfss3DLayout`` component instance.
        """
        ...
    
    @pyaedt_function_handler(touchstone="input_file", probe_pins="tx_schematic_pins", probe_ref_pins="tx_schematic_differential_pins")
    @deprecate_argument(arg_name="analyze", message="The ``analyze`` argument will be removed in future versions. Analyze before exporting results.")
    def create_tdr_schematic_from_snp(self, input_file, tx_schematic_pins, tx_schematic_differential_pins=..., termination_pins=..., differential=..., rise_time=..., use_convolution=..., analyze=..., design_name=..., impedance=...):
        """Create a schematic from a Touchstone file and automatically setup a TDR transient analysis.

        Parameters
        ----------
        input_file : str
            Full path to the sNp file.
        tx_schematic_pins : list
            List of pins to attach to the probe components.
        tx_schematic_differential_pins : list, optional
            Reference pins to attach to probe components. The default is ``None``.
            This parameter is valid only in differential TDR probes.
        termination_pins : list, optional
            Pins to terminate. The default is ``None``.
        differential : bool, optional
            Whether the buffers are differential. The default is ``True``. If ``False``, the
            pins are single ended.
        rise_time : float, int, optional
            Rise time of the input pulse in picoseconds. The default is ``30``.
        use_convolution : bool, optional
            Whether to use convolution for the Touchstone file. The default is ``True``.
            If ``False``, state-space is used.
        analyze : bool
             Whether to automatically assign differential pairs. The default is ``False``.
        design_name : str, optional
            New schematic name. The default is ``"LNA"``.
        impedance : float, optional
            TDR single ended impedance. The default is ``50``. For differential tdr, it will be computed by PyAEDT.

        Returns
        -------

        """
        ...
    
    @pyaedt_function_handler(touchstone="input_file")
    @deprecate_argument(arg_name="analyze", message="The ``analyze`` argument will be removed in future versions. Analyze before exporting results.")
    def create_lna_schematic_from_snp(self, input_file, start_frequency=..., stop_frequency=..., auto_assign_diff_pairs=..., separation=..., pattern=..., analyze=..., design_name=...): # -> tuple[Literal[True], list[Any], list[Any]]:
        """Create a schematic from a Touchstone file and automatically set up an LNA analysis.

        This method optionally assigns differential pairs automatically based on name pattern.

        Parameters
        ----------
        input_file : str
            Full path to the sNp file.
        start_frequency : int, float, optional
            Start frequency in GHz of the LNA setup. The default is ``0``.
        stop_frequency  : int, float, optional
            Stop frequency in GHz of the LNA setup. The default is ``30``.
        auto_assign_diff_pairs : bool
            Whether to automatically assign differential pairs. The default is ``False``.
        separation : str, optional
            Character to use to separate port names. The default is ``"."``.
        pattern : list, optional
            Port name pattern. The default is ``["component", "pin", "net"]``.
        analyze : bool
             Whether to automatically assign differential pairs. The default is ``False``.
        design_name : str, optional
            New schematic name. The default is ``"LNA"``.

        Returns
        -------
        (bool, list, list)
            First argument is ``True`` if succeeded.
            Second and third argument are respectively names of the differential and common mode pairs.
        """
        ...
    
    @pyaedt_function_handler(touchstone="input_file", ibis_ami="ibis_tx_file", tx_pins="tx_schematic_pins", rx_pins="rx_schematic_pins", tx_refs="tx_schematic_differential_pins", rx_refs="rx_schematic_differentialial_pins")
    @deprecate_argument(arg_name="analyze", message="The ``analyze`` argument will be removed in future versions. Analyze before exporting results.")
    def create_ami_schematic_from_snp(self, input_file, ibis_tx_file, tx_buffer_name, rx_buffer_name, tx_schematic_pins, rx_schematic_pins, tx_schematic_differential_pins=..., rx_schematic_differentialial_pins=..., ibis_tx_component_name=..., ibis_rx_component_name=..., use_ibis_buffer=..., differential=..., bit_pattern=..., unit_interval=..., use_convolution=..., analyze=..., design_name=..., ibis_rx_file=..., create_setup=...):
        """Create a schematic from a Touchstone file and automatically set up an IBIS-AMI analysis.

        Parameters
        ----------
        input_file : str
            Full path to the sNp file.
        ibis_tx_file : str
            Full path to the IBIS file.
        ibis_tx_component_name : str, optional
            IBIS component name to use for the simulation of the transmitter.
            This parameter is needed only if IBIS component pins are used.
        ibis_rx_component_name : str, optional
            IBIS component name to use for the simulation of the receiver.
            This parameter is needed only if IBIS component pins are used.
        tx_buffer_name : str
            Transmission buffer name.
        rx_buffer_name : str
            Receiver buffer name
        tx_schematic_pins : list
            Pins to assign the transmitter IBIS.
        tx_schematic_differential_pins : list
            Reference pins to assign the transmitter IBIS. This parameter is only used in
            a differential configuration.
        rx_schematic_pins : list
            Pins to assign the receiver IBIS.
        rx_schematic_differentialial_pins : list
            Reference pins to assign the receiver IBIS. This parameter is only used
            in a differential configuration.
        use_ibis_buffer : bool, optional
            Whether to use the IBIS buffer. The default is ``True``. If ``False``, pins are used.
        differential : bool, optional
            Whether the buffers are differential. The default is ``True``. If ``False``,
            the buffers are single-ended.
        bit_pattern : str, optional
            IBIS bit pattern.
        unit_interval : str, optional
            Unit interval of the bit pattern.
        use_convolution : bool, optional
            Whether to use convolution for the Touchstone file. The default is
            ``True``. If ``False``, state-space is used.
        analyze : bool
             Whether to automatically assign differential pairs. The default is ``False``.
        design_name : str, optional
            New schematic name. The default is ``"LNA"``.
        ibis_rx_file : str, optional
            Ibis receiver file.
        create_setup : bool, optional
            Whether to create a transient or an ami setup. The default is ``True``.

        Returns
        -------
        (bool, list, list)
            First argument is ``True`` if successful.
            Second and third arguments are respectively the names of the tx and rx mode probes.
        """
        ...
    
    @pyaedt_function_handler()
    @deprecate_argument(arg_name="analyze", message="The ``analyze`` argument will be removed in future versions. Analyze before exporting results.")
    def create_ibis_schematic_from_snp(self, input_file, ibis_tx_file, tx_buffer_name, rx_buffer_name, tx_schematic_pins, rx_schematic_pins, ibis_rx_file=..., tx_schematic_differential_pins=..., rx_schematic_differential_pins=..., ibis_tx_component_name=..., ibis_rx_component_name=..., use_ibis_buffer=..., differential=..., bit_pattern=..., unit_interval=..., use_convolution=..., analyze=..., design_name=..., is_ami=..., create_setup=...):
        """Create a schematic from a Touchstone file and automatically set up an IBIS-AMI analysis.

        Parameters
        ----------
        input_file : str
            Full path to the sNp file.
        ibis_tx_file : str
            Full path to the IBIS file.
        tx_buffer_name : str
            Transmission buffer name. It can be a buffer or an ibis pin name.
            In the latter case the user has to provide also the component_name.
        rx_buffer_name : str
            Receiver buffer name.
        tx_schematic_pins : list
            Pins to assign to the transmitter IBIS.
        rx_schematic_pins : list, optional
            Pins to assign to the receiver IBIS.
        tx_schematic_differential_pins : list, optional
            Reference pins to assign to the transmitter IBIS. This parameter is only used in
            a differential configuration.
        rx_schematic_differential_pins : list
            Reference pins to assign to the receiver IBIS. This parameter is only used
            in a differential configuration.
        ibis_tx_component_name : str, optional
            IBIS component name to use for the simulation of the transmitter.
            This parameter is needed only if IBIS component pins are used.
        ibis_rx_component_name : str, optional
            IBIS component name to use for the simulation of the receiver.
            This parameter is needed only if IBIS component pins are used.
        use_ibis_buffer : bool, optional
            Whether to use the IBIS buffer. The default is ``True``. If ``False``, pins are used.
        differential : bool, optional
            Whether the buffers are differential. The default is ``True``. If ``False``,
            the buffers are single-ended.
        bit_pattern : str, optional
            IBIS bit pattern.
        unit_interval : str, optional
            Unit interval of the bit pattern.
        use_convolution : bool, optional
            Whether to use convolution for the Touchstone file. The default is
            ``True``. If ``False``, state-space is used.
        analyze : bool
             Whether to automatically assign differential pairs. The default is ``False``.
        design_name : str, optional
            New schematic name. The default is ``"IBIS"``.
        is_ami : bool, optional
            Whether the ibis is AMI. The default is ``False``.
        ibis_rx_file : str, optional
            Ibis receiver file.
        create_setup : bool, optional
            Whether to create transient or ami setup. The default is ``True``.

        Returns
        -------
        (bool, list, list)
            First argument is ``True`` if successful.
            Second and third arguments are respectively the names of the tx and rx mode probes.
        """
        ...
    
    @pyaedt_function_handler()
    @deprecate_argument(arg_name="analyze", message="The ``analyze`` argument will be removed in future versions. Analyze before exporting results.")
    def create_ibis_schematic_from_pins(self, ibis_tx_file, ibis_rx_file=..., tx_buffer_name=..., rx_buffer_name=..., tx_schematic_pins=..., rx_schematic_pins=..., tx_schematic_differential_pins=..., rx_schematic_differential_pins=..., tx_component_name=..., rx_component_name=..., ibis_tx_component_name=..., ibis_rx_component_name=..., use_ibis_buffer=..., differential=..., bit_pattern=..., unit_interval=..., use_convolution=..., analyze=..., is_ami=..., create_setup=...):
        """Create a schematic from a list of pins and automatically set up an IBIS-AMI analysis.

        Parameters
        ----------
        ibis_tx_file : str
            Full path to the IBIS file for transmitters.
        ibis_rx_file : str
            Full path to the IBIS file for receiver.
        tx_buffer_name : str
            Transmission buffer name. It can be a buffer or a ibis pin name.
            In this last case the user has to provide also the component_name.
        rx_buffer_name : str
            Receiver buffer name.
        tx_schematic_pins : list
            Pins to assign to the transmitter IBIS.
        rx_schematic_pins : list, optional
            Pins to assign to the receiver IBIS.
        tx_schematic_differential_pins : list, optional
            Reference pins to assign to the transmitter IBIS. This parameter is only used in
            a differential configuration.
        rx_schematic_differential_pins : list
            Reference pins to assign to the receiver IBIS. This parameter is only used
            in a differential configuration.
        tx_component_name : str, optional
            Component name in AEDT circuit schematic to which tx_pins belongs.
        rx_component_name : str, optional
            Component name in AEDT circuit schematic to which rx_pins belongs.
        ibis_tx_component_name : str, optional
            IBIS component name to use for the simulation of the transmitter.
            This parameter is needed only if IBIS component pins are used.
        ibis_rx_component_name : str, optional
            IBIS component name to use for the simulation of the receiver.
            This parameter is needed only if IBIS component pins are used.
        use_ibis_buffer : bool, optional
            Whether to use the IBIS buffer. The default is ``True``. If ``False``, pins are used.
        differential : bool, optional
            Whether the buffers are differential. The default is ``True``. If ``False``,
            the buffers are single-ended.
        bit_pattern : str, optional
            IBIS bit pattern.
        unit_interval : str, optional
            Unit interval of the bit pattern.
        use_convolution : bool, optional
            Whether to use convolution for the Touchstone file. The default is
            ``True``. If ``False``, state-space is used.
        analyze : bool
             Whether to automatically assign differential pairs. The default is ``False``.
        is_ami : bool, optional
            Whether the ibis is AMI. The default is ``False``.
        create_setup : bool, optional
            Whether to create transient or ami setup. The default is ``True``.


        Returns
        -------
        (bool, list, list)
            First argument is ``True`` if successful.
            Second and third arguments are respectively the names of the tx and rx mode probes.
        """
        ...
    
    @pyaedt_function_handler()
    def create_schematic_from_asc_file(self, input_file, config_file=...):
        """Import an asc schematic and convert to Circuit Schematic. Only passives and sources will be imported.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Path to asc file.
        config_file : str, optional
            Path to configuration file to map components. Default is None which uses internal mapping.

        Returns
        -------
        bool
            ``True`` if successful.
        """
        ...
    
    @pyaedt_function_handler()
    def import_table(self, input_file, link=..., header_rows=..., rows_to_read=..., column_separator=..., data_type=..., sweep_columns=..., total_columns=..., real_columns=...): # -> Literal[False]:
        """Import a data table as a solution.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Full path to the file.
        link : bool, optional
            Whether to link the file to the solution. The default is ``False``.
        header_rows : int, optional
            Header rows. The default is ``0``.
        rows_to_read : int, optional
            Rows to read. If ``-1``, then reads until end of file. The default is ``-1``.
        column_separator : str, optional
            Column separator type. Available options are ``Space``, ``Tab``, ``Comma``, and ``Period``.
            The default is ``Space``.
        data_type : str, optional
            Data type. Available options are ``real``, ``real_imag``, ``mag_ang_deg``, and ``mag_ang_rad``.
            The default is ``real``.
        sweep_columns : int, optional
            Sweep columns. The default is ``0``.
        total_columns : int, optional
            Total number of columns. If ``-1``, then reads the total number of columns. The default is ``-1``.
        real_columns : int, optional
            Number of lefmotst real columns. The default is ``1``.

        Returns
        -------
        str
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportData

        Examples
        --------
        >>> from ansys.aedt.core import Circuit
        >>> cir = Circuit()
        >>> cir.import_table(input_file="my_file.csv")
        """
        ...
    
    @pyaedt_function_handler()
    def delete_imported_data(self, name): # -> bool:
        """Delete imported data.

        Parameters
        ----------
        name : str
            Delete table.

        Returns
        -------
        str
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.RemoveImportData

        Examples
        --------
        >>> from ansys.aedt.core import Circuit
        >>> cir = Circuit()
        >>> table_name = cir.import_table(input_file="my_file.csv")
        >>> cir.delete_imported_data(table_name)
        """
        ...
    


