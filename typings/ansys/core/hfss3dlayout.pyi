"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.application.analysis_3d_layout import FieldAnalysis3DLayout
from ansys.aedt.core.application.analysis_hf import ScatteringMethods
from ansys.aedt.core.generic.general_methods import pyaedt_function_handler
from ansys.aedt.core.internal.checks import min_aedt_version
from ansys.aedt.core.modeler.pcb.object_3d_layout import Line3dLayout
from ansys.aedt.core.modules.boundary.layout_boundary import BoundaryObject3dLayout

"""This module contains the ``Hfss3dLayout`` class."""
class Hfss3dLayout(FieldAnalysis3DLayout, ScatteringMethods):
    """Provides the HFSS 3D Layout application interface.

    This class inherits all objects that belong to HFSS 3D Layout, including EDB
    API queries.

    Parameters
    ----------
    project : str, optional
        Name of the project to select or the full path to the project
        or AEDTZ archive to open or the path to the ``aedb`` folder or
        ``edb.def`` file. The default is ``None``, in which case an
        attempt is made to get an active project. If no projects are present,
        an empty project is created.
    design : str, optional
        Name of the design to select. The default is ``None``, in
        which case an attempt is made to get an active design. If no
        designs are present, an empty design is created.
    solution_type : str, optional
        Solution type to apply to the design. The default is
        ``None``, in which case the default type is applied.
    setup : str, optional
        Name of the setup to use as the nominal. The default is
        ``None``, in which case the active setup is used or
        nothing is used.
    version : str, int, float, optional
        Version of AEDT to use. The default is ``None``, in which case
        the active version or latest installed version is used.
        Examples of input values are ``251``, ``25.1``, ``2025.1``, ``"2025.1"``.
    non_graphical : bool, optional
        Whether to launch AEDT in non-graphical mode. The default
        is ``True```, in which case AEDT is launched in graphical mode.
        This parameter is ignored when a script is launched within AEDT.
    new_desktop : bool, optional
        Whether to launch an instance of AEDT in a new thread, even if
        another instance of the ``specified_version`` is active on the
        machine. The default is ``False``.
    close_on_exit : bool, optional
        Whether to release AEDT on exit. The default is ``False``.
    student_version : bool, optional
        Whether to open the AEDT student version. The default is ``False``.
    machine : str, optional
        Machine name to connect the oDesktop session to. This works only in 2022 R2 or later.
        The remote server must be up and running with the command `"ansysedt.exe -grpcsrv portnum"`.
        If the machine is `"localhost"`. the server also starts if not present.
    port : int, optional
        Port number on which to start the oDesktop communication on an already existing server.
        This parameter is ignored when creating a new server. It works only in 2022 R2 or later.
        The remote server must be up and running with the command `"ansysedt.exe -grpcsrv portnum"`.
    aedt_process_id : int, optional
        Process ID for the instance of AEDT to point PyAEDT at. The default is
        ``None``. This parameter is only used when ``new_desktop = False``.
    ic_mode : bool, optional
        Whether to set the design to IC mode or not. The default is ``None``, which  means to retain
        the existing setting.
    remove_lock : bool, optional
        Whether to remove lock to project before opening it or not.
        The default is ``False``, which means to not unlock
        the existing project if needed and raise an exception.

    Examples
    --------
    Create an ``Hfss3dLayout`` object and connect to an existing HFSS
    design or create a new HFSS design if one does not exist.

    >>> from ansys.aedt.core import Hfss3dLayout
    >>> aedtapp = Hfss3dLayout()

    Create an ``Hfss3dLayout`` object and link to a project named
    ``projectname``. If this project does not exist, create one with
    this name.

    >>> aedtapp = Hfss3dLayout(projectname)

    Create an ``Hfss3dLayout`` object and link to a design named
    ``designname`` in a project named ``projectname``.

    >>> aedtapp = Hfss3dLayout(projectname, designame)

    Create an ``Hfss3dLayout`` object and open the specified project.

    >>> aedtapp = Hfss3dLayout("myfile.aedt")

    Create an AEDT 2025 R1 object and then create a
    ``Hfss3dLayout`` object and open the specified project.

    >>> aedtapp = Hfss3dLayout(version="2025.1", project="myfile.aedt")

    Create an instance of ``Hfss3dLayout`` from an ``Edb``

    >>> import ansys.aedt.core
    >>> edb_path = "/path/to/edbfile.aedb"
    >>> edb = ansys.aedt.core.Edb(edb_path, edbversion=251)
    >>> edb.stackup.import_stackup("stackup.xml")  # Import stackup. Manipulate edb, ...
    >>> edb.save_edb()
    >>> edb.close_edb()
    >>> aedtapp = ansys.aedt.core.Hfss3dLayout(version=251, project=edb_path)

    """
    @pyaedt_function_handler(designname="design", projectname="project", specified_version="version", setup_name="setup", new_desktop_session="new_desktop")
    def __init__(self, project=..., design=..., solution_type=..., setup=..., version=..., non_graphical=..., new_desktop=..., close_on_exit=..., student_version=..., machine=..., port=..., aedt_process_id=..., ic_mode=..., remove_lock=...) -> None:
        ...
    
    @property
    def ic_mode(self): # -> None:
        """IC mode of current design.

        Returns
        -------
        bool
        """
        ...
    
    @ic_mode.setter
    def ic_mode(self, value): # -> None:
        ...
    
    @pyaedt_function_handler(primivitivename="assignment", edgenumber="edge_number", iscircuit="is_circuit_port", iswave="is_wave_port", ref_primitive_name="reference_primitive", ref_edge_number="reference_edge_number")
    def create_edge_port(self, assignment: str | Line3dLayout, edge_number: int, is_circuit_port: bool = ..., is_wave_port: bool = ..., wave_horizontal_extension: float = ..., wave_vertical_extension: float = ..., wave_launcher: str = ..., reference_primitive: str = ..., reference_edge_number: str | int = ...) -> BoundaryObject3dLayout | bool:
        """Create an edge port.

        Parameters
        ----------
        assignment : str or :class:`ansys.aedt.core.modeler.pcb.object_3d_layout.Line3dLayout`
            Name of the primitive to create the edge port on.
        edge_number :
            Edge number to create the edge port on.
        is_circuit_port : bool, optional
            Whether the edge port is a circuit port. The default is ``False``.
        is_wave_port : bool, optional
            Whether the edge port is a wave port. The default is ``False``.
        wave_horizontal_extension : float, optional
            Horizontal port extension factor. The default is `5`.
        wave_vertical_extension : float, optional
            Vertical port extension factor. The default is `5`.
        wave_launcher : str, optional
            PEC (perfect electrical conductor) launcher size with units. The
            default is `"1mm"`.
        reference_primitive : str, optional
            Name of the reference primitive to place negative edge port terminal.
            The default is ``None``.
        reference_edge_number : str, int
            Edge number of reference primitive. The default is ``0``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`
            Port objcet port when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(primitive_name="assignment")
    def create_wave_port(self, assignment, edge_number, wave_horizontal_extension=..., wave_vertical_extension=..., wave_launcher=...): # -> BoundaryObject3dLayout | bool:
        """Create a single-ended wave port.

        Parameters
        ----------
        assignment : str
            Name of the primitive to create the edge port on.
        edge_number : int
            Edge number to create the edge port on.
        wave_horizontal_extension : float, optional
            Horizontal port extension factor. The default is ``5``.
        wave_vertical_extension : float, optional
            Vertical port extension factor. The default is ``5``.
        wave_launcher : str, optional
            PEC (perfect electrical conductor) launcher size with units. The
            default is ``"1mm"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`
            Port objcet port when successful, ``False`` when failed.

        References
        ----------
        """
        ...
    
    @pyaedt_function_handler(primivitivenames="assignment", edgenumbers="edge_numbers")
    def create_wave_port_from_two_conductors(self, assignment=..., edge_numbers=...): # -> BoundaryObject3dLayout | Literal[False]:
        """Create a wave port.

        Parameters
        ----------
        assignment : list, optional
            List of the primitive names to create the wave port on.
            The list must have two entries, one entry for each of the two conductors,
            or the method is not executed.

        edge_numbers : list, optional
            List of the edge number to create the wave port on.
            The list must have two entries, one entry for each of the two edges,
            or the method is not executed.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`
            Port objcet port when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(component_name="component")
    def dissolve_component(self, component): # -> Literal[True]:
        """Dissolve a component and remove it from 3D Layout.

        Parameters
        ----------
        component : str
            Name of the component.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.


        """
        ...
    
    @pyaedt_function_handler(component_name="component")
    def create_ports_on_component_by_nets(self, component, nets): # -> list[Any]:
        """Create the ports on a component for a list of nets.

        Parameters
        ----------
        component : str
            Component name.
        nets : str, list
            Nets to include.


        Returns
        -------
        list[:class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`]
            Port Objects when successful.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(component_name="component")
    def create_pec_on_component_by_nets(self, component, nets): # -> Literal[True]:
        """Create a PEC connection on a component for a list of nets.

        Parameters
        ----------
        component : str
            Component name.
        nets : str, list
            Nets to include.


        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(port_name="name")
    def create_differential_port(self, via_signal, via_reference, name, deembed=...): # -> BoundaryObject3dLayout | Literal[False]:
        """Create a differential port.

        Parameters
        ----------
        via_signal : str
            Signal pin.
        via_reference : float
            Reference pin.
        name : str
            New Port Name.
        deembed : bool, optional
            Whether to deembed parasitics. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`
            Port Object when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(vianame="via")
    def create_coax_port(self, via, radial_extent=..., layer=..., alignment=...): # -> BoundaryObject3dLayout | Literal[False]:
        """Create a coax port.

        Parameters
        ----------
        via : str
            Name of the via to create the port on.
        radial_extent : float
            Radial coax extension.
        layer : str
            Name of the layer to apply the reference to.
        alignment : str, optional
            Port alignment on the layer.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`
            Port Object when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreateEdgePort
        """
        ...
    
    @pyaedt_function_handler(xpos="x", ypos="y", bot_layer="bottom_layer")
    def create_pin_port(self, name, x=..., y=..., rotation=..., top_layer=..., bottom_layer=...): # -> BoundaryObject3dLayout | Literal[False]:
        """Create a pin port.

        Parameters
        ----------
        name : str
            Name of the pin port.
        x : float, optional
            X-axis position of the pin. The default is ``0``.
        y : float, optional
            Y-axis position of the pin. The default is ``0``.
        rotation : float, optional
            Rotation of the pin in degrees. The default is ``0``.
        top_layer : str, optional
            Top layer of the pin. The default is ``None``, in which case the top
            layer is assigned automatically.
        bottom_layer : str
            Bottom layer of the pin. The default is ``None``, in which case the
            bottom layer is assigned automatically.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.BoundaryObject3dLayout`

            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oEditor.CreatePin
        """
        ...
    
    @pyaedt_function_handler(portname="name")
    def delete_port(self, name, remove_geometry=...): # -> Literal[True]:
        """Delete a port.

        Parameters
        ----------
        name : str
            Name of the port.
        remove_geometry : bool, optional
            Whether to remove geometry. The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.Delete
        >>> oModule.DeleteExcitations
        """
        ...
    
    @pyaedt_function_handler(edb_full_path="input_folder")
    def import_edb(self, input_folder): # -> Literal[True]:
        """Import EDB.

        Parameters
        ----------
        input_folder : str or :class:`pathlib.Path`
            Full path to EDB.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportEDB
        """
        ...
    
    @pyaedt_function_handler(outputdir="output_dir")
    def validate_full_design(self, name=..., output_dir=..., ports=...): # -> tuple[list[Any], bool]:
        """Validate the design based on the expected value and save the information in the log file.

        Parameters
        ----------
        name : str, optional
            Name of the design to validate. The default is ``None``.
        output_dir : str, optional
            Output directory to save the log file to. The default is ``None``,
            in which case the file is exported to the working directory.

        ports : str, optional
            Number of excitations that are expected. The default is ``None``.

        Returns
        -------
        list of str
            List of validation messages.

        References
        ----------
        >>> oDesign.ValidateDesign
        """
        ...
    
    @pyaedt_function_handler(plot_name="plot")
    def create_scattering(self, plot=..., sweep_name=..., port_names=..., port_excited=..., variations=...): # -> Literal[False]:
        """Create a scattering report.

        Parameters
        ----------
        plot : str, optional
            Name of the plot. The default is ``"S Parameter Plot Nominal"``.
        sweep_name : str, optional
            Name of the sweep. The default is ``None``.
        port_names : str or list, optional
            One or more port names. The default is ``None``.
        port_excited : optional
            The default is ``None``.
        variations : optional
            The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.CreateReport
        """
        ...
    
    @pyaedt_function_handler(activate="export", export_dir="output_dir")
    def export_touchstone_on_completion(self, export=..., output_dir=...): # -> Literal[True]:
        """Enable or disable the automatic export of the touchstone file after completing frequency sweep.

        Parameters
        ----------
        export : bool, optional
            Whether to export the Touchstone file after the simulation. The default is ``True``.
        output_dir : str, optional
            Path to the directory of exported file. The default is the project path.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.DesignOptions
        """
        ...
    
    @pyaedt_function_handler()
    @min_aedt_version("2025.1")
    def set_export_touchstone(self, file_format=..., enforce_passivity=..., enforce_causality=..., use_common_ground=..., show_gamma_comments=..., renormalize=..., impedance=..., fitting_error=..., maximum_poles=..., passivity_type=..., column_fitting_type=..., state_space_fitting=..., relative_error_tolerance=..., ensure_accurate_fit=..., touchstone_output=..., units=..., precision=...): # -> Literal[True]:
        """Set or disable the automatic export of the touchstone file after completing frequency sweep.

        Parameters
        ----------
        file_format : str, optional
            Touchstone format. Available options are: ``"TouchStone1.0"``, and ``"TouchStone2.0"``.
            The default is ``"TouchStone1.0"``.
        enforce_passivity : bool, optional
            Enforce passivity. The default is ``True``.
        enforce_causality : bool, optional
            Enforce causality. The default is ``False``.
        use_common_ground : bool, optional
            Use common ground. The default is ``True``.
        show_gamma_comments : bool, optional
            Show gamma comments. The default is ``True``.
        renormalize : bool, optional
            Renormalize. The default is ``False``.
        impedance : float, optional
            Impedance in ohms. The default is ``50.0``.
        fitting_error : float, optional
            Fitting error. The default is ``0.5``.
        maximum_poles : int, optional
            Maximum number of poles. The default is ``10000``.
        passivity_type : str, optional
            Passivity type. Available options are: ``"PassivityByPerturbation"``, ``"IteratedFittingOfPV"``,
            ``"IteratedFittingOfPVLF"``, and ``"ConvexOptimization"``.
        column_fitting_type : str, optional
            Column fitting type. Available options are: ``"Matrix"``, `"Column"``, and `"Entry"``.
        state_space_fitting : str, optional
            State space fitting algorithm. Available options are: ``"IterativeRational"``, `"TWA"``, and `"FastFit"``.
        relative_error_tolerance : bool, optional
            Relative error tolerance. The default is ``True``.
        ensure_accurate_fit : bool, optional
            Ensure accurate impedance fit. The default is ``False``.
        touchstone_output : str, optional
            Touchstone output format. Available options are: ``"MA"`` for magnitude and phase in ``deg``,
            ``"RI"`` for real and imaginary part, and ``"DB"`` for magnitude in ``dB`` and phase in ``deg``.
        units : str, optional
            Frequency units. The default is ``"GHz"``.
        precision : int, optional
            Touchstone precision. The default is ``11``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oTool.SetExportTouchstoneOptions

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dlayout
        >>> layout = Hfss3dlayout()
        >>> layout.export_touchstone_on_completion()
        >>> layout.export_touchstone_on_completion()


        """
        ...
    
    @pyaedt_function_handler()
    def set_meshing_settings(self, mesh_method=..., enable_intersections_check=..., use_alternative_fallback=...): # -> Literal[True]:
        """Define the settings of the mesh.

        Parameters
        ----------
        mesh_method : string
            Mesh method. The default is ``"Phi"``. Options are ``"Phi"``, ``"PhiPlus"``,
            and ``"Classic"``.
        enable_intersections_check : bool, optional
            Whether to enable the alternative mesh intersections checks. The default is
            ``True``.
        use_alternative_fallback : bool, optional
            Whether to enable the alternative fall back mesh method. The default is ``True``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.DesignOptions
        """
        ...
    
    @pyaedt_function_handler(setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_linear_count_sweep(self, setup, unit, start_frequency, stop_frequency, num_of_freq_points, name=..., save_fields=..., save_rad_fields_only=..., sweep_type=..., interpolation_tol_percent=..., interpolation_max_solutions=..., use_q3d_for_dc=...): # -> Literal[False]:
        """Create a sweep with the specified number of points.

        Parameters
        ----------
        setup : str
            Name of the setup to attach to the sweep.
        unit : str
            Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
        start_frequency : float
            Starting frequency of the sweep.
        stop_frequency : float
            Stopping frequency of the sweep.
        num_of_freq_points : int
            Number of frequency points in the range.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save fields for a discrete sweep only. The
            default is ``True``.
        save_rad_fields_only : bool, optional
            Whether to save only radiated fields if
            ``save_fields=True``. The default is ``False``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``,
            ``"Interpolating"``, and ``"Discrete"``.  The default is
            ``"Interpolating"``.
        interpolation_tol_percent : float, optional
            Error tolerance threshold for the interpolation process.
            The default is ``0.5``.
        interpolation_max_solutions : int, optional
            Maximum number of solutions to evaluate for the
            interpolation process. The default is ``250``.
        use_q3d_for_dc : bool, optional
            Whether to use Q3D to solve the DC point. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS3DLayout` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AddSweep
        """
        ...
    
    @pyaedt_function_handler(setup_name="setup", setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name", sweep_name="name")
    def create_linear_step_sweep(self, setup, unit, start_frequency, stop_frequency, step_size, name=..., save_fields=..., save_rad_fields_only=..., sweep_type=..., interpolation_tol_percent=..., interpolation_max_solutions=..., use_q3d_for_dc=...): # -> Literal[False]:
        """Create a sweep with the specified frequency step.

        Parameters
        ----------
        setup : str
            Name of the setup to attach to the sweep.
        unit : str
            Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
        start_frequency : float
            Starting frequency of the sweep.
        stop_frequency : float
            Stopping frequency of the sweep.
        step_size : float
            Frequency size of the step.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save fields for a discrete sweep only. The
            default is ``True``.
        save_rad_fields_only : bool, optional
            Whether to save only radiated fields if
            ``save_fields=True``. The default is ``False``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``,
            ``"Interpolating"``, and ``"Discrete"``.
            The default is ``"Interpolating"``.
        interpolation_tol_percent : float, optional
            Error tolerance threshold for the interpolation
            process. The default is ``0.5``.
        interpolation_max_solutions : int, optional
            Maximum number of solutions to evaluate for the
            interpolation process. The default is ``250``.
        use_q3d_for_dc : bool, optional
            Whether to use Q3D to solve the DC point. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS3DLayout` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AddSweep
        """
        ...
    
    @pyaedt_function_handler(setupname="setup", sweepname="name")
    def create_single_point_sweep(self, setup, unit, freq, name=..., save_fields=..., save_rad_fields_only=...): # -> Literal[False]:
        """Create a sweep with a single frequency point.

        Parameters
        ----------
        setup : str
            Name of the setup.
        unit : str
            Unit of the frequency. For example, ``"MHz`` or ``"GHz"``.
        freq : float, list
            Frequency of the single point or list of frequencies to create distinct single points.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save fields for all points and subranges defined in the sweep. The default is ``False``.
        save_rad_fields_only : bool, optional
            Whether to save only radiating fields. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AddSweep
        """
        ...
    
    @pyaedt_function_handler(gds_path="input_file", aedb_path="output_dir")
    def import_gds(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import a GDS file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the GDS file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML or TECH file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
            If a TECH file is provided and the layer name starts with ``"v"``, the layer
            is mapped as a via layer.
        set_as_active : bool, optional
            Whether to set the GDS file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the GDS file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportGDSII
        """
        ...
    
    @pyaedt_function_handler(dxf_path="input_file", aedb_path="output_dir")
    def import_dxf(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import a DXF file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the DXF file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML or TECH file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
            If a TECH file is provided and the layer name starts with ``"v"``, the layer
            is mapped as a via layer.
        set_as_active : bool, optional
            Whether to set the DXF file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the DXF file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportDXF
        """
        ...
    
    @pyaedt_function_handler(gerber_path="input_file", aedb_path="output_dir")
    def import_gerber(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import a Gerber zip file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the Gerber zip file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
        set_as_active : bool, optional
            Whether to set the Gerber zip file file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the Gerber zip file file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportGerber
        """
        ...
    
    @pyaedt_function_handler(aedb_path="output_dir")
    def import_brd(self, input_file, output_dir=..., set_as_active=..., close_active_project=..., control_file=...): # -> bool:
        """Import a board file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the board file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        set_as_active : bool, optional
            Whether to set the board file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the board file.
            The default is ''False``.
        control_file : str, optional
            Path to the XML file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportExtracta
        """
        ...
    
    @pyaedt_function_handler(aedb_path="output_dir")
    def import_awr(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import an AWR Microwave Office file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the AWR Microwave Office file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
        set_as_active : bool, optional
            Whether to set the AWR Microwave Office file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the AWR Microwave Office file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportAWRMicrowaveOffice
        """
        ...
    
    @pyaedt_function_handler(aedb_path="output_dir")
    def import_ipc2581(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import an IPC2581 file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the IPC2581 file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
        set_as_active : bool, optional
            Whether to set the IPC2581 file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the IPC2581 file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportAWRMicrowaveOffice
        """
        ...
    
    @pyaedt_function_handler(aedb_path="output_dir")
    def import_odb(self, input_file, output_dir=..., control_file=..., set_as_active=..., close_active_project=...): # -> bool:
        """Import an ODB++ file into HFSS 3D Layout and assign the stackup from an XML file if present.

        Parameters
        ----------
        input_file : str
            Full path to the ODB++ file.
        output_dir : str, optional
            Full path to the AEDB folder. For example, ``"c:\\temp\\test.aedb"``.
        control_file : str, optional
            Path to the XML file with the stackup information. The default is ``None``, in
            which case the stackup is not edited.
        set_as_active : bool, optional
            Whether to set the ODB++ file as active. The default is ``True``.
        close_active_project : bool, optional
            Whether to close the active project after loading the ODB++ file.
            The default is ''False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportAWRMicrowaveOffice
        """
        ...
    
    @pyaedt_function_handler()
    def edit_cosim_options(self, simulate_missing_solution=..., align_ports=..., renormalize_ports=..., renorm_impedance=..., setup_override_name=..., sweep_override_name=..., use_interpolating_sweep=..., use_y_matrix=..., interpolation_algorithm=...): # -> bool:
        """Edit cosimulation options.

        Parameters
        ----------
        simulate_missing_solution : bool, optional
            Whether the solver is to simulate a missing solution. The default is ``True``. If
            ``False``, the solver interpolates a missing solution.
        align_ports : bool, optional
            Whether the solver is to align microwave parts. The default is ``True``.
        renormalize_ports : bool, optional
            Whether to renormalize port impendance. The default is ``True``.
        renorm_impedance : float, optional
            Renormalization impedance in ohms. The default is ``50``.
        setup_override_name : str, optional
            Setup name if there is a setup override. The default is ``None``.
        sweep_override_name : str, optional
            Sweep name if there is a sweep override. The default is ``None``.
        use_interpolating_sweep : bool, optional
            Whether the solver is to use an interpolating sweep. The default is ``True``.
            If ``False``, the solver is to use a discrete sweep.
        use_y_matrix : bool, optional
            Whether the interpolation algorithm is to use the Y matrix. The default is
            ``True``.
        interpolation_algorithm : str, optional
            Interpolation algorithm to use. Options are ``"auto"``, ``"lin"``, ``"shadH"``,
            and ``"shadNH"``. The default is ``"auto"``.

        Returns
        -------
        bool
            ``True`` if successful and ``False`` if failed.

        References
        ----------
        >>> oDesign.EditCoSimulationOptions

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dLayout
        >>> h3d = Hfss3dLayout()
        >>> h3d.edit_cosim_options(
        ...     simulate_missing_solution=True,
        ...     align_ports=True,
        ...     renormalize_ports=True,
        ...     renorm_impedance=50,
        ...     setup_override_name=None,
        ...     sweep_override_name=None,
        ...     use_interpolating_sweep=False,
        ...     use_y_matrix=True,
        ...     interpolation_algorithm="auto",
        ... )

        """
        ...
    
    @pyaedt_function_handler(positive_terminal="assignment", negative_terminal="reference", common_name="common_mode", diff_name="differential_mode", common_ref="common_reference", diff_ref_z="differential_reference")
    def set_differential_pair(self, assignment, reference, common_mode=..., differential_mode=..., common_reference=..., differential_reference=..., active=..., matched=...): # -> bool:
        """Add a differential pair definition.

        Parameters
        ----------
        assignment : str
            Name of the terminal to use as the positive terminal.
        reference : str
            Name of the terminal to use as the negative terminal.
        common_mode : str, optional
            Name for the common mode. The default is ``None``, in which case a unique name is assigned.
        differential_mode : str, optional
            Name for the differential mode. The default is ``None``, in which case a unique name is assigned.
        common_reference : float, optional
            Reference impedance for the common mode in ohms. The default is ``25``.
        differential_reference : float, optional
            Reference impedance for the differential mode in ohms. The default is ``100``.
        active : bool, optional
            Whether to set the differential pair as active. The default is ``True``.
        matched : bool, optional
            Whether to set the differential pair as active. The default is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.SetDiffPairs
        """
        ...
    
    @pyaedt_function_handler()
    def get_differential_pairs(self) -> list:
        """Get the list defined differential pairs.

        Returns
        -------
        list
            List of differential pairs.

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dLayout
        >>> hfss = Hfss3dLayout()
        >>> hfss.get_defined_diff_pairs()
        """
        ...
    
    @pyaedt_function_handler(filename="input_file")
    def load_diff_pairs_from_file(self, input_file: str) -> bool:
        """Load differential pairs definition from a file.

        You can use the ``save_diff_pairs_to_file`` method to obtain the file format.
        The ``File End Of Line`` must be UNIX (LF).
        New definitions are added only if compatible with the existing definition already defined in the project.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Full path to the differential pairs definition file.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.LoadDiffPairsFromFile
        """
        ...
    
    @pyaedt_function_handler(filename="output_file")
    def save_diff_pairs_to_file(self, output_file: str) -> bool:
        """Save differtential pairs definition to a file.

        If a file with the specified name already exists, it is overwritten.

        Parameters
        ----------
        output_file : str
            Full path to the differential pairs definition file.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.SaveDiffPairsToFile
        """
        ...
    
    @pyaedt_function_handler(file_name="output_file")
    def export_3d_model(self, output_file=...): # -> Path:
        """Export the Ecad model to a 3D file.

        Parameters
        ----------
        output_file : str, optional
            Full name of the file to export. The default is ``None``, in which case the file name is
            set to the design name and saved as a SAT file in the working directory.
            Extensions available are ``"sat"``, ``"sab"``, and ``"sm3"`` up to AEDT 2022 R2 and
            Parasolid format `"x_t"` from AEDT 2023R1.

        Returns
        -------
        str
            File name if successful.
        """
        ...
    
    @pyaedt_function_handler()
    def enable_rigid_flex(self): # -> bool:
        """Turn on or off the rigid flex of a board with bending if available.

        This function is the same for both turning on and off rigid flex.

        Returns
        -------
        bool
            ``True`` if rigid flex is turned off, ``False``` if rigid flex is turned off.
            In non-graphical, ``True`` is always returned due to a bug in the native API.
        """
        ...
    
    @pyaedt_function_handler()
    def edit_hfss_extents(self, diel_extent_type=..., diel_extent_horizontal_padding=..., diel_honor_primitives_on_diel_layers=..., air_extent_type=..., air_truncate_model_at_ground_layer=..., air_vertical_positive_padding=..., air_vertical_negative_padding=..., airbox_values_as_dim=..., air_horizontal_padding=...): # -> Literal[True]:
        """Edit HFSS 3D Layout extents.

        Parameters
        ----------
        diel_extent_type : str, optional
            Dielectric extent type. The default is ``None``. Options are ``"BboxExtent"``,
            ``"ConformalExtent"``, and ``"ConvexHullExtent"``.
        diel_extent_horizontal_padding : str, optional
            Dielectric extent horizontal padding. The default is ``None``.
        diel_honor_primitives_on_diel_layers : str, optional
            Whether to set dielectric honor primitives on dielectric layers. The default is ``None``.
        air_extent_type : str, optional
            Airbox extent type. The default is ``None``. Options are ``"BboxExtent"``,
            ``"ConformalExtent"``, and ``"ConvexHullExtent"``.
        air_truncate_model_at_ground_layer : str, optional
            Whether to set airbox truncate model at ground layer. The default is ``None``.
        air_vertical_positive_padding : str, optional
            Airbox vertical positive padding. The default is ``None``.
        air_vertical_negative_padding : str, optional
            Airbox vertical negative padding. The default is ``None``.
        airbox_values_as_dim : bool, optional
            Either if inputs are dims or not. Default is `True`.
        air_horizontal_padding : float, optional
            Airbox horizontal padding. The default is ``None``.


        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler()
    def get_model_from_mesh_results(self, binary=...): # -> Path | Literal['']:
        """Get the path for the parasolid file in the result folder.

        The parasolid file is generated after the mesh is created in 3D Layout.

        Parameters
        ----------
        binary : str, optional
            Either if retrieve binary format of parasoli or not.

        Returns
        -------
        str
            Path for the parasolid file in the results folder.
        """
        ...
    
    @pyaedt_function_handler(source_name="source", file_name="input_file")
    def edit_source_from_file(self, source, input_file, is_time_domain=..., x_scale=..., y_scale=..., impedance=..., data_format=..., encoding=..., include_post_effects=..., incident_voltage=..., window=...): # -> bool:
        """Edit a source from file data.

        File data is a csv containing either frequency data or time domain data that will be converted through FFT.

        Parameters
        ----------
        source : str
            Source Name.
        input_file : str
            Full name of the input file.
        is_time_domain : bool, optional
            Whether the input data is time-based. The defaulti s ``True``. If
            ``False``, the input data is frequency-based. Frequency-based data
            is degrees in this format: ``Mag/Phase``.
        x_scale : float, optional
            Scaling factor for x axis.
        y_scale : float, optional
            Scaling factor for y axis.
        impedance : float, optional
            Excitation impedance. Default is `50`.
        data_format : str, optional
            Either `"Power"`, `"Current"` or `"Voltage"`.
        encoding : str, optional
            Csv file encoding.
        include_post_effects : bool, optional
            Either if include or not post-processing effects. Default is `True`,
        incident_voltage : bool, optional
            Either if include or incident or total voltage. Default is `True`, for incident voltage.
        window : str, optional
            Fft window. Options are ``"hamming"``, ``"hanning"``, ``"blackman"``, ``"bartlett"`` or ``None``.

        Returns
        -------
        bool
        """
        ...
    
    @pyaedt_function_handler(setup_name="setup")
    def get_dcir_solution_data(self, setup, show=..., category=...): # -> Literal[False]:
        """Retrieve dcir solution data. Available element_names are dependent on element_type as below.

        Sources ["Voltage", "Current", "Power"]
        "RL" ['Loop Resistance', 'Path Resistance', 'Resistance', 'Inductance']
        "Vias" ['X', 'Y', 'Current', 'Limit', 'Resistance', 'IR Drop', 'Power']
        "Bondwires" ['Current', 'Limit', 'Resistance', 'IR Drop']
        "Probes" ['Voltage'].

        Parameters
        ----------
        setup : str
            Name of the setup.
        show : str, optional
            Type of the element. Options are ``"Sources"`, ``"RL"`, ``"Vias"``, ``"Bondwires"``, and ``"Probes"``.
        category : str, optional
            Name of the element. Options are ``"Voltage"`, ``"Current"`, ``"Power"``, ``"Loop_Resistance"``,
            ``"Path_Resistance"``, ``"Resistance"``, ``"Inductance"``, ``"X"``, ``"Y"``, ``"Limit"`` and ``"IR Drop"``.

        Returns
        -------
        from ansys.aedt.core.modules.solutions.SolutionData
        """
        ...
    
    @pyaedt_function_handler(setup_name="setup")
    def get_dcir_element_data_loop_resistance(self, setup): # -> DataFrame:
        """Get dcir element data loop resistance.

        Parameters
        ----------
        setup : str
            Name of the setup.

        Returns
        -------
        pandas.Dataframe
        """
        ...
    
    @pyaedt_function_handler(setup_name="setup")
    def get_dcir_element_data_current_source(self, setup): # -> DataFrame:
        """Get dcir element data current source.

        Parameters
        ----------
        setup : str
            Name of the setup.

        Returns
        -------
        pandas.Dataframe
        """
        ...
    
    @pyaedt_function_handler(setup_name="setup")
    def get_dcir_element_data_via(self, setup): # -> DataFrame | None:
        """Get dcir element data via.

        Parameters
        ----------
        setup : str
            Name of the setup.

        Returns
        -------
        pandas.Dataframe
        """
        ...
    
    @pyaedt_function_handler()
    def show_extent(self, show=...): # -> bool:
        """Show or hide extent in a HFSS3dLayout design.

        Parameters
        ----------
        show : bool, optional
            Whether to show or not the extent.
            The default value is ``True``.

        Returns
        -------
        bool
            ``True`` is successful, ``False`` if it fails.

        >>> oEditor.SetHfssExtentsVisible

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dLayout
        >>> h3d = Hfss3dLayout()
        >>> h3d.show_extent(show=True)
        """
        ...
    
    @pyaedt_function_handler()
    def change_options(self, color_by_net=...): # -> bool:
        """Change options for an existing layout.

        It changes design visualization by color.

        Parameters
        ----------
        color_by_net : bool, optional
            Whether visualize color by net or by layer.
            The default value is ``True``, which means color by net.

        Returns
        -------
        bool
            ``True`` if successful, ``False`` if it fails.

        >>> oEditor.ChangeOptions

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dLayout
        >>> h3d = Hfss3dLayout()
        >>> h3d.change_options(color_by_net=True)
        """
        ...
    
    @pyaedt_function_handler()
    def export_touchstone_on_completion(self, export=..., output_dir=...): # -> Literal[True]:
        """Enable or disable the automatic export of the touchstone file after completing frequency sweep.

        Parameters
        ----------
        export : bool, optional
            Whether to enable the export.
            The default is ``True``.
        output_dir : str, optional
            Path to the directory of exported file. The default is the project path.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetDesignSettings
        """
        ...
    
    @pyaedt_function_handler()
    def import_table(self, input_file, link=..., header_rows=..., rows_to_read=..., column_separator=..., data_type=..., sweep_columns=..., total_columns=..., real_columns=...): # -> Literal[False]:
        """Import a data table as a solution.

        Parameters
        ----------
        input_file : str
            Full path to the file.
        link : bool, optional
            Whether to link the file to the solution. The default is ``False``.
        header_rows : int, optional
            Header rows. The default is ``0``.
        rows_to_read : int, optional
            Rows to read. If ``-1``, then reads until end of file. The default is ``-1``.
        column_separator : str, optional
            Column separator type. Available options are ``Space``, ``Tab``, ``Comma``, and ``Period``.
            The default is ``Space``.
        data_type : str, optional
            Data type. Available options are ``real``, ``real_imag``, ``mag_ang_deg``, and ``mag_ang_rad``.
            The default is ``real``.
        sweep_columns : int, optional
            Sweep columns. The default is ``0``.
        total_columns : int, optional
            Total number of columns. If ``-1``, then reads the total number of columns. The default is ``-1``.
        real_columns : int, optional
            Number of lefmotst real columns. The default is ``1``.

        Returns
        -------
        str
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportData

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dlayout
        >>> h3d = Hfss3dlayout()
        >>> h3d.import_table(input_file="my_file.csv")
        """
        ...
    
    @pyaedt_function_handler()
    def delete_imported_data(self, name): # -> bool:
        """Delete imported data.

        Parameters
        ----------
        name : str
            Table to delete.

        Returns
        -------
        str
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.RemoveImportData

        Examples
        --------
        >>> from ansys.aedt.core import Hfss3dlayout
        >>> h3d = Hfss3dlayout()
        >>> table_name = h3d.import_table(input_file="my_file.csv")
        >>> h3d.delete_imported_data(table_name)
        """
        ...
    


