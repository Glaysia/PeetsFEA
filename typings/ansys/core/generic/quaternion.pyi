"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.generic.general_methods import pyaedt_function_handler

class Quaternion:
    """
    Implements fundamental quaternion operations.

    Quaternions are created using ``Quaternion(a, b, c, d)``.

    Quaternions are only used to represent rotations in 3D space.
    They are not used to represent translations or other transformations.
    Only methods related to rotations are implemented.

    The quaternion is defined as:
    .. math::
        q = a + bi + cj + dk
    where ``a`` is the scalar part and ``b``, ``c``, and ``d`` are the vector parts.

    This updated class offers enhanced functionality compared to the previous implementation,
    supporting both intrinsic and extrinsic rotations. Note that AEDT coordinate systems use intrinsic rotation.


    References
    ----------

    [1] https://en.wikipedia.org/wiki/Quaternion
    [2] https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
    [3] https://www.euclideanspace.com/maths/geometry/rotations/conversions/

    """
    def __init__(self, a=..., b=..., c=..., d=...) -> None:
        """Initialize the quaternion.
        Quaternions are created using ``Quaternion(a, b, c, d)``, representing the form q = a + bi + cj + dk.

        Parameters
        ----------

        a, b, c, d : float
            The quaternion coefficients.
        """
        ...
    
    @property
    def a(self): # -> float:
        ...
    
    @property
    def b(self): # -> float:
        ...
    
    @property
    def c(self): # -> float:
        ...
    
    @property
    def d(self): # -> float:
        ...
    
    @classmethod
    @pyaedt_function_handler()
    def from_euler(cls, angles, sequence, extrinsic=...): # -> Quaternion:
        """Creates a normalized rotation quaternion from the Euler angles using the specified rotation sequence.

        Parameters
        ----------

        angles : list, tuple of 3 floats
            The Euler angles in radians.

        sequence : str
            A three-character string indicating the rotation axis sequence (e.g., "xyz" or "ZYX").
            It is case-insensitive and must contain only the characters 'x', 'y', or 'z'.

        extrinsic : bool, optional
            If ``True``, the rotation is treated as extrinsic.
            If ``False`` (default), it is treated as intrinsic.

        Returns
        -------

        Quaternion
            A unit quaternion representing the rotation defined by the Euler angles in the given sequence.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> from math import pi
        >>> q = Quaternion.from_euler([pi / 2, 0, 0], "xyz")
        >>> q
        Quaternion(0.7071067811865476, 0.7071067811865476, 0, 0)

        >>> q = Quaternion.from_euler([0, pi / 2, pi], "zyz", extrinsic=True)
        >>> q
        Quaternion(0, -0.7071067811865476, 0, 0.7071067811865476)

        >>> q = Quaternion.from_euler([0, pi / 2, pi], "zyz")
        >>> q
        Quaternion(0, 0.7071067811865476, 0, 0.7071067811865476)
        """
        ...
    
    @pyaedt_function_handler()
    def to_euler(self, sequence, extrinsic=...): # -> tuple[int, ...]:
        """
        Converts the quaternion to Euler angles using the specified rotation sequence.

        The conversion follows the method described in [1]. In degenerate (gimbal lock) cases,
        the third angle is set to zero for stability.

        Parameters
        ----------
        sequence : str
            A three-character string indicating the rotation axis sequence (e.g., "xyz" or "ZYX").
            It is case-insensitive and must contain only the characters 'x', 'y', or 'z'.

        extrinsic : bool, optional
            If ``True``, the rotation is treated as extrinsic.
            If ``False`` (default), it is treated as intrinsic.

        Note
        ----
        Tait–Bryan angles (Heading, Pitch, Bank) correspond to an intrinsic "ZYX" sequence.

        Returns
        -------
        tuple of float
            A tuple of three Euler angles representing the same rotation as the quaternion.
            Angle in radians.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q = Quaternion(0.9069661433330367, -0.17345092325178477, -0.3823030778615049, -0.03422789400943274)
        >>> q.to_euler("zxz")
        (-2.0344439357957027, 0.8664730673456006, 1.9590019609437583)
        >>> q.to_euler("zyz")
        (2.677945044588987, 0.8664730673456006, -2.7533870194409316)

        References
        ----------

        [1] https://doi.org/10.1371/journal.pone.0276302
        [2] https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
        """
        ...
    
    @classmethod
    @pyaedt_function_handler()
    def from_axis_angle(cls, axis, angle): # -> Self:
        """Creates a normalized rotation quaternion from a given axis and rotation angle.


        Parameters
        ----------

        axis : List or tuple of float
            A 3D vector representing the axis of rotation.
        angle : float
            The rotation angle in radians.

        Returns
        -------

        Quaternion
            A unit quaternion representing the rotation around the specified axis by the given angle.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> from math import pi, sqrt
        >>> Quaternion.from_axis_angle((sqrt(3) / 3, sqrt(3) / 3, sqrt(3) / 3), 2 * pi / 3)
        Quaternion(0.5, 0.5, 0.5, 0.5)
        """
        ...
    
    @pyaedt_function_handler()
    def to_axis_angle(self): # -> tuple[tuple[float, float, float], float] | tuple[tuple[Any | float, Any | float, Any | float], float]:
        """Convert a quaternion to the axis angle rotation formulation.

        Returns
        -------
        tuple
            ((ux, uy, uz), theta) containing the rotation axes expressed as X, Y, Z components of
            the unit vector ``u`` and the rotation angle theta expressed in radians.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q = Quaternion(1, 1, 1, 1)
        >>> (axis, angle) = q.to_axis_angle()
        >>> axis
        (0.5773502691896257, 0.5773502691896257, 0.5773502691896257)
        >>> angle
        2.0943951023931953

        """
        ...
    
    @classmethod
    @pyaedt_function_handler()
    def from_rotation_matrix(cls, rotation_matrix): # -> Self:
        """Converts a 3x3 rotation matrix to a quaternion.
        It uses the method described in [1].

        Parameters
        ----------

        rotation_matrix: List or tuple
            Rotation matrix defined as a list of lists or a tuple of tuples.
            The matrix should be 3x3 and orthogonal.
            The matrix is assumed to be in the form:
            ((m00, m01, m02), (m10, m11, m12), (m20, m21, m22))

        Returns
        -------

        Quaternion
            The quaternion defined by the rotation matrix.

        References
        ----------
        [1] https://doi.org/10.1145/325334.325242 (pp. 245-254)

        Examples
        --------
        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> x = (0.7053456158585982, 0.07053456158585963, 0.7053456158585982)
        >>> y = (0.19470872568244832, 0.937486456989565, -0.2884573713814046)
        >>> z = (-0.681598176590997, 0.34079908829549865, 0.6475182677614472)
        >>> rotation_matrix = Quaternion.axis_to_rotation_matrix(x, y, z)
        >>> q = Quaternion.from_rotation_matrix(rotation_matrix)
        >>> q
        Quaternion(0.9069661433330367, -0.17345092325178477, -0.3823030778615049, -0.03422789400943274)

        """
        ...
    
    @pyaedt_function_handler()
    def to_rotation_matrix(self): # -> tuple[tuple[float, float, float], tuple[float, float, float], tuple[float, float, float]]:
        """Returns the rotation matrix corresponding to the quaternion.


        Returns
        -------

        tuple
            A 3×3 rotation matrix equivalent to the quaternion's rotation.
            The matrix is provided in the form:
            ((m00, m01, m02), (m10, m11, m12), (m20, m21, m22))

        Examples
        --------
        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q = Quaternion(0.9069661433330367, -0.17345092325178477, -0.3823030778615049, -0.03422789400943274)
        >>> rotation_matrix = q.to_rotation_matrix()
        >>> rotation_matrix
        ((0.7053456158585982, 0.07053456158585963, 0.7053456158585982),
         (0.19470872568244832, 0.937486456989565, -0.2884573713814046),
         (-0.681598176590997, 0.34079908829549865, 0.6475182677614472))

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def rotation_matrix_to_axis(rotation_matrix): # -> tuple[tuple[Any, ...], tuple[Any, ...], tuple[Any, ...]]:
        """Convert a rotation matrix to the corresponding axis of rotation.
        Parameters
        ----------
        rotation_matrix : tuple of tuples or list of lists
            A 3x3 rotation matrix defined as a tuple of tuples or a list of lists.
            The matrix should be orthogonal.
        Returns
        -------
        tuple
            The X, Y, and Z axes of the rotated frame.
        Examples
        --------
        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> rotation_matrix = (
        ...     (0.7071067811865476, 0.0, 0.7071067811865476),
        ...     (0.0, 1.0, 0.0),
        ...     (-0.7071067811865476, 0.0, 0.7071067811865476),
        ... )
        >>> x, y, z = Quaternion.rotation_matrix_to_axis(rotation_matrix)
        >>> x
        (0.7071067811865476, 0.0, -0.7071067811865476)
        >>> y
        (0.0, 1.0, 0.0)
        >>> z
        (-0.7071067811865476, 0.0, 0.7071067811865476)
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def axis_to_rotation_matrix(x_axis, y_axis, z_axis): # -> tuple[tuple[Any, Any, Any], tuple[Any, Any, Any], tuple[Any, Any, Any]]:
        """Construct a rotation matrix from three orthonormal axes.

        Parameters
        ----------
        x_axis : tuple of float
            The X axis of the rotated frame.
        y_axis : tuple of float
            The Y axis of the rotated frame.
        z_axis : tuple of float
            The Z axis of the rotated frame.

        Returns
        -------
        tuple of tuples
            A 3x3 rotation matrix where each column is one of the given axes.

        Raises
        ------
        ValueError
            If the axes do not form an orthonormal basis.
        """
        ...
    
    @pyaedt_function_handler()
    def rotate_vector(self, v): # -> tuple[Any | float, Any | float, Any | float]:
        """Evaluate the rotation of a vector, defined by a quaternion.

        Evaluated as:
        ``"q = q0 + q' = q0 + q1i + q2j + q3k"``,
        ``"w = qvq* = (q0^2 - |q'|^2)v + 2(q' • v)q' + 2q0(q' x v)"``.

        Parameters
        ----------
        v : tuple or List
            ``(x, y, z)`` coordinates for the vector to be rotated.

        Returns
        -------
        tuple
            ``(w1, w2, w3)`` coordinates for the rotated vector ``w``.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q = Quaternion(0.9238795325112867, 0.0, -0.3826834323650898, 0.0)
        >>> v = (1, 0, 0)
        >>> q.rotate_vector(v)
        (0.7071067811865475, 0.0, 0.7071067811865476)

        """
        ...
    
    @pyaedt_function_handler()
    def inverse_rotate_vector(self, v): # -> tuple[Any | float, Any | float, Any | float]:
        """Evaluate the inverse rotation of a vector that is defined by a quaternion.
        It can also be the rotation of the coordinate frame with respect to the vector.

            q = q0 + q' = q0 + iq1 + jq2 + kq3
            q* = q0 - q' = q0 - iq1 - jq2 - kq3
            w = q*vq

        Parameters
        ----------
        v : tuple or List
            ``(x, y, z)`` coordinates for the vector to be rotated.

        Returns
        -------
        tuple
            ``(w1, w2, w3)`` coordinates for the rotated vector ``w``.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q = Quaternion(0.9238795325112867, 0.0, -0.3826834323650898, 0.0)
        >>> v = (1, 0, 0)
        >>> q.rotate_vector(v)
        (0.7071067811865475, 0.0, 0.7071067811865476)

        """
        ...
    
    def __add__(self, other): # -> Quaternion:
        ...
    
    def __radd__(self, other): # -> Quaternion:
        ...
    
    def __sub__(self, other):
        ...
    
    def __mul__(self, other): # -> Quaternion:
        ...
    
    def __rmul__(self, other): # -> Quaternion:
        ...
    
    def __neg__(self): # -> Quaternion:
        ...
    
    def __truediv__(self, other): # -> Quaternion:
        ...
    
    def __rtruediv__(self, other): # -> Quaternion:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @pyaedt_function_handler()
    def add(self, other): # -> Quaternion:
        """Adds another quaternion or compatible value to this quaternion.

        Parameters
        ----------
        other : Quaternion, List, tuple, float, or int
            The value to be added.
            It can be another Quaternion or a sequence that can be interpreted as one.
            It can also be a scalar value (float or int).

        Returns
        -------
        Quaternion
            A new quaternion representing the sum of this quaternion and the provided value.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q1 = Quaternion(1, 2, 3, 4)
        >>> q2 = Quaternion(5, 6, 7, 8)
        >>> q1.add(q2)
        Quaternion(6, 8, 10, 12)
        >>> q1 + 7
        Quaternion(8, 2, 3, 4)

        """
        ...
    
    @pyaedt_function_handler()
    def mul(self, other): # -> Quaternion:
        """Performs quaternion multiplication with another quaternion or compatible value.

        Parameters
        ----------
        other : Quaternion, List, tuple, float, or int
            The value to multiply with this quaternion.
            It can be another Quaternion or a sequence that can be interpreted as one.
            It can also be a scalar value (float or int).

        Returns
        -------
        Quaternion
            A new quaternion representing the product of this quaternion and the given value.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q1 = Quaternion(1, 2, 3, 4)
        >>> q2 = Quaternion(5, 6, 7, 8)
        >>> q1.mul(q2)
        Quaternion(-60, 12, 30, 24)
        >>> q1.mul(2)
        Quaternion(2, 4, 6, 8)
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def hamilton_prod(q1, q2): # -> Quaternion:
        """Evaluate the Hamilton product of two quaternions, ``q1`` and ``q2``, defined as:
                q1 = p0 + p' = p0 + ip1 + jp2 + kp3
                q2 = q0 + q' = q0 + iq1 + jq2 + kq3
                m = q1*q2 = p0q0 - p' • q' + p0q' + q0p' + p' x q'

        Parameters
        ----------

        q1 : Quaternion, List, tuple
            The value to multiply with this quaternion.
            It can be another Quaternion or a sequence that can be interpreted as one.
        q2 : Quaternion, List, tuple
            The value to multiply with this quaternion.
            It can be another Quaternion or a sequence that can be interpreted as one.

        q1 and q2 must be quaternions or compatible values. Multiplicaiton between quaternions and scalar values is
        handled by the method ``mul``

        Returns
        -------

        Quaternion
            The quaternion result of the multiplication between q1 and q2

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q1 = Quaternion(1, 2, 3, 4)
        >>> q2 = Quaternion(5, 6, 7, 8)
        >>> Quaternion.hamilton_prod(q1, q2)
        Quaternion(-60, 12, 30, 24)
        """
        ...
    
    @pyaedt_function_handler()
    def conjugate(self): # -> Quaternion:
        """Returns the conjugate of the quaternion."""
        ...
    
    @pyaedt_function_handler()
    def norm(self): # -> float:
        """Returns the norm of the quaternion."""
        ...
    
    @pyaedt_function_handler()
    def normalize(self): # -> Quaternion:
        """Returns the normalized form of the quaternion."""
        ...
    
    @pyaedt_function_handler()
    def inverse(self): # -> Quaternion:
        """Returns the inverse of the quaternion."""
        ...
    
    @pyaedt_function_handler()
    def div(self, other): # -> Quaternion:
        """Performs quaternion division with another quaternion or compatible value.

        Parameters
        ----------
        other : Quaternion, List, tuple, float, or int
            The value to divide with this quaternion.
            It can be another Quaternion or a sequence that can be interpreted as one.
            It can also be a scalar value (float or int).

        Returns
        -------
        Quaternion
            A new quaternion representing the division of this quaternion and the given value.

        Examples
        --------

        >>> from ansys.aedt.core.generic.quaternion import Quaternion
        >>> q1 = Quaternion(1, 2, 3, 4)
        >>> q2 = Quaternion(1, -1, 1, 2)
        >>> q1.div(q2)
        Quaternion(10/7, 1/7, 10/7, -3/7)
        >>> q1.div(2)
        Quaternion(0.5, 1, 1.5, 2)
        """
        ...
    
    @pyaedt_function_handler()
    def coefficients(self): # -> tuple[float, float, float, float]:
        """Returns the coefficients of the quaternion as a tuple."""
        ...
    


