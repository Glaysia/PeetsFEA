"""
This type stub file was generated by pyright.
"""

from ansys.aedt.core.generic.general_methods import pyaedt_function_handler

class GeometryOperators:
    """Manages geometry operators."""
    @staticmethod
    @pyaedt_function_handler()
    def List2list(input_list): # -> list[Any]:
        """Convert a C# list object to a Python list.

        This function performs a deep conversion.

        Parameters
        ----------
        input_list : List
            C# list to convert to a Python list.

        Returns
        -------
        List
            Converted Python list.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def parse_dim_arg(string, scale_to_unit=..., variable_manager=...): # -> float | str | None:
        """Convert a number and unit to a float.

        Angles are converted in radians.

        Parameters
        ----------
        string : str, optional
            String to convert. For example, ``"2mm"``. The default is ``None``.
        scale_to_unit : str, optional
            Units for the value to convert. For example, ``"mm"``.
        variable_manager : :class:`ansys.aedt.core.application.variables.VariableManager`, optional
            Try to parse formula and returns numeric value.
            The default is ``None``.

        Returns
        -------
        float
            Value for the converted value and units. For example, ``0.002``.

        Examples
        --------
        Parse `'"2mm"'`.

        >>> from ansys.aedt.core.modeler.geometry_operators import GeometryOperators as go
        >>> go.parse_dim_arg("2mm")
        >>> 0.002

        Use the optional argument ``scale_to_unit`` to specify the destination unit.

        >>> go.parse_dim_arg("2mm", scale_to_unit="mm")
        >>> 2.0

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def cs_plane_to_axis_str(val): # -> Literal['Z', 'X', 'Y']:
        """Retrieve a string for a coordinate system plane.

        Parameters
        ----------
        val : int
            ``PLANE`` enum vélo.

        Returns
        -------
        str
           String for the coordinate system plane.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def cs_plane_to_plane_str(val): # -> Literal['XY', 'YZ', 'ZX']:
        """Retrieve a string for a coordinate system plane.

        Parameters
        ----------
        val :


        Returns
        -------
        str
           String for the coordinate system plane.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def cs_axis_str(val): # -> Literal['X', 'Y', 'Z']:
        """Retrieve a string for a coordinate system axis.

        Parameters
        ----------
        val : int
            ``AXIS`` enum value.


        Returns
        -------
        str
            String for the coordinate system axis.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def draft_type_str(val): # -> Literal['Extended', 'Round', 'Natural']:
        """Retrieve the draft type.

        Parameters
        ----------
        val : int
            ``SWEEPDRAFT`` enum value.

        Returns
        -------
        str
           Type of the draft.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def get_mid_point(v1, v2): # -> list[Any]:
        """Evaluate the midpoint between two points.

        Parameters
        ----------
        v1 : List
            List of ``[x, y, z]`` coordinates for the first point.
        v2 : List
            List of ``[x, y, z]`` coordinates for the second point.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the midpoint.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def get_triangle_area(v1, v2, v3): # -> float:
        """Evaluate the area of a triangle defined by its three vertices.

        Parameters
        ----------
        v1 : List
            List of ``[x, y, z]`` coordinates for the first vertex.
        v2 : List
            List of ``[x, y, z]`` coordinates for the second vertex.
        v3 : List
            List of ``[x, y, z]`` coordinates for the third vertex.

        Returns
        -------
        float
            Area of the triangle.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_cross(a, b): # -> list[Any]:
        """Evaluate the cross product of two geometry vectors.

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the result vector.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_dot(a, b): # -> Literal[False]:
        """Evaluate the dot product between two geometry vectors.

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.

        Returns
        -------
        float
            Result of the dot product.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_prod(s, v): # -> list[Any]:
        """Evaluate the product between a scalar value and a vector.

        Parameters
        ----------
        s : float
            Scalar value.
        v : List
            List of values for the vector in the format ``[v1, v2,..., vn]``.
            The vector can be any length.

        Returns
        -------
        List
            List of values for the result vector. This list is the
            same length as the list for the input vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_rotate_about_axis(vector, angle, radians=..., axis=...): # -> tuple[Any, Any, Any]:
        """Evaluate rotation of a vector around an axis.

        Parameters
        ----------
        vector : list
            List of the three component of the vector.
        angle : float
            Angle by which the vector is to be rotated (radians or degree).
        radians : bool, optional
            Whether the angle is expressed in radians. Default is ``False``.
        axis : str, optional
            Axis about which to rotate the vector. Default is ``"z"``.

        Returns
        -------
        list
            List of values for the result vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_sub(a, b): # -> list[Any]:
        """Evaluate two geometry vectors by subtracting them (a-b).

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the result vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_sum(a, b): # -> list[Any]:
        """Evaluate two geometry vectors by adding them (a+b).

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the result vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_norm(a): # -> float:
        """Evaluate the Euclidean norm of a geometry vector.

        Parameters
        ----------
        a : List
        List of ``[x, y, z]`` coordinates for the vector.

        Returns
        -------
        float
            Evaluated norm in the same unit as the coordinates for the input vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def normalize_vector(v): # -> list[Any]:
        """Normalize a geometry vector.

        Parameters
        ----------
        v : List
            List of ``[x, y, z]`` coordinates for vector.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the normalized vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_points(p1, p2): # -> list[Any]:
        """Vector from one point to another point.

        Parameters
        ----------
        p1 : List
            Coordinates ``[x1,y1,z1]`` for the first point.
        p2 : List
            Coordinates ``[x2,y2,z2]`` for second point.

        Returns
        -------
        List
            Coordinates ``[vx, vy, vz]`` for the vector from the first point to the second point.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def points_distance(p1, p2): # -> float | Literal[False]:
        """Evaluate the distance between two points expressed as their Cartesian coordinates.

        Parameters
        ----------
        p1 : List
            List of ``[x1,y1,z1]`` coordinates for the first point.
        p2 : List
            List of ``[x2,y2,z2]`` coordinates for the second ppint.

        Returns
        -------
        float
            Distance between the two points in the same unit as the coordinates for the points.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def find_point_on_plane(pointlists, direction=...): # -> float:
        """Find a point on a plane.

        Parameters
        ----------
        pointlists : List
            List of points.
        direction : int, optional
             The default is ``0``.

        Returns
        -------
        List

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def distance_vector(p, a, b): # -> list[Any]:
        """Evaluate the vector distance between point ``p`` and a line defined by two points, ``a`` and ``b``.

        .. note::
            he formula is  ``d = (a-p)-((a-p)dot p)n``, where ``a`` is a point of the line (either ``a`` or ``b``)
            and ``n`` is the unit vector in the direction of the line.

        Parameters
        ----------
        p : List
            List of ``[x, y, z]`` coordinates for the reference point.
        a : List
            List of ``[x, y, z]`` coordinates for the first point of the segment.
        b : List
            List of ``[x, y, z]`` coordinates for the second point of the segment.

        Returns
        -------
        List
            List of ``[x, y, z]`` coordinates for the distance vector.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_between_points(p, a, b, tol=...): # -> bool:
        """Check if a point lies on the segment defined by two points.

        Parameters
        ----------
        p : List
            List of ``[x, y, z]`` coordinates for the reference point ``p``.
        a : List
            List of ``[x, y, z]`` coordinates for the first point of the segment.
        b : List
            List of ``[x, y, z]`` coordinates for the second point of the segment.
        tol : float
            Linear tolerance. The default value is ``1e-6``.

        Returns
        -------
        bool
            ``True`` when the point lies on the segment defined by the two points, ``False`` otherwise.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_parallel(a1, a2, b1, b2, tol=...): # -> bool:
        """Check if a segment defined by two points is parallel to a segment defined by two other points.

        Parameters
        ----------
        a1 : List
            List of ``[x, y, z]`` coordinates for the first point of the fiirst segment.
        a2 : List
            List of ``[x, y, z]`` coordinates for the second point of the first segment.
        b1 : List
            List of ``[x, y, z]`` coordinates for the first point of the second segment.
        b2 : List
            List of ``[x, y, z]`` coordinates for the second point of the second segment.
        tol : float
            Linear tolerance. The default value is ``1e-6``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def parallel_coeff(a1, a2, b1, b2): # -> float:
        """ADD DESCRIPTION.

        Parameters
        ----------
        a1 : List
            List of ``[x, y, z]`` coordinates for the first point of the first segment.
        a2 : List
            List of ``[x, y, z]`` coordinates for the second point of the first segment.
        b1 : List
            List of ``[x, y, z]`` coordinates for the first point of the second segment.
        b2 : List
            List of ``[x, y, z]`` coordinates for the second point of the second segment.

        Returns
        -------
        float
            _vdot of 4 vertices of 2 segments.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_collinear(a, b, tol=...): # -> bool:
        """Check if two vectors are collinear (parallel or anti-parallel).

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.
        tol : float
            Linear tolerance. The default value is ``1e-6``.

        Returns
        -------
        bool
            ``True`` if vectors are collinear, ``False`` otherwise.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_projection_inside(a1, a2, b1, b2): # -> bool:
        """Project a segment onto another segment and check if the projected segment is inside it.

        Parameters
        ----------
        a1 : List
            List of ``[x, y, z]`` coordinates for the first point of the projected segment.
        a2 : List
            List of ``[x, y, z]`` coordinates for the second point of the projected segment.
        b1 : List
            List of ``[x, y, z]`` coordinates for the first point of the other segment.
        b2 : List
            List of ``[x, y, z]`` coordinates for the second point of the other segment.

        Returns
        -------
        bool
            ``True`` when the projected segment is inside the other segment, ``False`` otherwise.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def arrays_positions_sum(vertlist1, vertlist2): # -> float:
        """Return the sum of two vertices lists.

        Parameters
        ----------
        vertlist1 : List

        vertlist2 : List

        Returns
        -------
        float

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_angle(a, b): # -> float:
        """Evaluate the angle between two geometry vectors.

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.

        Returns
        -------
        float
            Angle in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def pointing_to_axis(*args, **kwargs): # -> tuple[tuple[Any, ...], tuple[Any, ...], tuple[Any, ...]]:
        """Retrieve the axes from the HFSS X axis and Y pointing axis as per
        the definition of the AEDT interface coordinate system.

        Parameters
        ----------
        x_pointing : List
            List of ``[x, y, z]`` coordinates for the X axis.

        y_pointing : List
            List of ``[x, y, z]`` coordinates for the Y pointing axis.

        Returns
        -------
        tuple
            ``[Xx, Xy, Xz], [Yx, Yy, Yz], [Zx, Zy, Zz]`` of the three axes (normalized).
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def axis_to_euler_zxz(x, y, z): # -> tuple[float, float, float]:
        """Retrieve Euler angles of a frame following the rotation sequence ZXZ.

        Provides an assumption for the gimbal lock problem.

        Parameters
        ----------
        x : List
            List of ``[Xx, Xy, Xz]`` coordinates for the X axis.
        y : List
            List of ``[Yx, Yy, Yz]`` coordinates for the Y axis.
        z : List
            List of ``[Zx, Zy, Zz]`` coordinates for the Z axis.

        Returns
        -------
        tuple
            (phi, theta, psi) containing the Euler angles in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def axis_to_euler_zyz(x, y, z): # -> tuple[float, float, float]:
        """Retrieve Euler angles of a frame following the rotation sequence ZYZ.

        Provides assumption for the gimbal lock problem.

        Parameters
        ----------
        x : List
            List of ``[Xx, Xy, Xz]`` coordinates for the X axis.
        y : List
            List of ``[Yx, Yy, Yz]`` coordinates for the Y axis.
        z : List
            List of ``[Zx, Zy, Zz]`` coordinates for the Z axis.

        Returns
        -------
        tuple
            (phi, theta, psi) containing the Euler angles in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def deg2rad(angle):
        """Convert the angle from degrees to radians.

        Parameters
        ----------
        angle : float
            Angle in degrees.

        Returns
        -------
        float
            Angle in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def rad2deg(angle):
        """Convert the angle from radians to degrees.

        Parameters
        ----------
        angle : float
            Angle in radians.

        Returns
        -------
        float
            Angle in degrees.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_orthonormal_triplet(x, y, z, tol=...): # -> bool:
        """Check if three vectors are orthonormal.
        Parameters
        ----------
        x : List or tuple
            List of ``(x1, x2, x3)`` coordinates for the first vector.
        y : List or tuple
            List of ``(y1, y2, y3)`` coordinates for the second vector.
        z : List or tuple
            List of ``(z1, z2, z3)`` coordinates for the third vector.
        tol : float, optional
            Linear tolerance. The default value is ``None``.
            If not specified, the value is set to ``MathUtils.EPSILON``.

        Returns
        -------
        bool
            ``True`` if the three vectors are orthonormal, ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_unit_vector(v, tol=...): # -> bool:
        """Check if a vector is a unit vector.

        Parameters
        ----------
        v : List or tuple
            List of ``(x1, x2, x3)`` coordinates for the vector.
        tol : float, optional
            Linear tolerance.
            The default value is ``None``.
            If not specified, the value is set to ``MathUtils.EPSILON``.

        Returns
        -------
        bool
            ``True`` if the vector is a unit vector, ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_orthogonal_matrix(matrix, tol=...): # -> bool:
        """
        Check if a given 3x3 matrix is orthogonal.

        An orthogonal matrix is a square matrix whose rows and columns are orthonormal vectors.
        This method verifies if the transpose of the matrix multiplied by the matrix itself
        results in an identity matrix within a specified tolerance.

        Parameters
        ----------
        matrix : List[List[float]]
            A 3x3 matrix represented as a list of lists.
        tol : float, optional
            Tolerance for numerical comparison.
            The default value is ``None``.
            If not specified, the value is set to ``MathUtils.EPSILON``.

        Returns
        -------
        bool
            True if the matrix is orthogonal, False otherwise.

        Examples
        --------
        Check if a matrix is orthogonal:

        >>> matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        >>> is_orthogonal_matrix(matrix)
        True

        >>> matrix = [[1, 0, 0], [0, 0, 1], [0, 1, 0]]
        >>> is_orthogonal_matrix(matrix)
        True

        >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
        >>> is_orthogonal_matrix(matrix)
        False
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def get_polygon_centroid(pts): # -> list[Any | float]:
        """Evaluate the centroid of a polygon defined by its points.

        Parameters
        ----------
        pts : List
            List of points, with each point defined by its ``[x,y,z]`` coordinates.

        Returns
        -------
        List
            List of [x,y,z] coordinates for the centroid of the polygon.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def cs_xy_pointing_expression(yaw, pitch, roll): # -> list[list[Any]]:
        """Return x_pointing and y_pointing vectors as expressions from the yaw, pitch, and roll input (as strings).

        Parameters
        ----------
        yaw : str
            String expression for the yaw angle (rotation about Z-axis)
        pitch : str
            String expression for the pitch angle (rotation about Y-axis)
        roll : str
            String expression for the roll angle (rotation about X-axis)

        Returns
        -------
        [x_pointing, y_pointing] vector expressions.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def get_numeric(s): # -> float:
        """Convert a string to a numeric value. Discard the suffix."""
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_small(s): # -> bool:
        """Return ``True`` if the number represented by s is zero (i.e very small).

        Parameters
        ----------
        s : numeric or str
            Variable value.

        Returns
        -------
            bool
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_vector_equal(v1, v2, tolerance=...): # -> bool:
        """Return ``True`` if two vectors are equal.

        Parameters
        ----------
        v1 : List
            List of ``[x, y, z]`` coordinates for the first vector.
        v2 : List
            List of ``[x, y, z]`` coordinates for the second vector.
        tolerance : float, optional
            Linear tolerance. The default value is ``None``.
            If not specified, the value is set to ``MathUtils.EPSILON``.

        Returns
        -------
        bool
            ``True`` if the two vectors are equal, ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def numeric_cs(cs_in): # -> list[float] | list[float | Any] | list[int] | None:
        """Return a list of [x,y,z] numeric values given a coordinate system as input.

        Parameters
        ----------
        cs_in : List of str or str
            ``["x", "y", "z"]`` or "Global".
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def orient_polygon(x, y, clockwise=...): # -> tuple[Any, Any]:
        """Orient a polygon clockwise or counterclockwise.

        The vertices should be already ordered either way.
        Use this function to change the orientation.
        The polygon is represented by its vertices coordinates.


        Parameters
        ----------
        x : List
            List of x coordinates of the vertices. Length must be >= 1.
            Degenerate polygon with only 2 points is also accepted, in this case the points are returned unchanged.
        y : List
            List of y coordinates of the vertices. Must be of the same length as x.
        clockwise : bool
            If ``True`` the polygon is oriented clockwise, if ``False`` it is oriented counterclockwise.
            Default is ``True``.

        Returns
        -------
        List of List
            Lists of oriented vertices.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_angle_sign(va, vb, vn, right_handed=...): # -> float:
        """Evaluate the signed angle between two geometry vectors.

        The sign is evaluated respect to the normal to the plane containing the two vectors as per the following rule.
        In case of opposite vectors, it returns an angle equal to 180deg (always positive).
        Assuming that the plane normal is normalized (vb == 1), the signed angle is simplified.
        For the right-handed rotation from Va to Vb:
        - atan2((va x Vb) . vn, va . vb).
        For the left-handed rotation from Va to Vb:
        - atan2((Vb x va) . vn, va . vb).

        Parameters
        ----------
        va : List
            List of ``[x, y, z]`` coordinates for the first vector.
        vb : List
            List of ``[x, y, z]`` coordinates for the second vector.
        vn : List
            List of ``[x, y, z]`` coordinates for the plane normal.
        right_handed : bool
            Whether to consider the right-handed rotation from va to vb. The default is ``True``.
            When ``False``, left-hand rotation from va to vb is considered.

        Returns
        -------
        float
            Angle in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def v_angle_sign_2D(va, vb, right_handed=...): # -> float:
        """Evaluate the signed angle between two 2D geometry vectors.

        It is the 2D version of the ``GeometryOperators.v_angle_sign`` considering vn = [0,0,1].
        In case of opposite vectors, it returns an angle equal to 180deg (always positive).

        Parameters
        ----------
        va : List
            List of ``[x, y]`` coordinates for the first vector.
        vb : List
            List of ``[x, y]`` coordinates for the second vector.
        right_handed : bool
            Whether to consider the right-handed rotation from Va to Vb. The default is ``True``.
            When ``False``, left-hand rotation from Va to Vb is considered.

        Returns
        -------
        float
            Angle in radians.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def point_in_polygon(point, polygon, tolerance=...): # -> Literal[0, -1, 1]:
        """Determine if a point is inside, outside the polygon or at exactly at the border.

        The method implements the radial algorithm (https://es.wikipedia.org/wiki/Algoritmo_radial)

        This version supports also self-intersecting polygons.

        point : List
            List of ``[x, y]`` coordinates.
        polygon : List
            [[x1, x2, ..., xn],[y1, y2, ..., yn]]
        tolerance : float
            tolerance used for the algorithm. Default value is 1e-8.

        Returns
        -------
        int
            - ``-1`` When the point is outside the polygon.
            - ``0`` When the point is exactly on one of the sides of the polygon.
            - ``1`` When the point is inside the polygon.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_point_in_polygon(point, polygon): # -> bool:
        """Determine if a point is inside or outside a polygon, both located on the same plane.

        The method implements the radial algorithm (https://es.wikipedia.org/wiki/Algoritmo_radial)

        point : List
            List of ``[x, y]`` coordinates.
        polygon : List
            [[x1, x2, ..., xn],[y1, y2, ..., yn]]

        Returns
        -------
        bool
            ``True`` if the point is inside the polygon or exactly on one of its sides.
            ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def are_segments_intersecting(a1, a2, b1, b2, include_collinear=...): # -> bool:
        """
        Determine if the two segments a and b are intersecting.

        a1 : List
            First point of segment a. List of ``[x, y]`` coordinates.
        a2 : List
            Second point of segment a. List of ``[x, y]`` coordinates.
        b1 : List
            First point of segment b. List of ``[x, y]`` coordinates.
        b2 : List
            Second point of segment b. List of ``[x, y]`` coordinates.
        include_collinear : bool
            If ``True`` two segments are considered intersecting also if just one end lies on the other segment.
            Default is ``True``.

        Returns
        -------
        bool
            ``True`` if the segments are intersecting.
            ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_segment_intersecting_polygon(a, b, polygon): # -> bool:
        """Determine if a segment defined by two points ``a`` and ``b`` intersects a polygon.

        Points on the vertices and on the polygon boundaries are not considered intersecting.

        Parameters
        ----------
        a : List
            First point of the segment. List of ``[x, y]`` coordinates.
        b : List
            Second point of the segment. List of ``[x, y]`` coordinates.
        polygon : List
            [[x1, x2, ..., xn],[y1, y2, ..., yn]]

        Returns
        -------
        float
            ``True`` if the segment intersect the polygon. ``False`` otherwise.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_perpendicular(a, b, tol=...): # -> bool:
        """Check if two vectors are perpendicular.

        Parameters
        ----------
        a : List
            List of ``[x, y, z]`` coordinates for the first vector.
        b : List
            List of ``[x, y, z]`` coordinates for the second vector.
        tol : float
            Linear tolerance. The default value is ``1e-6``.

        Returns
        -------
        bool
            ``True`` if vectors are perpendicular, ``False`` otherwise.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def is_point_projection_in_segment(p, a, b):
        """Check if a point projection lies on the segment defined by two points.

        Parameters
        ----------
        p : List
            List of ``[x, y, z]`` coordinates for the reference point ``p``.
        a : List
            List of ``[x, y, z]`` coordinates for the first point of the segment.
        b : List
            List of ``[x, y, z]`` coordinates for the second point of the segment.

        Returns
        -------
        bool
            ``True`` when the projection point lies on the segment defined by the two points, ``False`` otherwise.

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def point_segment_distance(p, a, b):
        """Calculate the distance between a point ``p`` and a segment defined by two points ``a`` and ``b``.

        Parameters
        ----------
        p : List
            List of ``[x, y, z]`` coordinates for the reference point ``p``.
        a : List
            List of ``[x, y, z]`` coordinates for the first point of the segment.
        b : List
            List of ``[x, y, z]`` coordinates for the second point of the segment.

        Returns
        -------
        float
            Distance between the point and the segment.
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def find_largest_rectangle_inside_polygon(polygon, partition_max_order=...): # -> list[list[Any]]:
        """Find the largest area rectangles of arbitrary orientation in a polygon.

        Implements the algorithm described by Rubén Molano, et al.
        *"Finding the largest area rectangle of arbitrary orientation in a closed contour"*, published in
        *Applied Mathematics and Computation*.
        https://doi.org/10.1016/j.amc.2012.03.063.
        (https://www.sciencedirect.com/science/article/pii/S0096300312003207)

        Parameters
        ----------
        polygon : List
            [[x1, x2, ..., xn],[y1, y2, ..., yn]]
        partition_max_order : float, optional
            Order of the lattice partition used to find the quasi-lattice polygon that approximates ``polygon``.
            Default is ``16``.

        Returns
        -------
        List of List
            List containing the rectangles points. Return all rectangles found.
            List is in the form: [[[x1, y1],[x2, y2],...],[[x1, y1],[x2, y2],...],...].
        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def degrees_over_rounded(angle, digits):
        """Ceil of angle.

        Parameters
        ----------
        angle : float
            Angle in radians which will be converted to degrees and will be over-rounded to the next "digits" decimal.
        digits : int
            Integer number which is the number of decimals.

        Returns
        -------
        float

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def radians_over_rounded(angle, digits):
        """Radian angle ceiling.

        Parameters
        ----------
        angle : float
            Angle in degrees which will be converted to radians and will be over-rounded to the  next "digits" decimal.
        digits : int
            Integer number which is the number of decimals.

        Returns
        -------
        float

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def degrees_default_rounded(angle, digits):
        """Convert angle to degree with given digits rounding.

        Parameters
        ----------
        angle : float
            Angle in radians which will be converted to degrees and will be under-rounded to the next "digits" decimal.
        digits : int
            Integer number which is the number of decimals.

        Returns
        -------
        float

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def radians_default_rounded(angle, digits):
        """Convert to radians with given round.

        Parameters
        ----------
        angle : float
            Angle in degrees which will be converted to radians and will be under-rounded to the next "digits" decimal.
        digits : int
            Integer number which is the number of decimals.

        Returns
        -------
        float

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler()
    def find_closest_points(points_list, reference_point, tol=...): # -> list[Any] | Literal[False]:
        """Given a list of points, finds the closest points to a reference point.
        It returns a list of points because more than one can be found.
        It works with 2D or 3D points. The tolerance used to evaluate the distance
        to the reference point can be specified.

        Parameters
        ----------
        points_list : List of List
            List of points. The points can be defined in 2D or 3D space.
        reference_point : List
            The reference point. The point can be defined in 2D or 3D space (same as points_list).
        tol : float, optional
            The tolerance used to evaluate the distance. Default is ``1e-6``.

        Returns
        -------
        List of List

        """
        ...
    
    @staticmethod
    @pyaedt_function_handler
    def mirror_point(start, reference, vector): # -> list[Any]:
        """Mirror point about a plane defining by a point on the plane and a normal point.

        Parameters
        ----------
        start : list
            Point to be mirrored
        reference : list
            The reference point. Point on the plane around which you want to mirror the object.
        vector : list
            Normalized vector used for the mirroring.

        Returns
        -------
        List
            List of the reflected point.

        """
        ...
    


