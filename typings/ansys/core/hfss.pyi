"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from typing import Union
from ansys.aedt.core.application.analysis_3d import FieldAnalysis3D
from ansys.aedt.core.application.analysis_hf import ScatteringMethods
from ansys.aedt.core.generic.general_methods import pyaedt_function_handler
from ansys.aedt.core.mixins import CreateBoundaryMixin
from ansys.aedt.core.modules.boundary.common import BoundaryObject

"""This module contains the ``Hfss`` class."""
class Hfss(FieldAnalysis3D, ScatteringMethods, CreateBoundaryMixin):
    """Provides the HFSS application interface.

    This class allows you to create an interactive instance of HFSS and
    connect to an existing HFSS design or create a new HFSS design if
    one does not exist.

    Parameters
    ----------
    project : str, optional
        Name of the project to select or the full path to the project
        or AEDTZ archive to open. The default is ``None``, in which
        case an attempt is made to get an active project. If no
        projects are present, an empty project is created.
    design : str, optional
        Name of the design to select. The default is ``None``, in
        which case an attempt is made to get an active design. If no
        designs are present, an empty design is created.
    solution_type : str, optional
        Solution type to apply to the design. The default is
        ``None``, in which case the user-defined
        default type is applied.
        Options are:

        - "Terminal"
        - "Modal"
        - "SBR+"
        - "Transient"
        - "Eigenmode"

    setup : str, optional
        Name of the setup to use as the nominal. The default is
        ``None``, in which case the active setup is used or
        nothing is used.
    version : str, int, float, optional
        Version of AEDT to use. The default is ``None``, in which case
        the active version or latest installed version is used.
        This parameter is ignored when a script is launched within AEDT.
        Examples of input values are ``251``, ``25.1``, ``2025.1``, ``"2025.1"``.
    non_graphical : bool, optional
        Whether to run AEDT in non-graphical mode. The default
        is ``False``, in which case AEDT is launched in graphical mode.
        This parameter is ignored when a script is launched within AEDT.
    new_desktop : bool, optional
        Whether to launch an instance of AEDT in a new thread, even if
        another instance of the ``specified_version`` is active on the
        machine. The default is ``False``. This parameter is ignored when
        a script is launched within AEDT.
    close_on_exit : bool, optional
        Whether to release AEDT on exit. The default is ``False``.
    student_version : bool, optional
        Whether to open the AEDT student version. The default is
        ``False``. This parameter is ignored when a script is launched
        within AEDT.
    machine : str, optional
        Machine name to connect the oDesktop session to. This parameter works only on
        2022 R2 or later. The remote Server must be up and running with the command
        `"ansysedt.exe -grpcsrv portnum"`. If the machine is `"localhost"`, the server
        starts if it is not present.
    port : int, optional
        Port number on which to start the oDesktop communication on an already existing server.
        This parameter is ignored when creating a new server. It works only in 2022 R2 or later.
        The remote server must be up and running with the command `"ansysedt.exe -grpcsrv portnum"`.
    aedt_process_id : int, optional
        Process ID for the instance of AEDT to point PyAEDT at. The default is
        ``None``. This parameter is only used when ``new_desktop = False``.
    remove_lock : bool, optional
        Whether to remove lock to project before opening it or not.
        The default is ``False``, which means to not unlock
        the existing project if needed and raise an exception.

    Examples
    --------
    Create an instance of HFSS and connect to an existing HFSS
    design or create a new HFSS design if one does not exist.

    >>> from ansys.aedt.core import Hfss
    >>> hfss = Hfss()
    PyAEDT INFO: No project is defined...
    PyAEDT INFO: Active design is set to...


    Create an instance of HFSS and link to a project named
    ``HfssProject``. If this project does not exist, create one with
    this name.

    >>> hfss = Hfss("HfssProject")
    PyAEDT INFO: Project HfssProject has been created.
    PyAEDT INFO: No design is present. Inserting a new design.
    PyAEDT INFO: Added design ...


    Create an instance of HFSS and link to a design named
    ``HfssDesign1`` in a project named ``HfssProject``.

    >>> hfss = Hfss("HfssProject", "HfssDesign1")
    PyAEDT INFO: Added design 'HfssDesign1' of type HFSS.


    Create an instance of HFSS and open the specified project,
    which is named ``"myfile.aedt"``.

    >>> hfss = Hfss("myfile.aedt")
    PyAEDT INFO: Project myfile has been created.
    PyAEDT INFO: No design is present. Inserting a new design.
    PyAEDT INFO: Added design...


    Create an instance of HFSS using the 2025 R1 release and open
    the specified project, which is named ``"myfile2.aedt"``.

    >>> hfss = Hfss(version=251, project="myfile2.aedt")
    PyAEDT INFO: Project myfile2 has been created.
    PyAEDT INFO: No design is present. Inserting a new design.
    PyAEDT INFO: Added design...


    Create an instance of HFSS using the 2025 R1 student version and open
    the specified project, which is named ``"myfile3.aedt"``.

    >>> hfss = Hfss(version="251", project="myfile3.aedt", student_version=True)
    PyAEDT INFO: Project myfile3 has been created.
    PyAEDT INFO: No design is present. Inserting a new design.
    PyAEDT INFO: Added design...

    """
    @pyaedt_function_handler(designname="design", projectname="project", specified_version="version", setup_name="setup", new_desktop_session="new_desktop")
    def __init__(self, project=..., design=..., solution_type=..., setup=..., version=..., non_graphical=..., new_desktop=..., close_on_exit=..., student_version=..., machine=..., port=..., aedt_process_id=..., remove_lock=...) -> None:
        ...
    
    @property
    def field_setups(self): # -> list[Any]:
        """List of AEDT radiation fields.

        Returns
        -------
        List of :class:`ansys.aedt.core.modules.boundary.hfss_boundary.FarFieldSetup` and
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @property
    def field_setup_names(self):
        """List of AEDT radiation field names.

        Returns
        -------
        List of str
        """
        ...
    
    class BoundaryType(CreateBoundaryMixin):
        """Creates and manages boundaries."""
        ...
    
    
    @property
    def hybrid(self): # -> bool:
        """HFSS hybrid mode for the active solution.

        For instance, it must be set to ``True`` to define the solution type as 'HFSS with Hybrid and Arrays'.

        Returns
        -------
        bool
        """
        ...
    
    @hybrid.setter
    def hybrid(self, value): # -> None:
        ...
    
    @property
    def composite(self): # -> bool:
        """HFSS composite mode for the active solution.

        Returns
        -------
        bool
        """
        ...
    
    @composite.setter
    def composite(self, value): # -> None:
        ...
    
    @property
    def table_names(self): # -> list[Any]:
        """Imported table names.

        Returns
        -------
        list of str
            List of names of all imported tables in the design.

        References
        ----------
        >>> oModule.GetValidISolutionList
        """
        ...
    
    @pyaedt_function_handler(boundary_type="opening_type")
    def set_auto_open(self, enable=..., opening_type=...): # -> bool:
        """Set the HFSS auto open type.

        Parameters
        ----------
        enable : bool, optional
            Whether to enable the HFSS auto open option. The default is ``True``.
        opening_type : str, optional
            Boundary type to use with auto open. Options are ``"Radiation"``,
            ``"FEBI"``, and ``"PML"``. The default is ``"Radiation"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        Examples
        --------
        Enable auto open type for the PML boundary.

        >>> hfss.set_auto_open(True, "PML")
        """
        ...
    
    @pyaedt_function_handler(obj="assignment", mat="material", cond="conductivity", perm="permittivity", usethickness="use_thickness", isinfgnd="is_infinite_ground", istwoside="is_two_side", isInternal="is_internal", issheelElement="is_shell_element", usehuray="use_huray")
    def assign_coating(self, assignment, material=..., conductivity=..., permittivity=..., use_thickness=..., thickness=..., roughness=..., is_infinite_ground=..., is_two_side=..., is_internal=..., is_shell_element=..., use_huray=..., radius=..., ratio=..., name=...): # -> BoundaryObject:
        """Assign finite conductivity to one or more objects or faces of a given material.

        .. deprecated:: 0.15.3
            Use assign_finite_conductivity method instead.

        Parameters
        ----------
        assignment : str or list
            One or more objects or faces to assign finite conductivity to.
        material : str, optional
            Material to use. The default is ``None``.
        conductivity : float, optional
            Conductivity. The default is ``58000000``.
            If no material is provided, a value must be supplied.
        permittivity : float, optional
            Permittivity. The default is ``1``. If no
            material is provided, a value must be supplied.
        use_thickness : bool, optional
            Whether to use thickness. The default is ``False``.
        thickness : str, optional
            Thickness value if ``usethickness=True``. The default is ``"0.1mm"``.
        roughness : str, optional
            Roughness value  with units. The default is ``"0um"``.
        is_infinite_ground : bool, optional
            Whether the finite conductivity is an infinite ground. The default is ``False``.
        is_two_side : bool, optional
            Whether the finite conductivity is two-sided. The default is ``False``.
        is_internal : bool, optional
            Whether the finite conductivity is internal. The default is ``True``.
        is_shell_element : bool, optional
            Whether the finite conductivity is a shell element.
            The default is ``False``.
        use_huray : bool, optional
            Whether to use a Huray coefficient. The default is ``False``.
        radius : str, optional
            Radius value if ``usehuray=True``. The default is ``"0.5um"``.
        ratio : str, optional
            Ratio value if ``usehuray=True``. The default is ``"2.9"``.
        name : str
            Name of the boundary.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignFiniteCond

        Examples
        --------

        Create two cylinders in the XY working plane and assign a copper coating of 0.2 mm to the inner cylinder and
        outer face.

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> origin = hfss.modeler.Position(0, 0, 0)
        >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
        >>> outer = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 4, 200, 0, "outer")
        >>> coat = hfss.assign_finite_conductivity(
        ...     ["inner", outer.faces[2].id], "copper", use_thickness=True, thickness="0.2mm"
        ... )

        """
        ...
    
    @pyaedt_function_handler()
    def assign_finite_conductivity(self, assignment, material=..., conductivity=..., permittivity=..., use_thickness=..., thickness=..., roughness=..., is_infinite_ground=..., is_two_side=..., is_internal=..., is_shell_element=..., use_huray=..., radius=..., ratio=..., height_deviation=..., name=...): # -> BoundaryObject:
        """Assign finite conductivity to one or more objects or faces of a given material.

        Parameters
        ----------
        assignment : str or list
            One or more objects or faces to assign finite conductivity to.
        material : str, optional
            Material to use. The default is ``None``.
        conductivity : float, optional
            Conductivity. The default is ``58000000``.
            If no material is provided, a value must be supplied.
        permittivity : float, optional
            Permittivity. The default is ``1``. If no
            material is provided, a value must be supplied.
        use_thickness : bool, optional
            Whether to use thickness. The default is ``False``.
        thickness : str, optional
            Thickness value if ``usethickness=True``. The default is ``"0.1mm"``.
        roughness : int, float or str, optional
            Roughness value with units. The default is ``"0um"``.
        is_infinite_ground : bool, optional
            Whether the finite conductivity is an infinite ground. The default is ``False``.
        is_two_side : bool, optional
            Whether the finite conductivity is two-sided. The default is ``False``.
        is_internal : bool, optional
            Whether the finite conductivity is internal. The default is ``True``.
        is_shell_element : bool, optional
            Whether the finite conductivity is a shell element.
            The default is ``False``.
        use_huray : bool, optional
            Whether to use a Huray coefficient. The default is ``False``.
        radius : str, optional
            Radius value if ``usehuray=True``. The default is ``"0.5um"``.
        ratio : str, optional
            Ratio value if ``usehuray=True``. The default is ``"2.9"``.
        height_deviation : float, int or str, optional
            Height standard deviation. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        name : str
            Name of the boundary.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignFiniteCond

        Examples
        --------

        Create two cylinders in the XY working plane and assign a copper coating of 0.2 mm to the inner cylinder and
        outer face.

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> origin = hfss.modeler.Position(0, 0, 0)
        >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
        >>> outer = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 4, 200, 0, "outer")
        >>> coat = hfss.assign_finite_conductivity(
        ...     ["inner", outer.faces[2].id], "copper", use_thickness=True, thickness="0.2mm"
        ... )

        """
        ...
    
    @pyaedt_function_handler()
    def assign_perfect_e(self, assignment, is_infinite_ground=..., height_deviation=..., roughness=..., name=...): # -> BoundaryObject:
        """Assign perfect electric boundary to one or more objects or faces.

        Parameters
        ----------
        assignment : str or list
            One or more objects or faces to assign finite conductivity to.
        is_infinite_ground : bool, optional
            Whether the boundary is an infinite ground. The default is ``False``.
        height_deviation : float, int or str, optional
            Surface height standard deviation. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        roughness : float, optional
            Surface roughness. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        name : str, optional
            Name of the boundary. . The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.PerfectE

        Examples
        --------

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> origin = hfss.modeler.Position(0, 0, 0)
        >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
        >>> coat = hfss.assign_perfect_e(["inner", outer.faces[2].id])
        """
        ...
    
    @pyaedt_function_handler()
    def assign_perfect_h(self, assignment, height_deviation=..., roughness=..., name=...): # -> BoundaryObject:
        """Assign perfect magnetic boundary to one or more objects or faces.

        Parameters
        ----------
        assignment : str or list
            One or more objects or faces to assign finite conductivity to.
        height_deviation : float, int or str, optional
            Surface height standard deviation. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        roughness : float, optional
            Surface roughness. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        name : str, optional
            Name of the boundary. . The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.PerfectH

        Examples
        --------

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> origin = hfss.modeler.Position(0, 0, 0)
        >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
        >>> coat = hfss.assign_perfect_h(["inner", outer.faces[2].id])
        """
        ...
    
    @pyaedt_function_handler()
    def assign_layered_impedance(self, assignment, is_two_side=..., material=..., thickness=..., is_infinite_ground=..., is_shell_element=..., roughness=..., height_deviation=..., name=...): # -> BoundaryObject:
        """Assign finite conductivity to one or more objects or faces of a given material.

        Parameters
        ----------
        assignment : str or list
            One or more objects or faces to assign finite conductivity to.
        is_two_side : bool, optional
            Whether the finite conductivity is two-sided. The default is ``False``.
        material : list or str, optional
            Material of each layer. The default is ``None``.
        thickness : float, optional
            Thickness of each layer. The default is ``None``.
        roughness : int, float or str, optional
            Roughness value with units. The default is ``"0um"``.
        is_infinite_ground : bool, optional
            Whether the finite conductivity is an infinite ground. The default is ``False``.
        is_shell_element : bool, optional
            Whether the finite conductivity is a shell element.
            The default is ``False``.
        height_deviation : float, int or str, optional
            Height standard deviation. This parameter is only valid in SBR+ designs. The default is ``0.0``.
        name : str
            Name of the boundary.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignFiniteCond

        Examples
        --------

        Create two cylinders in the XY working plane and assign a copper coating of 0.2 mm to the inner cylinder and
        outer face.

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> origin = hfss.modeler.Position(0, 0, 0)
        >>> inner = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 3, 200, 0, "inner")
        >>> outer = hfss.modeler.create_cylinder(hfss.PLANE.XY, origin, 4, 200, 0, "outer")
        >>> coat = hfss.assign_finite_conductivity(
        ...     ["inner", outer.faces[2].id], "copper", use_thickness=True, thickness="0.2mm"
        ... )

        """
        ...
    
    @pyaedt_function_handler(startobj="assignment", endobj="reference", sourcename="name", is_infinite_gnd="is_infinite_ground", bound_on_plane="is_boundary_on_plane", axisdir="start_direction")
    def create_perfecte_from_objects(self, assignment, reference, start_direction=..., name=..., is_infinite_ground=..., is_boundary_on_plane=...): # -> BoundaryObject:
        """Create a Perfect E taking the closest edges of two objects.

        Parameters
        ----------
        assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Starting object for the integration line.
        reference :  str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
           Ending object for the integration line.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the boundary location. It should be one of the values for
            ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.  The default
            is ``Application.AxisDir.XNeg``.
        name : str, optional
            Perfect E name. The default is ``None``, in which
            case a name is automatically assigned.
        is_infinite_ground : bool, optional
            Whether the Perfect E is an infinite ground. The default is ``False``.
        is_boundary_on_plane : bool, optional
            Whether to create the Perfect E on the plane orthogonal to
            the axis direction. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject` or bool
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignPerfectE

        Examples
        --------

        Create two boxes for creating a Perfect E named ``'PerfectE'``.

        >>> box1 = hfss.modeler.create_box([0, 0, 0], [10, 10, 5], "perfect1", "Copper")
        >>> box2 = hfss.modeler.create_box([0, 0, 10], [10, 10, 5], "perfect2", "copper")
        >>> perfect_e = hfss.create_perfecte_from_objects("perfect1", "perfect2", hfss.AxisDir.ZNeg, "PerfectE")
        PyAEDT INFO: Connection Correctly created
        >>> type(perfect_e)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(startobj="assignment", endobject="reference", sourcename="name", bound_on_plane="is_boundary_on_plane", axisdir="start_direction")
    def create_perfecth_from_objects(self, assignment, reference, start_direction=..., name=..., is_boundary_on_plane=...): # -> BoundaryObject:
        """Create a Perfect H taking the closest edges of two objects.

        Parameters
        ----------
        assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Starting object for the integration line.
        reference : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Ending object for the integration line.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the boundary location. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Perfect H name. The default is ``None``,
             in which case a name is automatically assigned.
        is_boundary_on_plane : bool, optional
            Whether to create the Perfect H on the plane
            orthogonal to the axis direction. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject` or bool
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignPerfectH

        Examples
        --------

        Create two boxes for creating a Perfect H named ``'PerfectH'``.

        >>> box1 = hfss.modeler.create_box([0, 0, 20], [10, 10, 5], "perfect1", "Copper")
        >>> box2 = hfss.modeler.create_box([0, 0, 30], [10, 10, 5], "perfect2", "copper")
        >>> perfect_h = hfss.create_perfecth_from_objects("perfect1", "perfect2", hfss.AxisDir.ZNeg, "Perfect H")
        PyAEDT INFO: Connection Correctly created
        >>> type(perfect_h)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(sheet_list="assignment", sourcename="name", is_infinite_gnd="is_infinite_ground")
    def assign_perfecte_to_sheets(self, assignment, name=..., is_infinite_ground=...): # -> BoundaryObject:
        """Create a Perfect E taking one sheet.

        Parameters
        ----------
        assignment : str or list
            One or more names of the sheets to apply the boundary to.
        name : str, optional
            Name of the Perfect E source. The default is ``None``.
        is_infinite_ground : bool, optional
            Whether the Perfect E is an infinite ground. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignPerfectE

        Examples
        --------

        Create a sheet and use it to create a Perfect E.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -90], [10, 2], name="PerfectESheet", material="Copper"
        ... )
        >>> perfect_e_from_sheet = hfss.assign_perfecte_to_sheets(sheet.name, "PerfectEFromSheet")
        >>> type(perfect_e_from_sheet)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(sheet_list="assignment", sourcename="name")
    def assign_perfecth_to_sheets(self, assignment, name=...): # -> BoundaryObject:
        """Assign a Perfect H to sheets.

        Parameters
        ----------
        assignment : list
            List of sheets to apply the boundary to.
        name : str, optional
            Perfect H name. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignPerfectH

        Examples
        --------

        Create a sheet and use it to create a Perfect H.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -90], [10, 2], name="PerfectHSheet", material="Copper"
        ... )
        >>> perfect_h_from_sheet = hfss.assign_perfecth_to_sheets(sheet.name, "PerfectHFromSheet")
        >>> type(perfect_h_from_sheet)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(startobj="start_assignment", endobject="end_assignment", axisdir="start_direction", sourcename="source_name", is_infground="is_infinite_ground")
    def create_impedance_between_objects(self, start_assignment, end_assignment, start_direction=..., source_name=..., resistance=..., reactance=..., is_infinite_ground=..., bound_on_plane=...): # -> BoundaryObject:
        """Create an impedance taking the closest edges of two objects.

        Parameters
        ----------
        start_assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Starting object for the integration line.
        end_assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Ending object for the integration line.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the boundary location. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        source_name : str, optional
            Name of the impedance. The default is ``None``.
        resistance : float, optional
            Resistance value in ohms. The default is ``50``. If ``None``,
            this parameter is disabled.
        reactance : optional
            Reactance value in ohms. The default is ``0``. If ``None``,
            this parameter is disabled.
        is_infinite_ground : bool, optional
            Whether the impendance is an infinite ground. The default is ``False``.
        bound_on_plane : bool, optional
            Whether to create the impedance on the plane orthogonal to ``AxisDir``.
            The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject` or bool
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignImpedance

        Examples
        --------

        Create two boxes for creating an impedance named ``'ImpedanceExample'``.

        >>> box1 = hfss.modeler.create_box([0, 0, 70], [10, 10, 5], "box1", "copper")
        >>> box2 = hfss.modeler.create_box([0, 0, 80], [10, 10, 5], "box2", "copper")
        >>> impedance = hfss.create_impedance_between_objects(
        ...     "box1", "box2", hfss.AxisDir.XPos, "ImpedanceExample", 100, 50
        ... )
        PyAEDT INFO: Connection Correctly created

        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", boundary_name="name", is_inifinite_gnd="is_inifinite_ground")
    def create_boundary(self, boundary_type=..., assignment=..., name=..., is_inifinite_ground=...): # -> BoundaryObject | None:
        """Assign a boundary condition to a sheet or surface.

        This method is generally used by other methods in the ``Hfss`` class such as the
        :meth:``Hfss.assign_febi`` or :meth:``Hfss.assign_radiation_boundary_to_faces`` method.

        Parameters
        ----------
        boundary_type : int, optional
            Type of boundary condition to assign to a sheet or surface. The
            default is ``Hfss.BoundaryType.PerfectE``. Options are the properties of the
            :class:``Hfss.BoundaryType`` class. For example:

                - ``Hfss.BoundaryType.PerfectE``
                - ``Hfss.BoundaryType.PerfectH``
                - ``Hfss.BoundaryType.Radiation``
                - ``Hfss.BoundaryType.Impedance``
                - ``Hfss.BoundaryType.LumpedRLC``
                - ``Hfss.BoundaryType.FEBI``

        assignment : int, str, or list, optional
            Name of the sheet or face to assign the boundary condition to. The
            default is ``None``. You can provide an integer (face ID), a string (sheet),
            or a list of integers and strings.
        name : str, optional
            Name of the boundary. The default is ``None``.
        is_inifinite_ground : bool, optional
            Whether the boundary is an infinite ground. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        """
        ...
    
    @pyaedt_function_handler(obh_names="assignment", boundary_name="name")
    def assign_radiation_boundary_to_objects(self, assignment, name=...): # -> BoundaryObject | None:
        """Assign a radiation boundary to one or more objects (usually airbox objects).

        Parameters
        ----------
        assignment : str or list or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            One or more object names or IDs.
        name : str, optional
            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignRadiation

        Examples
        --------

        Create a box and assign a radiation boundary to it.

        >>> radiation_box = hfss.modeler.create_box([0, -200, -200], [200, 200, 200], name="Radiation_box")
        >>> radiation = hfss.assign_radiation_boundary_to_objects("Radiation_box")
        >>> type(radiation)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(obj_names="assignment", boundary_name="name")
    def assign_hybrid_region(self, assignment, name=..., hybrid_region=...): # -> BoundaryObject | None:
        """Assign a hybrid region to one or more objects.

        Parameters
        ----------
        assignment : str or list or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            One or more object names or IDs.
        name : str, optional
            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.
        hybrid_region : str, optional
            Hybrid region to assign. The default is `"SBR+"``. Options are ``"IE"``, ``"PO"``
            and ``"SBR+"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignHybridRegion

        Examples
        --------

        Create a box and assign a hybrid boundary to it.

        >>> box = hfss.modeler.create_box([0, -200, -200], [200, 200, 200], name="Radiation_box")
        >>> sbr_box = hfss.assign_hybrid_region("Radiation_box")
        >>> type(sbr_box)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(obj_names="assignment", boundary_name="name")
    def assign_febi(self, assignment, name=...): # -> BoundaryObject | None:
        """Assign an FE-BI region to one or more objects.

        Parameters
        ----------
        assignment : str or list or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            One or more object names or IDs.
        name : str, optional
            Name of the boundary. The default is ``None``, in which case a name is automatically assigned.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignFEBI

        Examples
        --------

        Create a box and assign an FE-BI boundary to it.

        >>> box = hfss.modeler.create_box([0, -200, -200], [200, 200, 200], name="Radiation_box")
        >>> febi_box = hfss.assign_febi("Radiation_box")
        >>> type(febi_box)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(faces_id="assignment", boundary_name="name")
    def assign_radiation_boundary_to_faces(self, assignment, name=...): # -> BoundaryObject | None:
        """Assign a radiation boundary to one or more faces.

        Parameters
        ----------
        assignment :
            Face ID to assign the boundary condition to.
        name : str, optional
            Name of the boundary. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignRadiation

        Examples
        --------

        Create a box. Select the faces of this box and assign a radiation
        boundary to them.

        >>> radiation_box = hfss.modeler.create_box([0, -100, 0], [200, 200, 200], name="RadiationForFaces")
        >>> ids = [i.id for i in hfss.modeler["RadiationForFaces"].faces]
        >>> radiation = hfss.assign_radiation_boundary_to_faces(ids)
        >>> type(radiation)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler(setupname="name", setuptype="setup_type")
    def create_setup(self, name=..., setup_type=..., **kwargs): # -> SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS:
        """Create an analysis setup for HFSS.

        Optional arguments are passed along with ``setup_type`` and ``name``. Keyword
        names correspond to keyword for the ``setup_type`` as defined in
        the native AEDT API.

        .. note::
           This method overrides the ``Analysis.setup()`` method for the HFSS app.

        Parameters
        ----------
        name : str, optional
            Name of the setup. The default is ``"Setup1"``.
        setup_type : str, optional
            Type of the setup, which is based on the solution type. Options are
            ``"HFSSDrivenAuto"``, ``"HFSSDriven"``, ``"HFSSEigen"``, ``"HFSSTransient"``,
            and ``"HFSSSBR"``. The default is ``"HFSSDriven"``.
        **kwargs : dict, optional
            Keyword arguments from the native AEDT API.
            For more information, see
            :doc:`../SetupTemplatesHFSS`.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_setup.SetupHFSS`,
        :class:`ansys.aedt.core.modules.solve_setup.SetupHFSSAuto`
            3D Solver Setup object.

        References
        ----------
        >>> oModule.InsertSetup

        Examples
        --------

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> hfss.create_setup(name="Setup1", setup_type="HFSSDriven", Frequency="10GHz")

        """
        ...
    
    @pyaedt_function_handler(setupname="setup", unit="units", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name")
    def create_linear_count_sweep(self, setup, units, start_frequency, stop_frequency, num_of_freq_points=..., name=..., save_fields=..., save_rad_fields=..., sweep_type=..., interpolation_tol=..., interpolation_max_solutions=...): # -> Literal[False]:
        """Create a sweep with a specified number of points.

        Parameters
        ----------
        setup : str
            Name of the setup.
        units : str
            Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
        start_frequency : float
            Starting frequency of the sweep, such as ``1``.
        stop_frequency : float
            Stopping frequency of the sweep.
        num_of_freq_points : int
            Number of frequency points in the range.
            The default is ``401`` for ``sweep_type = "Interpolating"``. The defaults
            are "Fast"`` and ``5`` for ``sweep_type = ""Discrete"``.
        name : str, optional
            Name of the sweep. The default is ``None``, in which
            case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save the fields. The default is ``True``.
        save_rad_fields : bool, optional
            Whether to save the radiating fields. The default is ``False``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Fast"``, ``"Interpolating"``,
            and ``"Discrete"``. The default is ``"Discrete"``.
        interpolation_tol : float, optional
            Error tolerance threshold for the interpolation process. The default
            is ``0.5``.
        interpolation_max_solutions : int, optional
            Maximum number of solutions evaluated for the interpolation process.
            The default is ``250``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearCountSetup"`` and use it in a linear count sweep
        named ``"LinearCountSweep"``.

        >>> setup = hfss.create_setup("LinearCountSetup")
        >>> linear_count_sweep = hfss.create_linear_count_sweep(
        ...     setup="LinearCountSetup",
        ...     sweep="LinearCountSweep",
        ...     units="MHz",
        ...     start_frequency=1.1e3,
        ...     stop_frequency=1200.1,
        ...     num_of_freq_points=1658,
        ... )
        >>> type(linear_count_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    @pyaedt_function_handler(setup_name="setup", setupname="setup", freqstart="start_frequency", freqstop="stop_frequency", sweepname="name", sweep_name="name")
    def create_linear_step_sweep(self, setup, unit, start_frequency, stop_frequency, step_size, name=..., save_fields=..., save_rad_fields=..., sweep_type=...): # -> Literal[False]:
        """Create a sweep with a specified frequency step.

        Parameters
        ----------
        setup : str
            Name of the setup.
        unit : str
            Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
        start_frequency : float
            Starting frequency of the sweep.
        stop_frequency : float
            Stopping frequency of the sweep.
        step_size : float
            Frequency size of the step.
        name : str, optional
            Name of the sweep. The default is ``None``, in
            which case a name is automatically assigned.
        save_fields : bool, optional
            Whether to save fields. The default is ``True``.
        save_rad_fields : bool, optional
            Whether to save radiating fields. The default is ``False``.
        sweep_type : str, optional
            Type of the sweep. Options are ``"Discrete"``,``"Interpolating"`` and
            ``"Fast"``. The default is ``"Discrete"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearStepSetup"`` and use it in a linear step sweep
        named ``"LinearStepSweep"``.

        >>> setup = hfss.create_setup("LinearStepSetup")
        >>> linear_step_sweep = hfss.create_linear_step_sweep(
        ...     setup="LinearStepSetup", unit="MHz", start_frequency=1.1e3, stop_frequency=1200.1, step_size=153.8
        ... )
        >>> type(linear_step_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    @pyaedt_function_handler(setupname="setup", sweepname="name")
    def create_single_point_sweep(self, setup, unit, freq, name=..., save_single_field=..., save_fields=..., save_rad_fields=...): # -> Literal[False]:
        """Create a sweep with a single frequency point.

        Parameters
        ----------
        setup : str
            Name of the setup.
        unit : str
            Unit of the frequency. For example, ``"MHz"`` or ``"GHz"``.
        freq : float, list
            Frequency of the single point or list of frequencies to create distinct single points.
        name : str, optional
            Name of the sweep. The default is ``None``, in
            which case a name is automatically assigned.
        save_single_field : bool, list, optional
            Whether to save the fields of the single point. The default is ``True``.
            If a list is specified, the length must be the same as the list of frequencies.
        save_fields : bool, optional
            Whether to save fields for all points and subranges defined in the sweep.
            The default is ``False``.
        save_rad_fields : bool, optional
            Whether to save only radiating fields. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.solve_sweeps.SweepHFSS` or bool
            Sweep object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.InsertFrequencySweep

        Examples
        --------

        Create a setup named ``"LinearStepSetup"`` and use it in a single point sweep
        named ``"SinglePointSweep"``.

        >>> setup = hfss.create_setup("LinearStepSetup")
        >>> single_point_sweep = hfss.create_single_point_sweep(setup="LinearStepSetup", unit="MHz", freq=1.1e3)
        >>> type(single_point_sweep)
        <class 'from ansys.aedt.core.modules.setup_templates.SweepHFSS'>

        """
        ...
    
    class SbrAntennas:
        ...
    
    
    class SBRAntennaDefaults:
        _conical = ...
        _cross = ...
        _dipole = ...
        _horizontal = ...
        _parametricbeam = ...
        _slot = ...
        _horn = ...
        _smallloop = ...
        _wiredipole = ...
        parameters = ...
        default_type_id = ...
        array_parameters = ...
    
    
    @pyaedt_function_handler(model_units="units", parameters_dict="parameters", antenna_name="name")
    def create_sbr_antenna(self, antenna_type=..., target_cs=..., units=..., parameters=..., use_current_source_representation=..., is_array=..., custom_array=..., name=...): # -> NativeComponentObject:
        """Create a parametric beam antennas in SBR+.

        Parameters
        ----------
        antenna_type : str, `SbrAntennas.ConicalHorn`
            Name of the antennas type. The enumerator ``SbrAntennas`` can also be used.
            The default is ``"SbrAntennas.Conical Horn"``.
        target_cs : str, optional
            Target coordinate system. The default is ``None``, in which case
            the active coodiante system is used.
        units : str, optional
            Model units to apply to the object. The default is
            ``None``, in which case the active modeler units are applied.
        parameters : dict, optional
            Dictionary of parameters. The default is ``None``.
        use_current_source_representation : bool, optional
            Whether to use the current source representation. The default is ``False``.
        is_array : bool, optional
            Whether to define a parametric array. The default is ``False``.
        custom_array : str, optional
            Custom array file. The extensions supported are ``".sarr"``. The default is ``None``, in which case
            parametric array is created.
        name : str, optional
            Name of the 3D component. The default is ``None``, in which case the
            name is auto-generated based on the antenna type.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.NativeComponentObject`
            NativeComponentObject object.

        References
        ----------
        >>> oEditor.InsertNativeComponent

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss(solution_type="SBR+")
        >>> parm = {"Polarization": "Vertical"}
        >>> par_beam = hfss.create_sbr_antenna(hfss.SbrAntennas.ShortDipole, parameters=parm, name="TX1")
        >>> custom_array = "my_file.sarr"
        >>> antenna_array = hfss.create_sbr_antenna(hfss.SbrAntennas.ShortDipole, custom_array=custom_array)
        >>> antenna_array_parametric = hfss.create_sbr_antenna(hfss.SbrAntennas.ShortDipole, is_array=True)

        """
        ...
    
    @pyaedt_function_handler(ffd_full_path="far_field_data", model_units="units", antenna_name="name")
    def create_sbr_file_based_antenna(self, far_field_data, antenna_size=..., antenna_impedance=..., representation_type=..., target_cs=..., units=..., is_array=..., custom_array=..., name=...): # -> NativeComponentObject:
        """Create a linked antenna.

        Parameters
        ----------
        far_field_data : str
            Full path to the FFD file.
        antenna_size : str, optional
            Antenna size with units. The default is ``"1mm"``.
        antenna_impedance : str, optional
            Antenna impedance with units. The default is ``"50ohm"``.
        representation_type : str, optional
            Type of the antennas. Options are ``"Far Field"`` and ``"Near Field"``.
            The default is ``"Far Field"``.
        target_cs : str, optional
            Target coordinate system. The default is ``None``, in which case the
            active coordinate system is used.
        units : str, optional
            Model units to apply to the object. The default is
            ``None``, in which case the active modeler units are applied.
        is_array : bool, optional
            Whether to define a parametric array. The default is ``False``.
        custom_array : str, optional
            Custom array file. The extensions supported are ``".sarr"``. The default is ``None``, in which case
            parametric array is created.
        name : str, optional
            Name of the 3D component. The default is ``None``, in which case
            the name is auto-generated based on the antenna type.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.layout_boundary.NativeComponentObject`

        References
        ----------
        >>> oEditor.InsertNativeComponent

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss(solution_type="SBR+")  # doctest: +SKIP
        >>> ffd_file = "full_path/to/ffdfile.ffd"
        >>> par_beam = hfss.create_sbr_file_based_antenna(ffd_file)  # doctest: +SKIP

        """
        ...
    
    @pyaedt_function_handler(source_object="assignment", solution="setup", fieldtype="field_type", source_name="name")
    def create_sbr_linked_antenna(self, assignment, target_cs=..., setup=..., field_type=..., use_composite_ports=..., use_global_current=..., current_conformance=..., thin_sources=..., power_fraction=..., visible=..., is_array=..., custom_array=..., name=...): # -> NativeComponentObject:
        """Create a linked antennas.

        Parameters
        ----------
        assignment : ansys.aedt.core.Hfss
            Source object.
        target_cs : str, optional
            Target coordinate system. The default is ``"Global"``.
        setup : optional
            Name of the setup. The default is ``None``, in which
            case a name is automatically assigned.
        field_type : str, optional
            Field type. The options are ``"nearfield"`` and ``"farfield"``.
            The default is ``"nearfield"``.
        use_composite_ports : bool, optional
            Whether to use composite ports. The default is ``False``.
        use_global_current : bool, optional
            Whether to use the global current. The default is ``True``.
        current_conformance : bool, optional
            Whether to enable current conformance. The default is ``False``.
        thin_sources : bool, optional
             Whether to enable thin sources. The default is ``True``.
        power_fraction : str, optional
             The default is ``"0.95"``.
        visible : bool, optional.
            Whether to make source objects in the target design visible. The default is ``True``.
        is_array : bool, optional
            Whether to define a parametric array. The default is ``False``.
        custom_array : str, optional
            Custom array file. The extensions supported are ``".sarr"``. The default is ``None``, in which case
            parametric array is created.
        name : str, optional
            Name of the source.
            The default is ``None`` in which case a name is automatically assigned.

        References
        ----------
        >>> oEditor.InsertNativeComponent

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> target_project = "my/path/to/targetProject.aedt"
        >>> source_project = "my/path/to/sourceProject.aedt"
        >>> target = Hfss(project=target_project, solution_type="SBR+", version="2025.1", new_desktop=False)
        >>> source = Hfss(project=source_project, design="feeder", version="2025.1", new_desktop=False)
        >>> target.create_sbr_linked_antenna(
        ...     source, target_cs="feederPosition", field_type="farfield"
        ... )  # doctest: +SKIP

        """
        ...
    
    @pyaedt_function_handler()
    def create_sbr_custom_array_file(self, output_file=..., frequencies=..., element_number=..., state_number=..., position=..., x_axis=..., y_axis=..., weight=...): # -> Path:
        """Create custom array file with sarr format.

        Parameters
        ----------
        output_file : str, optional
            Full path and name for the file.
            The default is ``None``, in which case the file is exported to the working directory.
        frequencies : list, optional
            List of frequencies in GHz. The default is ``[1.0]``.
        element_number : int, optional
            Number of elements in the array. The default is ``1``.
        state_number : int, optional
            Number of states. The default is ``1``.
        position : list of list
            List of the ``[x, y, z]`` coordinates for each element. The default is ``[1, 0, 0]``.
        x_axis : list of list
            List of X, Y, Z components of X-axis unit vector.
        y_axis : list of list
            List of X, Y, Z components of Y-axis unit vector. The default is ``[0, 1, 0]``.
        weight : list of list
            Weight of each element. The default is ``None`` in which case all elements have uniform weight.
            The second dimension contains the weights for each element, organized as follows:
            The first ``frequencies`` entries correspond to the weights for that element at each
            of the ``frequencies``, for the first state.
            If there are multiple states, the next ``frequencies`` entries represent the weights for the second state,
            and so on.
            For example, for 3 frequencies ``(f1, f2, f3)``, 2 elements ``(e1, e2)``, and 2 states ``(s1, s2)``,
            the weight would be represented as: ``[[w_f1_e1_s1, w_f1_e2_s1], [w_f2_e1_s1, w_f2_e2_s1],
            [w_f3_e1_s1, w_f3_e2_s1], [w_f1_e1_s2, w_f1_e2_s2], [w_f2_e1_s2, w_f2_e2_s2], [w_f3_e1_s2, w_f3_e2_s2]]``.
            ```

        Returns
        -------
        str
            File name when successful, ``False`` when failed.

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> hfss.create_sbr_custom_array_file()
        >>> hfss.release_desktop()
        """
        ...
    
    @pyaedt_function_handler()
    def set_sbr_txrx_settings(self, txrx_settings): # -> BoundaryObject:
        """Set SBR+ TX RX antennas settings.

        Parameters
        ----------
        txrx_settings : dict
            Dictionary containing the TX as key and RX as values.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.SetSBRTxRxSettings
        """
        ...
    
    @pyaedt_function_handler(start_object="assignment", end_object="reference", port_width="width")
    def create_spiral_lumped_port(self, assignment, reference, width=..., name=...): # -> BoundaryObject:
        """Create a spiral lumped port between two adjacent objects.

        The two objects must have two adjacent, parallel, and identical faces.
        The faces must be a polygon (not a circle).
        The closest faces must be aligned with the main planes of the reference system.

        Parameters
        ----------
        assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            First solid connected to the spiral port.
        reference : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Second object connected to the spiral port.
        width : float, optional
            Width of the spiral port.
            If a width is not specified, it is calculated based on the object dimensions.
            The default is ``None``.
        name : str, optional
            Port name.  The default is ``None``.


        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        Examples
        --------
        >>> aedtapp = Hfss()
        >>> aedtapp.insert_design("Design_Terminal_2")
        >>> aedtapp.solution_type = "Terminal"
        >>> box1 = aedtapp.modeler.create_box([-100, -100, 0], [200, 200, 5], name="gnd2z", material="copper")
        >>> box2 = aedtapp.modeler.create_box([-100, -100, 20], [200, 200, 25], name="sig2z", material="copper")
        >>> aedtapp.modeler.fit_all()
        >>> portz = aedtapp.create_spiral_lumped_port(box1, box2)
        """
        ...
    
    @pyaedt_function_handler(startobj="assignment", endobject="reference", sourcename="name", axisdir="start_direction")
    def create_voltage_source_from_objects(self, assignment, reference, start_direction=..., name=..., source_on_plane=...): # -> BoundaryObject:
        """Create a voltage source taking the closest edges of two objects.

        Parameters
        ----------
        assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            First object connected to the voltage source.
        reference : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Second object connected to the voltage source.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the port location.
            It should be one of the values for ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Name of the source. The default is ``None``.
        source_on_plane : bool, optional
            Whether to create the source on the plane orthogonal to
            ``AxisDir``. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignVoltage

        Examples
        --------

        Create two boxes for creating a voltage source named ``'VoltageSource'``.

        >>> box1 = hfss.modeler.create_box([30, 0, 0], [40, 10, 5], "BoxVolt1", "copper")
        >>> box2 = hfss.modeler.create_box([30, 0, 10], [40, 10, 5], "BoxVolt2", "copper")
        >>> v1 = hfss.create_voltage_source_from_objects("BoxVolt1", "BoxVolt2", hfss.AxisDir.XNeg, "VoltageSource")
        PyAEDT INFO: Connection Correctly created
        """
        ...
    
    @pyaedt_function_handler(startobj="assignment", endobject="reference", sourcename="name", axisdir="start_direction")
    def create_current_source_from_objects(self, assignment, reference, start_direction=..., name=..., source_on_plane=...): # -> BoundaryObject:
        """Create a current source taking the closest edges of two objects.

        Parameters
        ----------
        assignment : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            First object connected to the current source.
        reference : str or int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Second object connected to the current source.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the port location.
            It should be one of the values for ``Application.AxisDir``, which are: ``XNeg``, ``YNeg``,
            ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Name of the source. The default is ``None``.
        source_on_plane : bool, optional
            Whether to create the source on the plane orthogonal to
            the start direction. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignCurrent

        Examples
        --------

        Create two boxes for creating a current source named ``'CurrentSource'``.

        >>> box1 = hfss.modeler.create_box([30, 0, 20], [40, 10, 5], "BoxCurrent1", "copper")
        >>> box2 = hfss.modeler.create_box([30, 0, 30], [40, 10, 5], "BoxCurrent2", "copper")
        >>> i1 = hfss.create_current_source_from_objects(
        ...     "BoxCurrent1", "BoxCurrent2", hfss.AxisDir.XPos, "CurrentSource"
        ... )
        PyAEDT INFO: Connection created 'CurrentSource' correctly.
        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", sourcetype="source_type")
    def create_source_excitation(self, assignment, point1, point2, name, source_type=...): # -> BoundaryObject:
        """Create a source excitation.

        Parameters
        ----------
        assignment : str
            Name of the sheet.
        point1 : list
            First point of the source excitation.
        point2 : list
            Second point of the source excitation.
        name : str
            Name of the source.
        source_type : str, optional
            Type of the source. The default is ``"Voltage"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignVoltage
        >>> oModule.AssignCurrent
        """
        ...
    
    @pyaedt_function_handler(face="assignment", nummodes="modes", portname="name", renorm="renormalize", deembed_dist="deembed_distance")
    def create_floquet_port(self, assignment, lattice_origin=..., lattice_a_end=..., lattice_b_end=..., modes=..., name=..., renormalize=..., deembed_distance=..., reporter_filter=..., lattice_cs=...): # -> BoundaryObject:
        """Create a floquet port on a face.

        Parameters
        ----------
        assignment :
            Face or sheet to apply the floquet port to.
        lattice_origin : list
            List of ``[x,y,z]`` coordinates for the lattice A-B origin. The default is ``None``,
            in which case the method tries to compute the A-B automatically.
        lattice_a_end : list
            List of ``[x,y,z]`` coordinates for the lattice A end point. The default is ``None``,
            in which case the method tries to compute the A-B automatically.
        lattice_b_end : list
            List of ``[x,y,z]`` coordinates for the lattice B end point. The default is ``None``,
            in which case the method tries to compute the A-B automatically.
        modes : int, optional
            Number of modes. The default is ``2``.
        name : str, optional
            Name of the port. The default is ``None``.
        renormalize : bool, optional
            Whether to renormalize the mode. The default is ``True``.
        deembed_distance : float, str, optional
            Deembed distance in millimeters. The default is ``0``,
            in which case deembed is disabled.
        reporter_filter : bool, list of bool
            Whether to include modes in the report. The default is ``True``. If a single
            Boolean value is specified, it applies to all modes. If a list of Boolean values is specified, it applies
            to each mode in the list. A list must have ``nummodes`` elements.
        lattice_cs : str, optional
            Coordinate system for the lattice A-B vector reference. The default is ``Global``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.


        References
        ----------
        >>> oModule.AssignFloquetPort
        """
        ...
    
    @pyaedt_function_handler(face_couple="assignment", pair_name="name")
    def assign_lattice_pair(self, assignment, reverse_v=..., phase_delay=..., phase_delay_param1=..., phase_delay_param2=..., name=...): # -> BoundaryObject:
        """Assign a lattice pair to a couple of faces.

        Parameters
        ----------
        assignment : list
            List of two faces to assign the lattice pair to.
        reverse_v : bool, optional
            Whether to reverse the V vector. The default is `False`.
        phase_delay : str, optional
            Phase delay approach. Options are ``"UseScanAngle"``,
            ``"UseScanUV"``, and ``"InputPhaseDelay"``. The default is
            ``"UseScanAngle"``.
        phase_delay_param1 : str, optional
            Value for the first phase delay parameter, which depends on the approach:

            - Phi angle if the approach is ``"UseScanAngle"``.
            - U value if the approach is ``"UseScanUV"``.
            - Phase if the approach is ``"InputPhaseDelay"``.

            The default is ``0deg``.

        phase_delay_param2 :  str, optional
            Value for the second phase delay parameter, which depends on the approach:

            - Theta angle if the approach is "``UseScanAngle"``.
            - V value if the approach is ``"UseScanUV"``.

            The default is ``0deg``.
        name : str, optional
            Boundary name.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignLatticePair
        """
        ...
    
    @pyaedt_function_handler(object_to_assign="assignment")
    def auto_assign_lattice_pairs(self, assignment, coordinate_system=..., coordinate_plane=...): # -> list[Any]:
        """Assign lattice pairs to a geometry automatically.

        Parameters
        ----------
        assignment : str, :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Object to assign a lattice to.
        coordinate_system : str, optional
            Coordinate system to look for the lattice on.
        coordinate_plane : str, optional
            Plane to look for the lattice on. Options are ``"XY"``, ``"XZ"``, and
            ``"YZ"``. The default is ``"XY"``.

        Returns
        -------
        list of str
            List of created pair names.

        References
        ----------
        >>> oModule.AutoIdentifyLatticePair
        """
        ...
    
    @pyaedt_function_handler(face="assignment", primary_name="primary", coord_name="coordinate_system", secondary_name="name")
    def assign_secondary(self, assignment, primary, u_start, u_end, reverse_v=..., phase_delay=..., phase_delay_param1=..., phase_delay_param2=..., coordinate_system=..., name=...): # -> BoundaryObject:
        """Assign the secondary boundary condition.

        Parameters
        ----------
        assignment : int, FacePrimitive
            Face to assign the lattice pair to.
        primary : str
            Name of the primary boundary to couple.
        u_start : list
            List of ``[x,y,z]`` values for the starting point of the U vector.
        u_end : list
            List of ``[x,y,z]`` values for the ending point of the U vector.
        reverse_v : bool, optional
            Whether to reverse the V vector. The default is ``False``.
        phase_delay : str, optional
            Phase delay approach. Options are ``"UseScanAngle"``,
            ``"UseScanUV"``, and ``"InputPhaseDelay"``. The default is
            ``"UseScanAngle"``.
        phase_delay_param1 : str, optional
            Value for the first phase delay parameter, which depends on the approach:

            - Phi angle if the approach is ``"UseScanAngle"``.
            - U value if the approach is ``"UseScanUV"``.
            - Phase if the approach is ``"InputPhaseDelay"``.

            The default is ``0deg``.
        phase_delay_param2 :  str, optional
            Value for the second phase delay parameter, which depends on the approach:

            - Theta angle if the approach is "``UseScanAngle"``.
            - V value if the approach is ``"UseScanUV"``.

            The default is ``0deg``.
        coordinate_system : str, optional
            Name of the coordinate system for U coordinates.
        name : str, optional
            Name of the boundary. The default is ``None``,
            in which case a name is automatically assigned.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignSecondary
        """
        ...
    
    @pyaedt_function_handler(face="assignment", coord_name="coordinate_system", primary_name="name")
    def assign_primary(self, assignment, u_start, u_end, reverse_v=..., coordinate_system=..., name=...): # -> BoundaryObject:
        """Assign the primary boundary condition.

        Parameters
        ----------
        assignment : int, FacePrimitive
            Face to assign the lattice pair to.
        u_start : list
            List of ``[x,y,z]`` values for the starting point of the U vector.
        u_end : list
            List of ``[x,y,z]`` values for the ending point of the U vector.
        reverse_v : bool, optional
            Whether to reverse the V vector. The default is `False`.
        coordinate_system : str, optional
            Name of the coordinate system for the U coordinates. The
            default is ``"Global"``.
        name : str, optional
            Name of the boundary. The default is ``None``,
            in which case a name is automatically assigned.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignPrimary
        """
        ...
    
    @pyaedt_function_handler(Tissue_object_List_ID="assignment", TissueMass="tissue_mass", MaterialDensity="material_density", Average_SAR_method="average_sar_method")
    def sar_setup(self, assignment=..., tissue_mass=..., material_density=..., voxel_size=..., average_sar_method=...): # -> Literal[True]:
        """Define SAR settings.

        Parameters
        ----------
        assignment : int, optional
           Object ID. The default is ``-1`` to not specify the object.
        tissue_mass : float, optional
            Mass of tissue in grams. The default is ``1``.
        material_density : optional
            Density of material in gram/cm^3. The default is ``1``.
        voxel_size : optional
            Size of a voxel in millimeters. The default is ``1``.
        average_sar_method : optional
            SAR method. There are two options, ``0`` for IEEE Standard 1528 and ``1`` for the standard Ansys method.
            The default is ``0``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SARSetup
        """
        ...
    
    @pyaedt_function_handler(Frequency="frequency", Boundary="boundary", ApplyInfiniteGP="apply_infinite_ground", GPAXis="gp_axis")
    def create_open_region(self, frequency=..., boundary=..., apply_infinite_ground=..., gp_axis=...): # -> Literal[True]:
        """Create an open region on the active editor.

        Parameters
        ----------
        frequency : int, float, str optional
            Frequency with units. The default is ``"1GHz"``.
        boundary : str, optional
            Type of the boundary. The default is ``"Radiation"``.
        apply_infinite_ground : bool, optional
            Whether to apply an infinite ground plane. The default is ``False``.
        gp_axis : str, optional
            Open region direction. The default is ``"-z"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.CreateOpenRegion
        """
        ...
    
    @pyaedt_function_handler(startobj="assignment", endobj="reference", sourcename="name", rlctype="rlc_type", Rvalue="resistance", Lvalue="inductance", Cvalue="capacitance", bound_on_plane="is_boundary_on_plane", axisdir="start_direction")
    def create_lumped_rlc_between_objects(self, assignment, reference, start_direction=..., name=..., rlc_type=..., resistance=..., inductance=..., capacitance=..., is_boundary_on_plane=...): # -> BoundaryObject:
        """Create a lumped RLC taking the closest edges of two objects.

        Parameters
        ----------
        assignment :
            Starting object for the integration line.
        reference :
            Ending object for the integration line.
        start_direction : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Start direction for the boundary location.. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Perfect H name. The default is ``None``, in which
            case a name is automatically assigned.
        rlc_type : str, optional
            Type of the RLC. Options are ``"Parallel"`` and ``"Serial"``.
            The default is ``"Parallel"``.
        resistance : optional
            Resistance value in ohms. The default is ``None``,
            in which case this parameter is disabled.
        inductance : optional
            Inductance value in H. The default is ``None``,
            in which case this parameter is disabled.
        capacitance : optional
            Capacitance value in F. The default is ``None``,
            in which case this parameter is disabled.
        is_boundary_on_plane : bool, optional
            Whether to create the boundary on the plane orthogonal
            to ``AxisDir``. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject` or bool
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignLumpedRLC

        Examples
        --------

        Create two boxes for creating a lumped RLC named ``'LumpedRLC'``.

        >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5], "rlc1", "copper")
        >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5], "rlc2", "copper")
        >>> rlc = hfss.create_lumped_rlc_between_objects(
        ...     "rlc1", "rlc2", hfss.AxisDir.XPos, "Lumped RLC", resistance=50, inductance=1e-9, capacitance=1e-6
        ... )
        PyAEDT INFO: Connection Correctly created

        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", axisdir="start_direction")
    def assign_voltage_source_to_sheet(self, assignment, start_direction=..., name=...): # -> BoundaryObject:
        """Create a voltage source taking one sheet.

        Parameters
        ----------
        assignment : str
            Name of the sheet to apply the boundary to.
        start_direction : int, :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir` or list, optional
            Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
            of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Name of the source. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignVoltage

        Examples
        --------
        Create a sheet and assign to it some voltage.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -70], [10, 2], name="VoltageSheet", material="copper"
        ... )
        >>> v1 = hfss.assign_voltage_source_to_sheet(sheet.name, hfss.AxisDir.XNeg, "VoltageSheetExample")
        >>> v2 = hfss.assign_voltage_source_to_sheet(
        ...     sheet.name, [sheet.bottom_edge_x.midpoint, sheet.bottom_edge_y.midpoint], 50
        ... )

        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", axisdir="start_direction")
    def assign_current_source_to_sheet(self, assignment, start_direction=..., name=...): # -> BoundaryObject:
        """Create a current source taking one sheet.

        Parameters
        ----------
        assignment : str
            Name of the sheet to apply the boundary to.
        start_direction : int, :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir` or list, optional
            Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
            of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Name of the source. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignCurrent

        Examples
        --------

        Create a sheet and assign some current to it.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -50], [5, 1], name="CurrentSheet", material="copper"
        ... )
        >>> hfss.assign_current_source_to_sheet(sheet.name, hfss.AxisDir.XNeg, "CurrentSheetExample")
        'CurrentSheetExample'
        >>> c1 = hfss.assign_current_source_to_sheet(
        ...     sheet.name, [sheet.bottom_edge_x.midpoint, sheet.bottom_edge_y.midpoint]
        ... )

        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", rlctype="rlc_type", Rvalue="resistance", Lvalue="inductance", Cvalue="capacitance", axisdir="start_direction")
    def assign_lumped_rlc_to_sheet(self, assignment, start_direction=..., name=..., rlc_type=..., resistance=..., inductance=..., capacitance=...): # -> BoundaryObject:
        """Create a lumped RLC taking one sheet.

        Parameters
        ----------
        assignment : str
            Name of the sheet to apply the boundary to.
        start_direction : int, :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir` or list, optional
            Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
            of the start point and end point with the format [[xstart, ystart, zstart], [xend, yend, zend]]
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Lumped RLC name. The default is ``None``.
        rlc_type : str, optional
            Type of the RLC. Options are ``"Parallel"`` and ``"Serial"``. The default is ``"Parallel"``.
        resistance : float, optional
            Resistance value in ohms. The default is ``None``, in which
            case this parameter is disabled.
        inductance : float, optional
            Inductance value in Henry (H). The default is ``None``, in which
            case this parameter is disabled.
        capacitance : float, optional
            Capacitance value in  farads (F). The default is ``None``, in which
            case this parameter is disabled.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignLumpedRLC

        Examples
        --------

        Create a sheet and use it to create a lumped RLC.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -90], [10, 2], name="RLCSheet", material="Copper"
        ... )
        >>> lumped_rlc_to_sheet = hfss.assign_lumped_rlc_to_sheet(
        ...     sheet.name, hfss.AxisDir.XPos, resistance=50, inductance=1e-9, capacitance=1e-6
        ... )
        >>> type(lumped_rlc_to_sheet)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>
        >>> h2 = hfss.assign_lumped_rlc_to_sheet(
        ...     sheet.name,
        ...     [sheet.bottom_edge_x.midpoint, sheet.bottom_edge_y.midpoint],
        ...     resistance=50,
        ...     inductance=1e-9,
        ...     capacitance=1e-6,
        ... )

        """
        ...
    
    @pyaedt_function_handler(sheet_name="assignment", sourcename="name", is_infground="is_infinite_ground", reference_cs="coordinate_system")
    def assign_impedance_to_sheet(self, assignment, name=..., resistance=..., reactance=..., is_infinite_ground=..., coordinate_system=...): # -> BoundaryObject:
        """Create an impedance taking one sheet.

        Parameters
        ----------
        assignment : str or list
            One or more names of the sheets to apply the boundary to.
        name : str, optional
            Name of the impedance. The default is ``None``.
        resistance : float or list, optional
            Resistance value in ohms. The default is ``50.0``.
            If a list of four elements is passed, an anisotropic impedance is assigned with the following order,
            [``Zxx``, ``Zxy``, ``Zyx``, ``Zyy``].
        reactance : optional
            Reactance value in ohms. The default is ``0.0``.
            If a list of four elements is passed, an anisotropic impedance is assigned with the following order,
            [``Zxx``, ``Zxy``, ``Zyx``, ``Zyy``].
        is_infinite_ground : bool, optional
            Whether the impedance is an infinite ground. The default is ``False``.
        coordinate_system : str, optional
            Name of the coordinate system for the XY plane. The default is ``"Global"``.
            This parameter is only used for anisotropic impedance assignment.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object if successful, ``False`` otherwise.

        References
        ----------
        >>> oModule.AssignImpedance

        Examples
        --------

        Create a sheet and use it to create an impedance.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -90], [10, 2], name="ImpedanceSheet", material="Copper"
        ... )
        >>> impedance_to_sheet = hfss.assign_impedance_to_sheet(sheet.name, "ImpedanceFromSheet", 100, 50)

        Create a sheet and use it to create an anisotropic impedance.

        >>> sheet = hfss.modeler.create_rectangle(
        ...     hfss.PLANE.XY, [0, 0, -90], [10, 2], name="ImpedanceSheet", material="Copper"
        ... )
        >>> anistropic_impedance_to_sheet = hfss.assign_impedance_to_sheet(
        ...     sheet.name, "ImpedanceFromSheet", [377, 0, 0, 377], [0, 50, 0, 0]
        ... )

        """
        ...
    
    @pyaedt_function_handler(edge_signale="assignment", edge_gnd="reference", port_name="name", port_impedance="impedance")
    def create_circuit_port_from_edges(self, assignment, reference, name=..., impedance=..., renormalize=..., renorm_impedance=..., deembed=...): # -> BoundaryObject:
        """Create a circuit port from two edges.

        The integration line is from edge 2 to edge 1.

        .. deprecated:: 0.6.70
        Use :func:`circuit_port` method instead.

        Parameters
        ----------
        assignment : int
            Edge ID of the signal.
        reference : int
            Edge ID of the ground.
        name : str, optional
            Name of the port. The default is ``""``.
        impedance : int, str, or float, optional
            Impedance. The default is ``"50"``. You can also
            enter a string that looks like this: ``"50+1i*55"``.
        renormalize : bool, optional
            Whether to renormalize the mode. The default is ``False``.
            This parameter is ignored for a driven terminal.
        renorm_impedance :  str, optional
            Impedance. The default is ``50``.
        deembed : bool, optional
            Whether to deembed the port. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignCircuitPort

        Examples
        --------

        Create two rectangles in the XY plane.
        Select the first edge of each rectangle created previously.
        Create a circuit port from the first edge of the first rectangle
        toward the first edge of the second rectangle.

        >>> plane = hfss.PLANE.XY
        >>> rectangle1 = hfss.modeler.create_rectangle(plane, [10, 10, 10], [10, 10], name="rectangle1_for_port")
        >>> edges1 = hfss.modeler.get_object_edges(rectangle1.id)
        >>> first_edge = edges1[0]
        >>> rectangle2 = hfss.modeler.create_rectangle(plane, [30, 10, 10], [10, 10], name="rectangle2_for_port")
        >>> edges2 = hfss.modeler.get_object_edges(rectangle2.id)
        >>> second_edge = edges2[0]
        >>> hfss.solution_type = "Modal"
        >>> hfss.create_circuit_port_from_edges(
        ...     first_edge, second_edge, name="PortExample", impedance=50.1, renormalize=False, renorm_impedance="50"
        ... )
        'PortExample'

        """
        ...
    
    @pyaedt_function_handler(excitations="assignment")
    def edit_sources(self, assignment, include_port_post_processing=..., max_available_power=..., use_incident_voltage=..., eigenmode_stored_energy=...): # -> Literal[True]:
        """Set up the power loaded for HFSS postprocessing in multiple sources simultaneously.

        Parameters
        ----------
        assignment : dict
            Dictionary of input sources to modify module and phase.
            Dictionary values can be:
            - 1 value to setup 0deg as default
            - 2 values tuple or list (magnitude and phase) or
            - 3 values (magnitude, phase, and termination flag) for Terminal solution in case of incident voltage usage.
        include_port_post_processing : bool, optional
            Include port post-processing effects. The default is ``True``.
        max_available_power : str, optional
            System power for gain calculations.
            The default is ``None``, in which case maximum available power is applied.
        use_incident_voltage : bool, optional
            Use incident voltage definition. The default is ``False``.
            This argument applies only to the Terminal solution type.
        eigenmode_stored_energy : bool, optional
            Use stored energy definition. The default is ``True``.
            This argument applies only to the Eigenmode solution type.

        Returns
        -------
        bool

        Examples
        --------
        >>> sources = {"Port1:1": ("0W", "0deg"), "Port2:1": ("1W", "90deg")}
        >>> hfss.edit_sources(sources, include_port_post_processing=True)

        >>> sources = {"Box2_T1": ("0V", "0deg", True), "Box1_T1": ("1V", "90deg")}
        >>> hfss.edit_sources(sources, max_available_power="2W", use_incident_voltage=True)

        >>> aedtapp = add_app(solution_type="Eigenmode")
        >>> _ = aedtapp.modeler.create_box([0, 0, 0], [10, 20, 20])
        >>> setup = aedtapp.create_setup()
        >>> setup.props["NumModes"] = 2
        >>> sources = {"1": "1Joules", "2": "0Joules"}
        >>> aedtapp.edit_sources(sources, eigenmode_stored_energy=True)
        >>> sources = {"1": ("0V/M", "0deg"), "2": ("2V/M", "90deg")}
        >>> aedtapp.edit_sources(sources, eigenmode_stored_energy=False)
        """
        ...
    
    @pyaedt_function_handler(portandmode="assignment", powerin="power")
    def edit_source(self, assignment=..., power=..., phase=...): # -> Literal[True]:
        """Set up the power loaded for HFSS postprocessing.

        .. deprecated:: 0.11.2
           Use :func:`edit_sources` method instead.

        Parameters
        ----------
        assignment : str, optional
            Port name and mode. For example, ``"Port1:1"``.
            The port name must be defined if the solution type is other than Eigenmodal. This parameter
            is ignored if the solution type is Eigenmodal.
        power : str, optional
            Power in watts (W) or the project variable to put as stored energy in the project.
            The default is ``"1W"``.
        phase : str, optional
            Phase of the excitation. The default is ``"0deg"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditSources

        Examples
        --------

        Create a circle sheet and use it to create a wave port.
        Set up the thermal power for this wave port.

        >>> sheet = hfss.modeler.create_circle(hfss.PLANE.YZ, [-20, 0, 0], 10, name="sheet_for_source")
        >>> hfss.solution_type = "Modal"
        >>> wave_port = hfss.create_wave_port_from_sheet(sheet, 5, hfss.AxisDir.XNeg, 40, 2, "SheetWavePort", True)
        >>> hfss.edit_source("SheetWavePort" + ":1", "10W")
        PyAEDT INFO: Setting up power to "SheetWavePort:1" = 10W
        True

        """
        ...
    
    @pyaedt_function_handler(portandmode="assignment", file_name="input_file")
    def edit_source_from_file(self, input_file, assignment=..., is_time_domain=..., x_scale=..., y_scale=..., impedance=..., data_format=..., encoding=..., window=...): # -> Literal[True]:
        """Edit a source from file data.

        File data is a CSV containing either frequency data or time domain data that will be converted through FFT.

        Parameters
        ----------
        input_file : str
            Full name of the input file. If ``assignment`` is ``None``, it loads directly the file, in this case
            the file must have AEDT format.
        assignment : str, optional
            Port name and mode. For example, ``"Port1:1"``.
            The port name must be defined if the solution type is other than Eigenmodal.
        is_time_domain : bool, optional
            Whether the input data is time-based or frequency-based. Frequency based data are Mag/Phase (deg).
        x_scale : float, optional
            Scaling factor for the x axis. This argument is ignored if the algorithm
             identifies the format from the file header.
        y_scale : float, optional
            Scaling factor for the y axis. This argument is ignored if the algorithm
             identifies the format from the file header.
        impedance : float, optional
            Excitation impedance. Default is `50`.
        data_format : str, optional
            Data format. Options are ``"Current"``, ``"Power"``, and ``"Voltage"``. This
            argument is ignored if the algoritmm identifies the format from the
            file header.
        encoding : str, optional
            CSV file encoding.
        window : str, optional
            Fft window. Options are ``"hamming"``, ``"hanning"``, ``"blackman"``, ``"bartlett"`` or ``None``.

        Returns
        -------
        bool
        """
        ...
    
    @pyaedt_function_handler(file_name="input_file")
    def edit_sources_from_file(self, input_file): # -> Literal[True]:
        """Update all sources from a CSV file.

        .. deprecated:: 0.11.2
           Use :func:`edit_source_from_file` method instead.

        Parameters
        ----------
        input_file : str
            File name.

        Returns
        -------
        bool
        """
        ...
    
    @pyaedt_function_handler(inputlist="assignment", internalExtr="extrude_internally", internalvalue="internal_extrusion")
    def thicken_port_sheets(self, assignment, value, extrude_internally=..., internal_extrusion=...): # -> dict[Any, Any]:
        """Create thickened sheets over a list of input port sheets.

        This method is built to work with the output of ``modeler.find_port_faces``.

        Parameters
        ----------
        assignment : list
            List of the sheets to thicken.
        value :
            Value in millimeters for thickening the faces.
        extrude_internally : bool, optional
            Whether to extrude the sheets internally (going into the model).
            The default is ``True``.
        internal_extrusion : int, optional
            Value in millimeters for thickening the sheets internally if ``internalExtr=True``.
            The default is ``1``.

        Returns
        -------
        Dict
            For each input sheet, returns the port IDs where thickened sheets were created
            if the name contains the word "Vacuum".

        References
        ----------
        >>> oEditor.ThickenSheet

        Examples
        --------

        Create a circle sheet and use it to create a wave port.
        Set the thickness of this circle sheet to ``"2 mm"``.

        >>> sheet_for_thickness = hfss.modeler.create_circle(hfss.PLANE.YZ, [60, 60, 60], 10, name="SheetForThickness")
        >>> port_for_thickness = hfss.create_wave_port_from_sheet(
        ...     sheet_for_thickness, 5, hfss.AxisDir.XNeg, 40, 2, "WavePortForThickness", True
        ... )
        >>> hfss.thicken_port_sheets(["SheetForThickness"], 2)
        PyAEDT INFO: done
        {}

        """
        ...
    
    @pyaedt_function_handler(dname="design", outputdir="output_dir")
    def validate_full_design(self, design=..., output_dir=..., ports=...): # -> tuple[list[Any], bool]:
        """Validate a design based on an expected value and save information to the log file.

        Parameters
        ----------
        design : str,  optional
            Name of the design to validate. The default is ``None``, in which case
            the current design is used.
        output_dir : str, optional
            Directory to save the log file to. The default is ``None``,
            in which case the current project path is used.
        ports : int, optional
            Number of excitations (sum of modes) that is expected. The default is ``None``.

        Returns
        -------
        list of str
            List of all the validation information for later use.
        bool
            ``True`` if the validation was successful, ``False`` otherwise.

        References
        ----------
        >>> oDesign.ValidateDesign

        Examples
        --------
        Validate the current design and save the log file in the current project directory.

        >>> validation = hfss.validate_full_design()
        PyAEDT INFO: Design Validation Checks
        >>> validation[1]
        False
        """
        ...
    
    @pyaedt_function_handler(plot_name="plot", sweep_name="sweep", port_names="ports", port_excited="ports_excited")
    def create_scattering(self, plot=..., sweep=..., ports=..., ports_excited=..., variations=...): # -> Literal[False]:
        """Create an S-parameter report.

        Parameters
        ----------
        plot : str, optional
             Name of the plot. The default is ``"S Parameter Plot Nominal"``.
        sweep : str, optional
             Name of the sweep. The default is ``None``.
        ports : list, optional
             List of port names. The first index, i, in S[i,j].
             The default is ``None``.
        ports_excited : list or str, optional
             List of port names. The seconds index, j in S[i,j].
             The default is ``None``.
        variations : str, optional
             The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.CreateReport

        Examples
        --------

        Create an S-parameter plot named ``"S Parameter Plot Nominal"`` for a 3-port network.
        plotting S11, S21, S31.  The port names are ``P1``, ``P2``, and ``P3``.

        >>> hfss.create_scattering(ports=["P1", "P2", "P3"], ports_excited=["P1", "P1", "P1"])
        True

        """
        ...
    
    @pyaedt_function_handler(outputlist="output", setupname="setup", plotname="name", Xaxis="x_axis")
    def create_qfactor_report(self, project_dir, output, setup, name, x_axis=...): # -> Literal[True]:
        """Export a CSV file of the EigenQ plot.

        Parameters
        ----------
        project_dir : str
            Directory to export the CSV file to.
        output : list
            Output quantity, which in this case is the Q-factor.
        setup : str
            Name of the setup to generate the report from.
        name : str
            Name of the plot.
        x_axis : str, optional
            Value for the X axis. The default is ``"X"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.CreateReport

        """
        ...
    
    @pyaedt_function_handler(time_var="time_variable", setup_name="setup")
    def create_sbr_chirp_i_doppler_setup(self, time_variable=..., sweep_time_duration=..., center_freq=..., resolution=..., period=..., velocity_resolution=..., min_velocity=..., max_velocity=..., ray_density_per_wavelength=..., max_bounces=..., include_coupling_effects=..., doppler_ad_sampling_rate=..., setup=...): # -> tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, SetupParam | Any | Literal[False]] | tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, Literal[False]]:
        """Create an SBR+ Chirp I setup.

        Parameters
        ----------
        time_variable : str, optional
            Name of the time variable. The default is ``None``, in which case
            a search for the first time variable is performed.
        sweep_time_duration : float, optional
            Duration for the sweep time. The default is ``0.`` If a value greater
            than ``0`` is specified, a parametric sweep is created.
        center_freq : float, optional
            Center frequency in gigahertz (GHz). The default is ``76.5``.
        resolution : float, optional
            Doppler resolution in meters (m). The default is ``1``.
        period : float, optional
            Period of analysis in meters (m). The default is ``200``.
        velocity_resolution : float, optional
            Doppler velocity resolution in meters per second (m/s). The default is ``0.4``.
        min_velocity : str, optional
            Minimum Doppler velocity in meters per second (m/s). The default is ``-20``.
        max_velocity : str, optional
            Maximum Doppler velocity in meters per second (m/s). The default is ``20``.
        ray_density_per_wavelength : float, optional
            Doppler ray density per wavelength. The default is ``0.2``.
        max_bounces : int, optional
            Maximum number of bounces. The default is ``5``.
        include_coupling_effects : float, optional
            Whether to include coupling effects. The default is ``False``.
        doppler_ad_sampling_rate : float, optional
            Doppler AD sampling rate to use if ``include_coupling_effects``
            is ``True``. The default is ``20``.
        setup : str, optional
            Name of the setup. The default is ``None``, in which case the active setup is used.

        Returns
        -------
        tuple
            The tuple contains: (:class:`ansys.aedt.core.modules.solve_setup.Setup`,
            :class:`ansys.aedt.core.modules.design_xploration.ParametericsSetups.Optimetrics`).

        References
        ----------
        >>> oModule.InsertSetup

        """
        ...
    
    @pyaedt_function_handler(time_var="time_variable", setup_name="setup")
    def create_sbr_chirp_iq_doppler_setup(self, time_variable=..., sweep_time_duration=..., center_freq=..., resolution=..., period=..., velocity_resolution=..., min_velocity=..., max_velocity=..., ray_density_per_wavelength=..., max_bounces=..., include_coupling_effects=..., doppler_ad_sampling_rate=..., setup=...): # -> tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, SetupParam | Any | Literal[False]] | tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, Literal[False]]:
        """Create an SBR+ Chirp IQ setup.

        Parameters
        ----------
        time_variable : str, optional
            Name of the time variable. The default is ``None``, in which case
            a search for the first time variable is performed.
        sweep_time_duration : float, optional
            Duration of the sweep time. The default is ``0``. If a value greater
            than ``0`` is specified, a parametric sweep is created.
        center_freq : float, optional
            Center frequency in gighertz (GHz). The default is ``76.5``.
        resolution : float, optional
            Doppler resolution in meters (m). The default is ``1``.
        period : float, optional
            Period of analysis in meters (m). The default is ``200``.
        velocity_resolution : float, optional
            Doppler velocity resolution in meters per second (m/s). The default is ``0.4``.
        min_velocity : str, optional
            Minimum Doppler velocity in meters per second (m/s). The default is ``-20``.
        max_velocity : str, optional
            Maximum Doppler velocity in meters per second (m/s). The default is ``20``.
        ray_density_per_wavelength : float, optional
            Doppler ray density per wavelength. The default is ``0.2``.
        max_bounces : int, optional
            Maximum number of bounces. The default is ``5``.
        include_coupling_effects : float, optional
            Whether to include coupling effects. The default is ``False``.
        doppler_ad_sampling_rate : float, optional
            Doppler AD sampling rate to use if ``include_coupling_effects`` is
            ``True``. The default is ``20``.
        setup : str, optional
            Name of the setup. The default is ``None``, in which case the active
            setup is used.

        Returns
        -------
        tuple
            The tuple contains: (:class:`ansys.aedt.core.modules.solve_setup.Setup`,
            :class:`ansys.aedt.core.modules.design_xploration.ParametericsSetups.Optimetrics`).

        References
        ----------
        >>> oModule.InsertSetup
        """
        ...
    
    @pyaedt_function_handler(time_var="time_variable", center_freq="frequency", setup_name="setup")
    def create_sbr_pulse_doppler_setup(self, time_variable=..., sweep_time_duration=..., frequency=..., resolution=..., period=..., velocity_resolution=..., min_velocity=..., max_velocity=..., ray_density_per_wavelength=..., max_bounces=..., setup=...): # -> tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, SetupParam | Any | Literal[False]] | tuple[SetupHFSSAuto | SetupSBR | SetupMaxwell | SetupQ3D | SetupIcepak | SetupHFSS, Literal[False]]:
        """Create an SBR+ pulse Doppler setup.

        Parameters
        ----------
        time_variable : str, optional
            Name of the time variable. The default is ``None``, in which case
            a search for the first time variable is performed.
        sweep_time_duration : float, optional
            Duration of the sweep time. The default is ``0``. If a value greater
            than ``0`` is specified, a parametric sweep is created.
        frequency : float, optional
            Center frequency in gigahertz (GHz). The default is ``76.5``.
        resolution : float, optional
            Doppler resolution in meters (m). The default is ``1``.
        period : float, optional
            Period of analysis in meters (m). The default is ``200``.
        velocity_resolution : float, optional
            Doppler velocity resolution in meters per second (m/s).
            The default is ``0.4``.
        min_velocity : str, optional
            Minimum Doppler velocity in meters per second (m/s). The default
            is ``-20``.
        max_velocity : str, optional
            Maximum Doppler velocity in meters per second (m/s). The default
            is ``20``.
        ray_density_per_wavelength : float, optional
            Doppler ray density per wavelength. The default is ``0.2``.
        max_bounces : int, optional
            Maximum number of bounces. The default is ``5``.
        setup : str, optional
            Name of the setup. The default is ``None``, in which case the active
            setup is used.

        Returns
        -------
        tuple
            The tuple contains: (:class:`ansys.aedt.core.modules.solve_setup.Setup`,
            :class:`ansys.aedt.core.modules.design_xploration.ParametericsSetups.Optimetrics`).

        References
        ----------
        >>> oModule.InsertSetup
        """
        ...
    
    @pyaedt_function_handler(radar_name="name")
    def create_sbr_radar_from_json(self, radar_file, name, offset=..., speed=..., use_relative_cs=..., relative_cs_name=...): # -> Radar:
        """Create an SBR+ radar setup from a JSON file.

        Example of input JSON file:

          .. code-block:: json

            {
                "name": "Example_1Tx_1Rx",
                "version": 1,
                "number_tx":"1",
                "number_rx":"1",
                "units":"mm",
                "antennas": {
                    "tx1": {
                        "antenna_type":"parametric",
                        "mode":"tx",
                        "offset":["0" ,"0" ,"0"],
                        "rotation_axis":null,
                        "rotation":null,
                        "beamwidth_elevation":"10deg",
                        "beamwidth_azimuth":"60deg",
                        "polarization":"Vertical"
                        },
                    "rx1": {
                        "antenna_type":"parametric",
                        "mode":"rx",
                        "offset":["0" ,"1.8" ,"0"],
                        "rotation_axis":null,
                        "rotation":null,
                        "beamwidth_elevation":"10deg",
                        "beamwidth_azimuth":"60deg",
                        "polarization":"Vertical"
                        }
                }
            }

        Parameters
        ----------
        radar_file : str
            Path to the directory with the radar file.
        name : str
            Name of the radar file.
        offset : list, optional
            Offset relative to the global coordinate system.
        speed : float, optional
            Radar movement speed relative to the global coordinate system if greater than ``0``.
        use_relative_cs : bool, optional
            Whether to use the relative coordinate system. The default is ``False``.
        relative_cs_name : str
            Name of the relative coordinate system to link the radar to.
            The default is ``None``, in which case the global coordinate system is used.

        Returns
        -------
        :class:`ansys.aedt.core.modeler.actors.Radar`
            Radar  class object.

        References
        ----------
        AEDT API Commands.

        >>> oEditor.CreateRelativeCS
        >>> oModule.SetSBRTxRxSettings
        >>> oEditor.CreateGroup
        """
        ...
    
    @pyaedt_function_handler()
    def insert_infinite_sphere(self, definition=..., x_start=..., x_stop=..., x_step=..., y_start=..., y_stop=..., y_step=..., units=..., custom_radiation_faces=..., custom_coordinate_system=..., use_slant_polarization=..., polarization_angle=..., name=...): # -> FarFieldSetup | Literal[False]:
        """Create an infinite sphere.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        definition : str
            Coordinate definition type. The default is ``"Theta-Phi"``.
            It can be a ``ansys.aedt.core.generic.constants.INFINITE_SPHERE_TYPE`` enumerator value.
        x_start : float, str, optional
            First angle start value. The default is ``0``.
        x_stop : float, str, optional
            First angle stop value. The default is ``180``.
        x_step : float, str, optional
            First angle step value. The default is ``10``.
        y_start : float, str, optional
            Second angle start value. The default is ``0``.
        y_stop : float, str, optional
            Second angle stop value. The default is ``180``.
        y_step : float, str, optional
            Second angle step value. The default is ``10``.
        units : str
            Angle units. The default is ``"deg"``.
        custom_radiation_faces : str, optional
            List of radiation faces to use for far field computation. The default is ``None``.
        custom_coordinate_system : str, optional
            Local coordinate system to use for far field computation. The default is
            ``None``.
        use_slant_polarization : bool, optional
            Whether to use slant polarization. The default is ``False``.
        polarization_angle : float, str, optional
            Slant angle value. The default is ``45``.
        name : str, optional
            Name of the sphere. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.FarFieldSetup`
        """
        ...
    
    @pyaedt_function_handler()
    def insert_near_field_sphere(self, radius=..., radius_units=..., x_start=..., x_stop=..., x_step=..., y_start=..., y_stop=..., y_step=..., angle_units=..., custom_radiation_faces=..., custom_coordinate_system=..., name=...): # -> NearFieldSetup | Literal[False]:
        """Create a near field sphere.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        radius : float, str, optional
            Sphere radius. The default is ``20``.
        radius_units : str
            Radius units. The default is ``"mm"``.
        x_start : float, str, optional
            First angle start value. The default is ``0``.
        x_stop : float, str, optional
            First angle stop value. The default is ``180``.
        x_step : float, str, optional
            First angle step value. The default is ``10``.
        y_start : float, str, optional
            Second angle start value. The default is ``0``.
        y_stop : float, str, optional
            Second angle stop value. The default is ``180``.
        y_step : float, str, optional
            Second angle step value. The default is ``10``.
        angle_units : str
            Angle units. The default is ``"deg"``.
        custom_radiation_faces : str, optional
            List of radiation faces to use for far field computation. The default is ``None``.
        custom_coordinate_system : str, optional
            Local coordinate system to use for far field computation. The default is ``None``.
        name : str, optional
            Name of the sphere. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @pyaedt_function_handler()
    def insert_near_field_box(self, u_length=..., u_samples=..., v_length=..., v_samples=..., w_length=..., w_samples=..., units=..., custom_radiation_faces=..., custom_coordinate_system=..., name=...): # -> NearFieldSetup | Literal[False]:
        """Create a near field box.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        u_length : float, str, optional
            U axis length. The default is ``20``.
        u_samples : float, str, optional
            U axis samples. The default is ``21``.
        v_length : float, str, optional
            V axis length. The default is ``20``.
        v_samples : float, str, optional
            V axis samples. The default is ``21``.
        w_length : float, str, optional
            W axis length. The default is ``20``.
        w_samples : float, str, optional
            W axis samples. The default is ``21``.
        units : str
            Length units. The default is ``"mm"``.
        custom_radiation_faces : str, optional
            List of radiation faces to use for far field computation. The default is ``None``.
        custom_coordinate_system : str, optional
            Local coordinate system to use for far field computation. The default is ``None``.
        name : str, optional
            Name of the sphere. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @pyaedt_function_handler()
    def insert_near_field_rectangle(self, u_length=..., u_samples=..., v_length=..., v_samples=..., units=..., custom_radiation_faces=..., custom_coordinate_system=..., name=...): # -> NearFieldSetup | Literal[False]:
        """Create a near field rectangle.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        u_length : float, str, optional
            U axis length. The default is ``20``.
        u_samples : float, str, optional
            U axis samples. The default is ``21``.
        v_length : float, str, optional
            V axis length. The default is ``20``.
        v_samples : float, str, optional
            V axis samples. The default is ``21``.
        units : str
            Length units. The default is ``"mm"``.
        custom_radiation_faces : str, optional
            List of radiation faces to use for far field computation. The default is ``None``.
        custom_coordinate_system : str, optional
            Local coordinate system to use for far field computation. The default is ``None``.
        name : str, optional
            Name of the sphere. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @pyaedt_function_handler(line="assignment")
    def insert_near_field_line(self, assignment, points=..., custom_radiation_faces=..., name=...): # -> NearFieldSetup | Literal[False]:
        """Create a near field line.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        assignment : str
            Polyline name.
        points : float, str, optional
            Number of points. The default value is ``1000``.
        custom_radiation_faces : str, optional
            List of radiation faces to use for far field computation. The default is ``None``.
        name : str, optional
            Name of the sphere. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @pyaedt_function_handler()
    def insert_near_field_points(self, input_file: Union[str, Path] = ..., coordinate_system=..., name=...): # -> NearFieldSetup | Literal[False]:
        """Create a near field line.

        .. note::
           This method is not supported by HFSS ``EigenMode`` and ``CharacteristicMode`` solution types.

        Parameters
        ----------
        input_file : str or :class:`pathlib.Path`
            Point list file with. Extension must be ``.pts``.
        coordinate_system : str, optional
            Local coordinate system to use. The default is ``"Global``.
        name : str, optional
            Name of the point list. The default is ``None``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hfss_boundary.NearFieldSetup`
        """
        ...
    
    @pyaedt_function_handler()
    def set_sbr_current_sources_options(self, conformance=..., thin_sources=..., power_fraction=...): # -> Literal[True]:
        """Set SBR+ setup options for the current source.

        Parameters
        ----------
        conformance : bool, optional
            Whether to enable current source conformance. The default is ``False``.
        thin_sources : bool, optional
            Whether to enable thin sources. The default is ``False``.
        power_fraction : float or str, optional
            Power fraction to use if ``thin_sources=True``. The default is ``0.95``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditGlobalCurrentSourcesOption
        """
        ...
    
    @pyaedt_function_handler(positive_terminal="assignment", negative_terminal="reference", common_name="common_mode", diff_name="differential_mode", common_ref="common_reference", diff_ref_z="differential_reference")
    def set_differential_pair(self, assignment, reference, common_mode=..., differential_mode=..., common_reference=..., differential_reference=..., active=..., matched=...): # -> bool:
        """Add a differential pair definition.

        Differential pairs can be defined only in Terminal and Transient solution types.
        The differential pair is created from an existing port definition having at least two
        terminals.

        Parameters
        ----------
        assignment : str
            Name of the terminal to use as the positive terminal.
        reference : str
            Name of the terminal to use as the negative terminal.
        common_mode : str, optional
            Name for the common mode. The default is ``None``, in which case a unique name is assigned.
        differential_mode : str, optional
            Name for the differential mode. The default is ``None``, in which case a unique name is assigned.
        common_reference : float, optional
            Reference impedance for the common mode in ohms. The default is ``25``.
        differential_reference : float, optional
            Reference impedance for the differential mode in ohms. The default is ``100``.
        active : bool, optional
            Whether the differential pair is active. The default is ``True``.
        matched : bool, optional
            Whether the differential pair is matched. The default is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.EditDiffPairs
        """
        ...
    
    @pyaedt_function_handler(array_name="name", json_file="input_data")
    def add_3d_component_array_from_json(self, input_data, name=...):
        """Add or edit a 3D component array from a JSON file, TOML file, or dictionary.

        The 3D component is placed in the layout if it is not present.

        Parameters
        ----------
        input_data : str, dict
            Full path to either the JSON file, TOML file, or the dictionary
            containing the array information.
        name : str, optional
             Name of the boundary to add or edit.

        Returns
        -------
        class:`ansys.aedt.core.modeler.cad.component_array.ComponentArray`

        Examples
        --------
        Add a 3D component array from a json file.
        Below is the content of a json file that will be used in the following code sample.

        >>> {
        >>> "primarylattice": "MyFirstLattice",
        >>> "secondarylattice": "MySecondLattice",
        >>> "useairobjects": true,
        >>> "rowdimension": 4,
        >>> "columndimension": 4,
        >>> "visible": true,
        >>> "showcellnumber": true,
        >>> "paddingcells": 0,
        >>> "referencecsid": 1,
        >>> "MyFirstCell": "path/to/firstcell.a3dcomp", # optional to insert 3d comp
        >>> "MySecondCell": "path/to/secondcell.a3dcomp",# optional to insert 3d comp
        >>> "MyThirdCell": "path/to/thirdcell.a3dcomp",  # optional to insert 3d comp
        >>> "cells": { "(1,1)": {
        >>>            "name" : "MyFirstCell",
        >>>            "color" : "(255,0,20)", #optional
        >>>            "active" : true, #optional
        >>>            "postprocessing" : true #optional
        >>>            "rotation" : 0.0  #optional
        >>>             },
        >>>            "(1,2)": {
        >>>            "name" : "MySecondCell",
        >>>            "rotation" : 90.0
        >>>             }
        >>> # continue
        >>> }

        >>> from ansys.aedt.core import Hfss
        >>> from ansys.aedt.core.generic.file_utils import read_configuration_file
        >>> hfss_app = Hfss()
        >>> dict_in = read_configuration_file(r"path\\to\\json_file")
        >>> component_array = hfss_app.add_3d_component_array_from_json(dict_in)
        """
        ...
    
    @pyaedt_function_handler()
    def get_antenna_ffd_solution_data(self, frequencies=..., setup=..., sphere=..., variations=..., overwrite=..., link_to_hfss=..., export_touchstone=..., set_phase_center_per_port=...): # -> FfdSolutionDataExporter | FfdSolutionData | Literal[False]:
        """Export the antenna parameters to Far Field Data (FFD) files and return an
        instance of the ``FfdSolutionDataExporter`` object.

        .. deprecated:: 0.9.8
        Use :func:`get_antenna_data` method instead.

        Parameters
        ----------
        frequencies : float, list, optional
            Frequency value or list of frequencies to compute far field data. The default is ``None,`` in which case
            all available frequencies are computed.
        setup : str, optional
            Name of the setup to use. The default is ``None,`` in which case ``nominal_adaptive`` is used.
        sphere : str, optional
            Infinite sphere to use. The default is ``None``, in which case an existing sphere is used or a new
            one is created.
        variations : dict, optional
            Variation dictionary. The default is ``None``, in which case the nominal variation is exported.
        overwrite : bool, optional
            Whether to overwrite FFD files. The default is ``True``.
        link_to_hfss : bool, optional
            Whether to return an instance of the
            :class:`ansys.aedt.core.generic.farfield_explorerf.FfdSolutionDataExporter` class,
            which requires a connection to an instance of the :class:`Hfss` class.
            The default is `` True``. If ``False``, returns an instance of
            :class:`ansys.aedt.core.generic.farfield_explorer.FfdSolutionData` class, which is
            independent of the running HFSS instance.
        export_touchstone : bool, optional
            Whether to export touchstone file. The default is ``False``.
        set_phase_center_per_port : bool, optional
            Set phase center per port location. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.visualization.post.farfield_exporter.FfdSolutionDataExporter`
            SolutionData object.
        """
        ...
    
    @pyaedt_function_handler()
    def get_antenna_data(self, frequencies=..., setup=..., sphere=..., variations=..., overwrite=..., link_to_hfss=..., export_touchstone=..., set_phase_center_per_port=...): # -> FfdSolutionDataExporter | FfdSolutionData | Literal[False]:
        """Export the antenna parameters to Far Field Data (FFD) files and return an
        instance of the ``FfdSolutionDataExporter`` object.

        For phased array cases, only one phased array is calculated.

        Parameters
        ----------
        frequencies : float, list, optional
            Frequency value or list of frequencies to compute far field data. The default is ``None,`` in which case
            all available frequencies are computed.
        setup : str, optional
            Name of the setup to use. The default is ``None,`` in which case ``nominal_adaptive`` is used.
        sphere : str, optional
            Infinite sphere to use. The default is ``None``, in which case an existing sphere is used or a new
            one is created.
        variations : dict, optional
            Variation dictionary. The default is ``None``, in which case the nominal variation is exported.
        overwrite : bool, optional
            Whether to overwrite FFD files. The default is ``True``.
        link_to_hfss : bool, optional
            Whether to return an instance of the
            :class:`ansys.aedt.core.visualization.advanced.farfield_exporter.FfdSolutionDataExporter` class,
            which requires a connection to an instance of the :class:`Hfss` class.
            The default is `` True``. If ``False``, returns an instance of
            :class:`ansys.aedt.core.visualization.advanced.farfield_visualization.FfdSolutionData` class, which is
            independent of the running HFSS instance.
        export_touchstone : bool, optional
            Whether to export touchstone file. The default is ``False``.
        set_phase_center_per_port : bool, optional
            Set phase center per port location. The default is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.visualization.advanced.farfield_visualization.FfdSolutionDataExporter`
            SolutionData object.

        Examples
        --------
        The method :func:`get_antenna_data` is used to export the farfield of each element of the design.

        Open a design and create the objects.

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> ffdata = hfss.get_antenna_data()
        >>> ffdata.farfield_data.plot_cut(primary_sweep="theta", theta=0, is_polar=False)
        """
        ...
    
    @pyaedt_function_handler()
    def get_rcs_data(self, frequencies=..., setup=..., expression=..., variations=..., overwrite=..., link_to_hfss=..., variation_name=...): # -> MonostaticRCSExporter | MonostaticRCSData | Literal[False]:
        """Export the radar cross-section data.

        This method returns an instance of the ``RcsSolutionDataExporter`` object.

        Parameters
        ----------
        frequencies : float, list, optional
            Frequency value or list of frequencies to compute the data. The default is ``None,`` in which case
            all available frequencies are computed.
        setup : str, optional
            Name of the setup to use. The default is ``None,`` in which case ``nominal_adaptive`` is used.
        expression : str, optional
            Monostatic expression name. The default value is ``"ComplexMonostaticRCSTheta"``.
        variations : dict, optional
            Variation dictionary. The default is ``None``, in which case the nominal variation is exported.
        overwrite : bool, optional
            Whether to overwrite metadata files. The default is ``True``.
        link_to_hfss : bool, optional
            Whether to return an instance of the
            :class:`ansys.aedt.core.visualization.post.rcs_exporter.MonostaticRCSExporter` class,
            which requires a connection to an instance of the :class:`Hfss` class.
            The default is `` True``. If ``False``, returns an instance of
            :class:`ansys.aedt.core.visualization.advanced.rcs_visualization.MonostaticRCSData` class, which is
            independent of the running HFSS instance.
        variation_name : str, optional
            Variation name. The default is ``None``, in which case the nominal variation is added.

        Returns
        -------
        :class:`ansys.aedt.core.post.rcs_exporter.MonostaticRCSExporter`
            SolutionData object.

        Examples
        --------
        The method :func:`get_antenna_data` is used to export the farfield of each element of the design.

        Open a design and create the objects.

        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> rcs_data = hfss.get_rcs_data()
        """
        ...
    
    @pyaedt_function_handler()
    def set_material_threshold(self, threshold=...): # -> Literal[True]:
        """Set the material conductivity threshold.

        Parameters
        ----------
        threshold : float, optional
            Conductivity threshold. The default value is ``100000``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(entity_list="assignment", simmetry_name="name")
    def assign_symmetry(self, assignment, name=..., is_perfect_e=...): # -> BoundaryObject:
        """Assign symmetry to planar entities.

        Parameters
        ----------
        assignment : list
            List of IDs or :class:`ansys.aedt.core.modeler.cad.elements_3d.FacePrimitive`.
        name : str, optional
            Name of the boundary.
            If a name is not provided, one is automatically generated.
        is_perfect_e : bool, optional
            Type of symmetry plane the boundary represents: Perfect E or Perfect H.
            The default value is ``True`` (Perfect E).

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignSymmetry

        Examples
        --------

        Create a box. Select the faces of this box and assign a symmetry.

        >>> symmetry_box = hfss.modeler.create_box([0, -100, 0], [200, 200, 200], name="SymmetryForFaces")
        >>> ids = [i.id for i in hfss.modeler["SymmetryForFaces"].faces]
        >>> symmetry = hfss.assign_symmetry(ids)
        >>> type(symmetry)
        <class 'from ansys.aedt.core.modules.boundary.common.BoundaryObject'>

        """
        ...
    
    @pyaedt_function_handler()
    def set_impedance_multiplier(self, multiplier: float) -> bool:
        """Set impedance multiplier.

        Parameters
        ----------
        multiplier : float
            Impedance Multiplier.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ChangeImpedanceMult

        Examples
        --------

        Create a box. Select the faces of this box and assign a symmetry.

        >>> symmetry_box = hfss.modeler.create_box([0, -100, 0], [200, 200, 200], name="SymmetryForFaces")
        >>> ids = [i.id for i in hfss.modeler["SymmetryForFaces"].faces]
        >>> symmetry = hfss.assign_symmetry(ids)
        >>> hfss.set_impedance_multiplier(2.0)

        """
        ...
    
    @pyaedt_function_handler()
    def set_phase_center_per_port(self, coordinate_system: list = ...) -> bool:
        """Set phase center per port.

        Parameters
        ----------
        coordinate_system : list
            List of the coordinate system per port. The default is ``None``, in which case the
            default port location is assigned.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.SetPhaseCenterPerPort

        Examples
        --------

        Set phase center of an antenna with two ports.

        >>> hfss.set_phase_center_per_port(["Global", "Global"])

        """
        ...
    
    @pyaedt_function_handler(filename="file_name")
    def parse_hdm_file(self, file_name): # -> Any | complex | list[complex] | list[Any] | tuple[Any, ...] | float | int | NDArray[Any] | list[Any | complex | float | int] | list[Any | complex | list[complex] | list[Any] | tuple[Any, ...] | NDArray[Any] | list[Any | complex | float | int]] | Literal[False]:
        """Parse an HFSS SBR+ or Creeping Waves ``hdm`` file.

        Parameters
        ----------
        file_name : str or :class:`pathlib.Path`
            Name of the file to parse.

        Returns
        -------
        :class:`ansys.aedt.core.modules.hdm_parser.Parser`
        """
        ...
    
    @pyaedt_function_handler(filename="file_name")
    def get_hdm_plotter(self, file_name=...): # -> HDMPlotter:
        """Get the HDM plotter.

        Parameters
        ----------
        file_name : str, optional


        Returns
        -------
        :class:`ansys.aedt.core.sbrplus.plot.HDMPlotter`

        """
        ...
    
    @pyaedt_function_handler(signal="assignment")
    def circuit_port(self, assignment, reference, port_location=..., impedance=..., name=..., renormalize=..., renorm_impedance=..., deembed=...): # -> BoundaryObject:
        """Create a circuit port from two objects.

        The integration line is from edge 2 to edge 1.

        Parameters
        ----------
        assignment : int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d` or
         :class:`ansys.aedt.core.modeler.cad.FacePrimitive`or :class:`ansys.aedt.core.modeler.cad.EdgePrimitive`
            Signal object.
        reference : int or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d` or
         :class:`ansys.aedt.core.modeler.cad.FacePrimitive`or :class:`ansys.aedt.core.modeler.cad.EdgePrimitive`
            Reference object.
        port_location : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Position of the port when an object different from an edge is provided.
            It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
        name : str, optional
            Name of the port. The default is ``""``.
        impedance : int, str, or float, optional
            Impedance. The default is ``"50"``. You can also
            enter a string that looks like this: ``"50+1i*55"``.
        renormalize : bool, optional
            Whether to renormalize the mode. The default is ``False``.
            This parameter is ignored for a driven terminal.
        renorm_impedance :  str, optional
            Impedance. The default is ``50``.
        deembed : bool, optional
            Whether to deembed the port. The default is ``False``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Boundary object.

        References
        ----------
        >>> oModule.AssignCircuitPort

        Examples
        --------

        Create two rectangles in the XY plane.
        Select the first edge of each rectangle created previously.
        Create a circuit port from the first edge of the first rectangle
        toward the first edge of the second rectangle.

        >>> plane = hfss.PLANE.XY
        >>> rectangle1 = hfss.modeler.create_rectangle(plane, [10, 10, 10], [10, 10], name="rectangle1_for_port")
        >>> edges1 = hfss.modeler.get_object_edges(rectangle1.id)
        >>> first_edge = edges1[0]
        >>> rectangle2 = hfss.modeler.create_rectangle(plane, [30, 10, 10], [10, 10], name="rectangle2_for_port")
        >>> edges2 = hfss.modeler.get_object_edges(rectangle2.id)
        >>> second_edge = edges2[0]
        >>> hfss.solution_type = "Modal"
        >>> hfss.circuit_port(
        ...     first_edge, second_edge, impedance=50.1, name="PortExample", renormalize=False, renorm_impedance="50"
        ... )
        'PortExample'
        """
        ...
    
    @pyaedt_function_handler(signal="assignment")
    def lumped_port(self, assignment, reference=..., create_port_sheet=..., port_on_plane=..., integration_line=..., impedance=..., name=..., renormalize=..., deembed=..., terminals_rename=...): # -> BoundaryObject:
        """Create a waveport taking the closest edges of two objects.

        Parameters
        ----------
        assignment : str, int, list, :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d` or
            :class:`ansys.aedt.core.modeler.cad.elements_3d.FacePrimitive`
            Main object for port creation or starting object for the integration line.
        reference : int, list or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
        create_port_sheet : bool, optional
            Whether to create a port sheet or use given start_object as port sheet.
        integration_line : int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Position of the port. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
            The default is ``Application.AxisDir.XNeg``.
            It can also be a list of 2 points.
        port_on_plane : bool, optional
            Whether to create the source on the plane orthogonal to ``AxisDir``.
            The default is ``True``.
        impedance : float, optional
            Port impedance. The default is ``50``.
        name : str, optional
            Name of the port. The default is ``None``.
        renormalize : bool, optional
            Whether to renormalize the mode. The default is ``True``.
        deembed : float, optional
            Deembed distance in millimeters. The default is ``0``, in which case deembed is disabled.
        terminals_rename : bool, optional
            Modify terminals name with the port name plus the terminal number. The default value is ``True``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Port object.

        Examples
        --------

        Create two boxes that will be used to create a lumped port
        named ``'LumpedPort'``.

        >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5], "BoxLumped1", "copper")
        >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5], "BoxLumped2", "copper")
        >>> hfss.lumped_port("BoxLumped1", "BoxLumped2", hfss.AxisDir.XNeg, 50, "LumpedPort", True, False)
        PyAEDT INFO: Connection Correctly created
        'LumpedPort'

        """
        ...
    
    @pyaedt_function_handler(signal="assignment", num_modes="modes")
    def wave_port(self, assignment, reference=..., create_port_sheet=..., create_pec_cap=..., integration_line=..., port_on_plane=..., modes=..., impedance=..., name=..., renormalize=..., deembed=..., is_microstrip=..., vfactor=..., hfactor=..., terminals_rename=..., characteristic_impedance=...): # -> BoundaryObject:
        """Create a waveport from a sheet (``start_object``) or taking the closest edges of two objects.

        Parameters
        ----------
        assignment : int, str, :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d` or
         :class:`ansys.aedt.core.modeler.cad.elements_3d.FacePrimitive`
            Main object for port creation or starting object for the integration line.
        reference : int, str, list or :class:`ansys.aedt.core.modeler.cad.object_3d.Object3d`
            Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
        create_port_sheet : bool, optional
            Whether to create a port sheet or use the start object as the surface
            to create the port. The default is ``False``.
        create_pec_cap : bool, False
            Whether to create a port cap. The default is ``False``.
        integration_line : list or int or :class:`ansys.aedt.core.application.analysis.Analysis.AxisDir`, optional
            Position of the integration. It should be one of the values for ``Application.AxisDir``,
            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``
            The default is ``Application.AxisDir.XNeg``.
            It can also be a list of 2 points.
        port_on_plane : bool, optional
            Whether to create the source on the plane orthogonal to ``AxisDir``.
            The default is ``True``.
        impedance : float, optional
            Port impedance. The default is ``50``.
        modes : int, optional
            Number of modes. The default is ``1``.
        name : str, optional
            Name of the port. The default is ``None``, in which
            case a name is automatically assigned.
        renormalize : bool, optional
            Whether to renormalize the mode. The default is ``True``.
        deembed : float, optional
            Deembed distance in millimeters. The default is ``0``.
        is_microstrip : bool, optional
            Whether if the wave port will be created and is a microstrip port.
            The default is ``False``.
        vfactor : int, optional
            Port vertical factor. Only valid if ``is_microstrip`` is enabled. The default is ``3``.
        hfactor : int, optional
            Port horizontal factor. Only valid if ``is_microstrip`` is enabled. The default is ``5``.
        terminals_rename : bool, optional
            Modify terminals name with the port name plus the terminal number. The default is ``True``.
        characteristic_impedance : str or list, optional
            Characteristic impedance for each mode. Available options are `"Zpi"``,`"Zpv"``, `"Zvi"``, and `"Zwave"``.
            The default is ``"Zpi"``.

        Returns
        -------
        :class:`ansys.aedt.core.modules.boundary.common.BoundaryObject`
            Port object.

        References
        ----------
        >>> oModule.AssignWavePort

        Examples
        --------

        Create a wave port supported by a microstrip line.

        >>> import ansys.aedt.core
        >>> hfss = ansys.aedt.core.Hfss()
        >>> ms = hfss.modeler.create_box([4, 5, 0], [1, 100, 0.2], name="MS1", material="copper")
        >>> sub = hfss.modeler.create_box([0, 5, -2], [20, 100, 2], name="SUB1", material="FR4_epoxy")
        >>> gnd = hfss.modeler.create_box([0, 5, -2.2], [20, 100, 0.2], name="GND1", material="FR4_epoxy")
        >>> port = hfss.wave_port("GND1", "MS1", integration_line=1, name="MS1")

        Create a wave port in a circle.

        >>> import ansys.aedt.core
        >>> hfss = ansys.aedt.core.Hfss()
        >>> c = hfss.modeler.create_circle("Z", [-1.4, -1.6, 0], 1, name="wave_port")
        >>> start = [["-1.4mm", "-1.6mm", "0mm"], ["-1.4mm", "-1.6mm", "0mm"]]
        >>> end = [["-1.4mm", "-0.6mm", "0mm"], ["-1.4mm", "-2.6mm", "0mm"]]
        >>> port = hfss.wave_port(c.name, integration_line=[start, end], characteristic_impedance=["Zwave", "Zpv"])

        """
        ...
    
    @pyaedt_function_handler()
    def plane_wave(self, assignment=..., vector_format=..., origin=..., polarization=..., propagation_vector=..., wave_type=..., wave_type_properties=..., name=...) -> BoundaryObject:
        """Create a plane wave excitation.

        Parameters
        ----------
        assignment : str or list, optional
            One or more objects or faces to assign finite conductivity to. The default is ``None``, in which
            case the excitation is assigned to anything.
        vector_format : str, optional
            Vector input format. Options are ``"Spherical"`` or ``"Cartesian"``. The default is ``"Spherical"``.
        origin : list, optional
            Excitation location and zero phase position. The default is ``["0mm", "0mm", "0mm"]``.
        polarization : str or list, optional
            Electric field polarization vector. If ``"Vertical"`` or ``"Horizontal"`` is passed, the method computes
            the electric polarization vector.
            If a ``list`` is passed, the user can customize the input vector. If ``vector_format`` is ``"Cartesian"``,
            the vector has three coordinates which corresponds to ``["Ex", "Ey", "Ez"]``.
            If ``vector_format`` is ``"Spherical"``, the vector has two coordinates which corresponds to
            ``["Ephi", "Etheta"]``.
            The default is ``"Vertical"``.
        propagation_vector : list, optional
            Propagation vector.
            If ``vector_format`` is ``"Cartesian"`` the type must be a ``list`` with three elements.
            If ``vector_format`` is ``"Spherical"`` the type must be a ``list`` with two elements. The first element
            corresponds to the phi sweep, which must be a ``list`` of three elements: start, stop, and number of points.
            The second element has the same format, it corresponds to the theta sweep.
            The default is ``[0.0, 0.0, 1.0]`` for ``"Cartesian"`` and
            ``[["0.0deg", "0.0deg", 1], ["0.0deg", "0.0deg", 1]]`` for ``"Spherical"``.
        wave_type : str, optional
            Type of plane wave. Options are ``"Propagating"``, ``"Evanescent"``,  or ``"Elliptical"``.
            The default is ``"Propagating"``.
        wave_type_properties : list, optional
            Properties of the plane wave type.
            If ``"Propagating"`` is used, no additional properties are needed. The default is ``None``.
            If ``"Evanescent"`` is selected, the propagation constant is expressed as both real and
            imaginary components. The default is ``[0.0, 1.0]``.
            If ``"Elliptical"`` is used, the polarization angle and ratio are defined. The default is
            ``["0deg", 1.0]``.
        name : str, optional
            Name of the excitation. The default is ``None``, in which
            case a name is automatically assigned.

        Returns
        -------
        :class:`pyaedt.modules.Boundary.BoundaryObject`
            Port object.

        References
        ----------
        >>> oModule.AssignPlaneWave

        Examples
        --------

        Create a plane wave excitation.

        >>> port1 = hfss.plane_wave(vector_format="Spherical",
         ...                        polarization="Vertical",
         ...                        propagation_vector=[["0deg","90deg", 25], ["0deg","0deg", 1]])
        >>> port2 = hfss.plane_wave(vector_format="Cartesian",
         ...                        polarization=[1, 1, 0], propagation_vector=[0, 0, 1])
        """
        ...
    
    @pyaedt_function_handler()
    def hertzian_dipole_wave(self, assignment=..., origin=..., polarization=..., is_electric=..., radius=..., name=...) -> BoundaryObject:
        """Create a hertzian dipole wave excitation.

        The excitation is assigned in the assigned sphere. Inside this sphere, the field magnitude
        is equal to the field magnitude calculated on the surface of the sphere.

        Parameters
        ----------
        assignment : str or list, optional
            One or more objects or faces to assign finite conductivity to. The default is ``None``, in which
            case the excitation is assigned to anything.
        origin : list, optional
            Excitation location. The default is ``["0mm", "0mm", "0mm"]``.
        polarization : list, optional
            Electric field polarization vector.
            The default is ``[0, 0, 1]``.
        is_electric : bool, optional
            Type of dipole. Electric dipole if ``True``, magnetic dipole if ``False``. The default is ``True``.
        radius : str or float, optional
            Radius of surrounding sphere. The default is "10mm".
        name : str, optional
            Name of the boundary.

        Returns
        -------
        :class:`pyaedt.modules.Boundary.BoundaryObject`
            Port object.

        References
        ----------
        >>> oModule.AssignHertzianDipoleWave

        Examples
        --------

        Create a hertzian dipole wave excitation.
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> sphere = hfss.modeler.primitives.create_sphere([0, 0, 0], 10)
        >>> port1 = hfss.hertzian_dipole_wave(assignment=sphere, radius=10)
        """
        ...
    
    @pyaedt_function_handler()
    def set_radiated_power_calc_method(self, method=...): # -> Literal[True]:
        """Set the radiated power calculation method in Hfss.

        method : str, optional
            Radiated power calculation method.
            The options are ``"Auto"``, ``"Radiation Surface Integral"`` and ``"Far Field Integral"``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """
        ...
    
    @pyaedt_function_handler(component="assignment")
    def set_mesh_fusion_settings(self, assignment: list | str = ..., volume_padding: list = ..., priority: list = ...) -> bool:
        """Set mesh fusion settings in HFSS.

        component : list, optional
            List of active 3D Components.
            The default is ``None``, in which case components are disabled.
        volume_padding : list, optional
            List of mesh envelope padding, the format is ``[+x, -x, +y, -y, +z, -z]``.
            The default is ``None``, in which case all zeros are applied.
        priority : list, optional
            List of components with the priority flag enabled. The default is ``None``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetDoMeshAssembly

        Examples
        --------

        >>> import ansys.aedt.core
        >>> app = ansys.aedt.core.Hfss()
        >>> app.set_mesh_fusion_settings(assignment=["Comp1", "Comp2"],
        >>>                              volume_padding=[[0,0,0,0,0,0], [0,0,5,0,0,0]],priority=["Comp1"])
        """
        ...
    
    @pyaedt_function_handler()
    def export_element_pattern(self, frequencies, setup, sphere, variations=..., element_name=..., output_dir=...): # -> Literal[True]:
        """Export the element pattern.

        For phased array cases, only one phased array is calculated.

        Parameters
        ----------
        frequencies : float, list
            Frequency value or list of frequencies to compute far field data.
        setup : str
            Name of the setup to use.
        sphere : str
            Infinite sphere to use.
        variations : dict, optional
            Variation dictionary. The default is ``None``, in which case the nominal variation is exported.
        element_name : str, optional
            Element pattern file name. The default is ``"element"``.
        output_dir : str, optional
            Path to export the element patterns to. The default is ``None``, in which
            case the files are exported to the working_directory path.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ExportElementPatternToFile
        """
        ...
    
    @pyaedt_function_handler()
    def export_antenna_metadata(self, frequencies, setup, sphere, variations=..., output_dir=..., export_element_pattern=..., export_objects=..., export_touchstone=..., export_power=...): # -> Literal[True]:
        """Export the element pattern.

        For phased array cases, only one phased array is calculated.

        Parameters
        ----------
        frequencies : float, list
            Frequency value or list of frequencies to compute far field data.
        setup : str
            Name of the setup to use.
        sphere : str
            Infinite sphere to use.
        variations : dict, optional
            Variation dictionary. The default is ``None``, in which case the nominal variation is exported.
        output_dir : str, optional
            Path to export the element patterns to. The default is ``None``, in which
            case the files are exported to the working_directory path.
        export_element_pattern : bool, optional
            Whether to export the element patterns. The default is ``True``.
        export_objects : bool, optional
            Whether to export the objects. The default is ``False``.
        export_touchstone : bool, optional
            Whether to export touchstone file. The default is ``True``.
        export_power : bool, optional
            Whether to export all available powers: ``IncidentPower``, ``RadiatedPower``, ``AcceptedPower``.
            The default is ``False``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ExportMetadata
        """
        ...
    
    @pyaedt_function_handler()
    def export_touchstone_on_completion(self, export=..., output_dir=...): # -> Literal[True]:
        """Enable or disable the automatic export of the touchstone file after completing frequency sweep.

        Parameters
        ----------
        export : bool, optional
            Whether to export the Touchstone file after the simulation.
            The default is ``True``.
        output_dir : str, optional
            Path to the directory of exported file. The default is the project path.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oDesign.SetDesignSettings
        """
        ...
    
    @pyaedt_function_handler()
    def set_export_touchstone(self, file_format=..., enforce_passivity=..., enforce_causality=..., use_common_ground=..., show_gamma_comments=..., renormalize=..., impedance=..., fitting_error=..., maximum_poles=..., passivity_type=..., column_fitting_type=..., state_space_fitting=..., relative_error_tolerance=..., ensure_accurate_fit=..., touchstone_output=..., units=..., precision=...): # -> Literal[True]:
        """Set or disable the automatic export of the touchstone file after completing frequency sweep.

        Parameters
        ----------
        file_format : str, optional
            Touchstone format. Available options are: ``"TouchStone1.0"``, and ``"TouchStone2.0"``.
            The default is ``"TouchStone1.0"``.
        enforce_passivity : bool, optional
            Enforce passivity. The default is ``True``.
        enforce_causality : bool, optional
            Enforce causality. The default is ``False``.
        use_common_ground : bool, optional
            Use common ground. The default is ``True``.
        show_gamma_comments : bool, optional
            Show gamma comments. The default is ``True``.
        renormalize : bool, optional
            Renormalize. The default is ``False``.
        impedance : float, optional
            Impedance in ohms. The default is ``50.0``.
        fitting_error : float, optional
            Fitting error. The default is ``0.5``.
        maximum_poles : int, optional
            Maximum number of poles. The default is ``10000``.
        passivity_type : str, optional
            Passivity type. Available options are: ``"PassivityByPerturbation"``, ``"IteratedFittingOfPV"``,
            ``"IteratedFittingOfPVLF"``, and ``"ConvexOptimization"``.
        column_fitting_type : str, optional
            Column fitting type. Available options are: ``"Matrix"``, `"Column"``, and `"Entry"``.
        state_space_fitting : str, optional
            State space fitting algorithm. Available options are: ``"IterativeRational"``, `"TWA"``, and `"FastFit"``.
        relative_error_tolerance : bool, optional
            Relative error tolerance. The default is ``True``.
        ensure_accurate_fit : bool, optional
            Ensure accurate impedance fit. The default is ``False``.
        touchstone_output : str, optional
            Touchstone output format. Available options are: ``"MA"`` for magnitude and phase in ``deg``,
            ``"RI"`` for real and imaginary part, and ``"DB"`` for magnitude in ``dB`` and phase in ``deg``.
        units : str, optional
            Frequency units. The default is ``"GHz"``.
        precision : int, optional
            Touchstone precision. The default is ``11``.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oTool.SetExportTouchstoneOptions

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> hfss.export_touchstone_on_completion()
        >>> hfss.export_touchstone_on_completion()


        """
        ...
    
    @pyaedt_function_handler()
    def import_table(self, input_file, name, is_real_imag=..., is_field=..., column_names=..., independent_columns=...): # -> Literal[True]:
        """Import a data table.

            The table can have multiple independent real-valued columns of data,
            and multiple dependent real- or complex-valued columns of data.
            The data supported is comma delimited format (.csv).
            The first row may contain column names. Complex data columns are inferred from the column data format.
            In comma delimited format, "(double, double)" denotes a complex number.

        Parameters
        ----------
        input_file : str
            Full path to the file. Supported formats is ``".csv"``.
        name : str
            Table name.
        is_real_imag : bool, optional
            Whether to use real and imaginary to interpret data for any complex column. If ``False``, then use
            magnitude and phase in degrees. The default is ``True``.
        is_field : bool, optional
            Whether to matrix data. If ``True``, then use field data. The default is ``False``.
        column_names : list, optional
            Column names. The default is ``None``, in which case column names obtained from data file are assigned.
        independent_columns : list, optional
            Indicates which columns are independent. If ``None``, only the first column is independent.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.ImportTable

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> hfss.import_table(input_file="my_file.csv")
        """
        ...
    
    @pyaedt_function_handler()
    def delete_table(self, name): # -> Literal[True]:
        """Delete data table.

        Parameters
        ----------
        name : str or list of str
            Table name to delete.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.

        References
        ----------
        >>> oModule.DeleteImportData

        Examples
        --------
        >>> from ansys.aedt.core import Hfss
        >>> hfss = Hfss()
        >>> hfss.import_table(name="Table1")
        """
        ...
    


